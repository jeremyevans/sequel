<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>object_model.rdoc</title>
    <meta content='text/html; charset=US-ASCII' http-equiv='Content-Type'>
    <link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='file' id='wrapper'>
      <div class='header'>
        <h1 class='name'>object_model.rdoc</h1>
        <div class='paths'>
          doc/object_model.rdoc
        </div>
        <div class='last-update'>
          Last Update:
          <span class='datetime'>2013-10-21 11:50:03 -0700</span>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <h1 id="label-The+Sequel+Object+Model">The <a href="../../classes/Sequel.html">Sequel</a> Object Model</h1>
            
            <p>Sequel&#39;s dataset layer is mostly structured as an DSL, so it often
            obscures what actual objects are being used.  For example, you don&#39;t
            usually create <a href="../../classes/Sequel.html">Sequel</a> objects by
            calling new on the object&#39;s class (other than <a
            href="../../classes/Sequel/Model.html">Sequel::Model</a> instances). 
            However, just as almost everything in ruby is an object, all  the methods
            you call in <a href="../../classes/Sequel.html">Sequel</a> deal with
            objects behind the scenes.</p>
            
            <p>There are five main types of Sequel-specific objects that you deal with in
            Sequel:</p>
            <ul><li>
            <p><a href="../../classes/Sequel/Database.html">Sequel::Database</a></p>
            </li><li>
            <p><a href="../../classes/Sequel/Dataset.html">Sequel::Dataset</a></p>
            </li><li>
            <p><a href="../../classes/Sequel/Model.html">Sequel::Model</a></p>
            </li><li>
            <p>Standard Ruby Types</p>
            </li><li>
            <p><a
            href="../../classes/Sequel/SQL/Expression.html">Sequel::SQL::Expression</a>
            (and subclasses)</p>
            </li></ul>
            
            <h2 id="label-Sequel%3A%3ADatabase"><a href="../../classes/Sequel/Database.html">Sequel::Database</a></h2>
            
            <p><a href="../../classes/Sequel/Database.html">Sequel::Database</a> is the
            main <a href="../../classes/Sequel.html">Sequel</a> object that you deal
            with.  It&#39;s usually created by the <a
            href="../../classes/Sequel.html#method-c-connect">Sequel.connect</a>
            method:</p>
            
            <pre>DB = Sequel.connect(&#39;postgres://host/database&#39;)</pre>
            
            <p>A <a href="../../classes/Sequel/Database.html">Sequel::Database</a> object
            represents the database you are connecting to. <a
            href="../../classes/Sequel/Database.html">Sequel::Database</a> handles
            things like <a href="../../classes/Sequel/Dataset.html">Sequel::Dataset</a>
            creation,</p>
            
            <pre>dataset = DB[:table]</pre>
            
            <p>schema modification,</p>
            
            <pre>DB.create_table(:table) do&#x000A;  primary_key :id&#x000A;  String :name&#x000A;end</pre>
            
            <p>and transactions:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">transaction</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">insert</span>(:<span class="ruby-identifier">column=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">value</span>)&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p><a
            href="../../classes/Sequel/Database.html#method-i-literal">Sequel::Database#literal</a>
            can be used to take any object that <a
            href="../../classes/Sequel.html">Sequel</a> handles and literalize the
            object to an SQL string fragment:</p>
            
            <pre>DB.literal(DB[:table]) # (SELECT * FROM &quot;table&quot;)</pre>
            
            <h2 id="label-Sequel%3A%3ADataset"><a href="../../classes/Sequel/Dataset.html">Sequel::Dataset</a></h2>
            
            <p><a href="../../classes/Sequel/Dataset.html">Sequel::Dataset</a> objects
            represent SQL queries, or more generally, they represent abstract
            collections of rows in the database.  They are usually created from a <a
            href="../../classes/Sequel/Database.html">Sequel::Database</a> object:</p>
            
            <pre>dataset = DB[:table]         # SELECT * FROM &quot;table&quot;&#x000A;dataset = DB.from(table)     # SELECT * FROM &quot;table&quot;&#x000A;dataset = DB.select(:column) # SELECT &quot;column&quot;</pre>
            
            <p>Most <a href="../../classes/Sequel/Dataset.html">Sequel::Dataset</a>
            methods return modified copies of the receiver, and the general way to
            build queries in <a href="../../classes/Sequel.html">Sequel</a> is via a
            method chain:</p>
            
            <pre class="ruby"><span class="ruby-identifier">dataset</span> = <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">test</span>].&#x000A;            <span class="ruby-identifier">select</span>(:<span class="ruby-identifier">column1</span>, :<span class="ruby-identifier">column2</span>).&#x000A;            <span class="ruby-identifier">where</span>(:<span class="ruby-identifier">column3</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">4</span>).&#x000A;            <span class="ruby-identifier">order</span>(:<span class="ruby-identifier">column5</span>)</pre>
            
            <p>Such a method chain is a more direct way of doing:</p>
            
            <pre class="ruby"><span class="ruby-identifier">dataset</span> = <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">test</span>]&#x000A;<span class="ruby-identifier">dataset</span> = <span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">select</span>(:<span class="ruby-identifier">column1</span>, :<span class="ruby-identifier">column2</span>)&#x000A;<span class="ruby-identifier">dataset</span> = <span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">column3</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">4</span>)&#x000A;<span class="ruby-identifier">dataset</span> = <span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">order</span>(:<span class="ruby-identifier">column5</span>)</pre>
            
            <p>When you are ready to execute your query, you call one of the <a
            href="../../classes/Sequel/Dataset.html">Sequel::Dataset</a> action
            methods.  For returning rows, you can do:</p>
            
            <pre class="ruby"><span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">first</span>&#x000A;<span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">all</span>&#x000A;<span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">row</span><span class="ruby-operator">|</span> <span class="ruby-identifier">row</span>}</pre>
            
            <p>For inserting, updating, or deleting rows, you can do:</p>
            
            <pre class="ruby"><span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">insert</span>(:<span class="ruby-identifier">column=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">value</span>)&#x000A;<span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">column=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">value</span>)&#x000A;<span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">delete</span></pre>
            
            <p>All datasets are related to their database object, which you can access via
            the <a
            href="../../classes/Sequel/Dataset.html#attribute-i-db">Sequel::Dataset#db</a>
            method:</p>
            
            <pre class="ruby"><span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">db</span> <span class="ruby-comment"># =&gt; DB</span></pre>
            
            <h2 id="label-Sequel%3A%3AModel"><a href="../../classes/Sequel/Model.html">Sequel::Model</a></h2>
            
            <p><a href="../../classes/Sequel/Model.html">Sequel::Model</a> objects are
            wrappers around a particular <a
            href="../../classes/Sequel/Dataset.html">Sequel::Dataset</a> object that
            add custom behavior, both custom behavior for the entire set of rows in the
            dataset (the model&#39;s class methods), custom behavior for a subset of
            rows in the dataset (the model&#39;s dataset methods), and custom behavior
            for single rows in the dataset (the model&#39;s instance methods).</p>
            
            <p>Unlike most other <a href="../../classes/Sequel.html">Sequel</a> objects,
            <a href="../../classes/Sequel/Model.html">Sequel::Model</a> classes and
            instances are generally created by the user using standard ruby syntax:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-identifier">album</span> = <span class="ruby-constant">Album</span>.<span class="ruby-identifier">new</span></pre>
            
            <p>All model classes are related to their <a
            href="../../classes/Sequel/Dataset.html">Sequel::Dataset</a> object, which
            you can access via the Sequel::Model.dataset method:</p>
            
            <pre>Album.dataset # SELECT * FROM &quot;albums&quot;</pre>
            
            <p>Additionally, all model classes are related to their dataset&#39;s <a
            href="../../classes/Sequel/Database.html">Sequel::Database</a> object,
            which you can access via the Sequel::Model.db method:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">db</span> <span class="ruby-comment"># =&gt; DB</span></pre>
            
            <h2 id="label-Standard+Ruby+Types">Standard Ruby Types</h2>
            
            <p>Where possible, <a href="../../classes/Sequel.html">Sequel</a> uses
            ruby&#39;s standard types to represent SQL concepts. In the examples here,
            the text to the right side of the # sign is the output if you pass the left
            side to <a
            href="../../classes/Sequel/Database.html#method-i-literal">Sequel::Database#literal</a>.</p>
            
            <h3 id="label-Symbol"><a href="../../classes/Symbol.html">Symbol</a></h3>
            
            <p>For example, ruby symbols represent SQL identifiers (tables, columns,
            schemas):</p>
            
            <pre>:table  # &quot;table&quot;&#x000A;:column # &quot;column&quot;</pre>
            
            <p>However, they can also represent qualified identifiers by including a
            double underscore inside a symbol:</p>
            
            <pre>:table__column # &quot;table&quot;.&quot;column&quot;</pre>
            
            <p>They can also represent an aliased identifier by including a triple
            underscore inside a symbol:</p>
            
            <pre>:column___alias # &quot;column&quot; AS &quot;alias&quot;</pre>
            
            <p>You can combine both qualification and aliasing by using a double
            underscore and a triple underscore:</p>
            
            <pre>:table__column___alias # &quot;table&quot;.&quot;column&quot; AS &quot;alias&quot;</pre>
            
            <h3 id="label-Integer%2C+Float%2C+BigDecimal%2C+String%2C+Date%2C+Time%2C+DateTime">Integer, Float, BigDecimal, <a href="../../classes/String.html">String</a>, Date, Time, DateTime</h3>
            
            <p>Ruby&#39;s Integer, Float, BigDecimal, <a
            href="../../classes/String.html">String</a>, Date, Time, and DateTime
            classes represent similar types in SQL:</p>
            
            <pre>1                     # 1&#x000A;1.0                   # 1.0&#x000A;BigDecimal.new(&#39;1.0&#39;) # 1.0&#x000A;&quot;string&quot;              # &#39;string&#39;&#x000A;Date.new(2012, 5, 6)  # &#39;2012-05-06&#39;&#x000A;Time.now              # &#39;2012-05-06 10:20:30&#39;&#x000A;DateTime.now          # &#39;2012-05-06 10:20:30&#39;</pre>
            
            <h3 id="label-Hash"><a href="../../classes/Hash.html">Hash</a></h3>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> generally uses hash objects
            to represent equality:</p>
            
            <pre class="ruby">{:<span class="ruby-identifier">column</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>} <span class="ruby-comment"># (&quot;column&quot; = 1)</span></pre>
            
            <p>However, if you use in array as the hash value, it will usually be used to
            represent inclusion:</p>
            
            <pre class="ruby">{:<span class="ruby-identifier">column</span> =<span class="ruby-operator">&gt;</span> [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]} <span class="ruby-comment"># (&quot;column&quot; IN (1, 2, 3))</span></pre>
            
            <p>You can also use a <a
            href="../../classes/Sequel/Dataset.html">Sequel::Dataset</a> instance as
            the hash value, which will be used to represent inclusion in the subselect:</p>
            
            <pre class="ruby">{:<span class="ruby-identifier">column</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">select</span>(:<span class="ruby-identifier">column</span>)} <span class="ruby-comment"># (&quot;column&quot; IN (SELECT &quot;column&quot; FROM &quot;table&quot;))</span></pre>
            
            <p>If you pass true, false, or nil as the hash value, it will be used to
            represent identity:</p>
            
            <pre class="ruby">{:<span class="ruby-identifier">column</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">nil</span>} <span class="ruby-comment"># (&quot;column&quot; IS NULL)</span></pre>
            
            <p>If you pass a Range object, it will be used as the bounds for a greater
            than and less than operation:</p>
            
            <pre class="ruby">{:<span class="ruby-identifier">column</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>} <span class="ruby-comment"># ((&quot;column&quot; &gt;= 1) AND (&quot;column&quot; &lt;= 2))</span>&#x000A;{:<span class="ruby-identifier">column</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span><span class="ruby-operator">...</span><span class="ruby-value">3</span>} <span class="ruby-comment"># ((&quot;column&quot; &gt;= 1) AND (&quot;column&quot; &lt; 3))</span></pre>
            
            <p>If you pass a Regexp object as the value, it will be used as a regular
            expression operation (only supported on PostgreSQL and MySQL currently):</p>
            
            <pre class="ruby">{:<span class="ruby-identifier">column</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-regexp">/a.*b/</span>} <span class="ruby-comment"># (&quot;column&quot; ~ &#39;a.*b&#39;)</span></pre>
            
            <h3 id="label-Array"><a href="../../classes/Array.html">Array</a></h3>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> generally treats arrays as
            an SQL value list:</p>
            
            <pre>[1, 2, 3] # (1, 2, 3)</pre>
            
            <p>However, if all members of the array are arrays with two members, then the
            array is treated like a hash:</p>
            
            <pre>[[:column, 1]] # (&quot;column&quot; = 1)</pre>
            
            <p>The advantage of using an array over a hash for such a case is that a hash
            cannot include multiple objects with the same key, while the array can.</p>
            
            <h2 id="label-Sequel%3A%3ASQL%3A%3AExpression+%28and+subclasses%29"><a href="../../classes/Sequel/SQL/Expression.html">Sequel::SQL::Expression</a> (and subclasses)</h2>
            
            <p>If <a href="../../classes/Sequel.html">Sequel</a> needs to represent an SQL
            concept that does not map directly to an existing ruby class, it will
            generally use a <a
            href="../../classes/Sequel/SQL/Expression.html">Sequel::SQL::Expression</a>
            subclass to represent that concept.</p>
            
            <p>Some of the examples below show examples that require the <a
            href="core_extensions_rdoc.html">core_extensions extension</a></p>
            
            <h3 id="label-Sequel%3A%3ALiteralString"><a href="../../classes/Sequel/LiteralString.html">Sequel::LiteralString</a></h3>
            
            <p><a href="../../classes/Sequel/LiteralString.html">Sequel::LiteralString</a>
            is not actually a <a
            href="../../classes/Sequel/SQL/Expression.html">Sequel::SQL::Expression</a>
            subclass.  It is a subclass of <a
            href="../../classes/String.html">String</a>, but it is treated specially by
            <a href="../../classes/Sequel.html">Sequel</a>, in that it is treated as
            literal SQL code, instead of as an SQL string that needs to be escaped:</p>
            
            <pre>Sequel::LiteralString.new(&quot;co&#39;de&quot;) # co&#39;de</pre>
            
            <p>The following shortcuts exist for creating <a
            href="../../classes/Sequel/LiteralString.html">Sequel::LiteralString</a>
            objects:</p>
            
            <pre>Sequel.lit(&quot;co&#39;de&quot;)&#x000A;&quot;co&#39;de&quot;.lit # core_extensions extension</pre>
            
            <h3 id="label-Sequel%3A%3ASQL%3A%3ABlob"><a href="../../classes/Sequel/SQL/Blob.html">Sequel::SQL::Blob</a></h3>
            
            <p><a href="../../classes/Sequel/SQL/Blob.html">Sequel::SQL::Blob</a> is also
            a <a href="../../classes/String.html">String</a> subclass, but it is
            treated as an SQL blob instead of an SQL string, as SQL blobs often have
            different literalization rules than SQL strings do:</p>
            
            <pre>Sequel::SQL::Blob.new(&quot;blob&quot;)</pre>
            
            <p>The following shortcuts exist for creating <a
            href="../../classes/Sequel/SQL/Blob.html">Sequel::SQL::Blob</a> objects:</p>
            
            <pre>Sequel.blob(&quot;blob&quot;)&#x000A;&quot;blob&quot;.to_sequel_blob  # core_extensions extension</pre>
            
            <h3 id="label-Sequel%3A%3ASQLTime"><a href="../../classes/Sequel/SQLTime.html">Sequel::SQLTime</a></h3>
            
            <p><a href="../../classes/Sequel/SQLTime.html">Sequel::SQLTime</a> is a Time
            subclass.  However, it is treated specially by <a
            href="../../classes/Sequel.html">Sequel</a> in that only the time component
            is literalized, not the date part.  This type is used to represent SQL time
            types, which do not contain date information.</p>
            
            <pre>Sequel::SQLTime.create(10, 20, 30) # &quot;10:20:30&quot;</pre>
            
            <h3 id="label-Sequel%3A%3ASQL%3A%3AValueList"><a href="../../classes/Sequel/SQL/ValueList.html">Sequel::SQL::ValueList</a></h3>
            
            <p><a
            href="../../classes/Sequel/SQL/ValueList.html">Sequel::SQL::ValueList</a>
            objects always represent SQL value lists.  Most ruby arrays represent value
            lists in SQL, except that arrays of two-element arrays are treated similar
            to hashes.  Such arrays can be wrapped in this class to ensure they are
            treated as value lists.  This is important when doing a composite key IN
            lookup, which some databases support.  <a
            href="../../classes/Sequel/SQL/ValueList.html">Sequel::SQL::ValueList</a>
            is an <a href="../../classes/Array.html">::Array</a> subclass with no
            additional behavior, so it can be instantiated like a normal array:</p>
            
            <pre>Sequel::SQL::ValueList.new([[1, 2], [3, 4]]) # ((1, 2), (3, 4))</pre>
            
            <p>In old versions of <a href="../../classes/Sequel.html">Sequel</a>, these
            objects often needed to be created manually, but in newer versions of <a
            href="../../classes/Sequel.html">Sequel</a>, they are created automatically
            in most cases where they are required.</p>
            
            <p>The following shortcuts exist for creating <a
            href="../../classes/Sequel/SQL/ValueList.html">Sequel::SQL::ValueList</a>
            objects:</p>
            
            <pre>Sequel.value_list([[1, 2], [3, 4]])&#x000A;[[1, 2], [3, 4]].sql_value_list # core_extensions extension</pre>
            
            <h3 id="label-Sequel%3A%3ASQL%3A%3AIdentifier"><a href="../../classes/Sequel/SQL/Identifier.html">Sequel::SQL::Identifier</a></h3>
            
            <p><a
            href="../../classes/Sequel/SQL/Identifier.html">Sequel::SQL::Identifier</a>
            objects represent single identifiers.  The main reason for their existance
            is that they are not checked for double or triple underscores, so no
            automatic qualification or aliasing happens for them:</p>
            
            <pre>Sequel::SQL::Identifier.new(:col__umn) # &quot;col__umn&quot;</pre>
            
            <p>The following shortcuts exist for creating <a
            href="../../classes/Sequel/SQL/Identifier.html">Sequel::SQL::Identifier</a>
            objects:</p>
            
            <pre>Sequel.expr(:column)&#x000A;Sequel.identifier(:col__umn)&#x000A;:col__umn.identifier # core_extensions extension</pre>
            
            <h3 id="label-Sequel%3A%3ASQL%3A%3AQualifiedIdentifier"><a href="../../classes/Sequel/SQL/QualifiedIdentifier.html">Sequel::SQL::QualifiedIdentifier</a></h3>
            
            <p><a
            href="../../classes/Sequel/SQL/QualifiedIdentifier.html">Sequel::SQL::QualifiedIdentifier</a>
            objects represent qualified identifiers:</p>
            
            <pre>Sequel::SQL::QualifiedIdentifier.new(:table, :column) # &quot;table&quot;.&quot;column&quot;</pre>
            
            <p>The following shortcuts exist for creating <a
            href="../../classes/Sequel/SQL/QualifiedIdentifier.html">Sequel::SQL::QualifiedIdentifier</a>
            objects:</p>
            
            <pre>Sequel.expr(:table__column)&#x000A;Sequel.qualify(:table, :column)&#x000A;:column.qualify(:table) # core_extensions extension</pre>
            
            <h3 id="label-Sequel%3A%3ASQL%3A%3AAliasedExpression"><a href="../../classes/Sequel/SQL/AliasedExpression.html">Sequel::SQL::AliasedExpression</a></h3>
            
            <p><a
            href="../../classes/Sequel/SQL/AliasedExpression.html">Sequel::SQL::AliasedExpression</a>
            objects represent aliased expressions in SQL.  The alias is treated as an
            identifier, but the expression can be an arbitrary <a
            href="../../classes/Sequel.html">Sequel</a> expression:</p>
            
            <pre>Sequel::SQL::AliasedExpression.new(:column, :alias) # &quot;column&quot; AS &quot;alias&quot;</pre>
            
            <p>The following shortcuts exist for creating <a
            href="../../classes/Sequel/SQL/AliasedExpression.html">Sequel::SQL::AliasedExpression</a>
            objects:</p>
            
            <pre>Sequel.expr(:column___alias)&#x000A;Sequel.as(:column, :alias)&#x000A;:column.as(:alias) # core_extensions extension</pre>
            
            <h3 id="label-Sequel%3A%3ASQL%3A%3AComplexExpression"><a href="../../classes/Sequel/SQL/ComplexExpression.html">Sequel::SQL::ComplexExpression</a></h3>
            
            <p><a
            href="../../classes/Sequel/SQL/ComplexExpression.html">Sequel::SQL::ComplexExpression</a>
            objects mostly represent SQL operations with arguments. There are separate
            subclasses for representing boolean operations such as AND and OR (<a
            href="../../classes/Sequel/SQL/BooleanExpression.html">Sequel::SQL::BooleanExpression</a>),
            mathematical operations such as + and - (<a
            href="../../classes/Sequel/SQL/NumericExpression.html">Sequel::SQL::NumericExpression</a>),
            and string operations such as || and LIKE (<a
            href="../../classes/Sequel/SQL/StringExpression.html">Sequel::SQL::StringExpression</a>).</p>
            
            <pre>Sequel::SQL::BooleanExpression.new(:OR, :col1, :col2) # (&quot;col1&quot; OR &quot;col2&quot;)&#x000A;Sequel::SQL::NumericExpression.new(:+, :column, 2) # (&quot;column&quot; + 2)&#x000A;Sequel::SQL::StringExpression.new(:&quot;||&quot;, :column, &quot;b&quot;) # (&quot;column&quot; || &#39;b&#39;)</pre>
            
            <p>There are many shortcuts for creating <a
            href="../../classes/Sequel/SQL/ComplexExpression.html">Sequel::SQL::ComplexExpression</a>
            objects:</p>
            
            <pre>Sequel.or(:col1, :col2)&#x000A;:col1 | :col2 # core_extensions extension&#x000A;Sequel.+(:column, 2)&#x000A;:column + 2 # core_extensions extension&#x000A;&#x000A;Sequel.join([:column, &#39;b&#39;])&#x000A;:column + &#39;b&#39; # core_extensions extension</pre>
            
            <h3 id="label-Sequel%3A%3ASQL%3A%3ACaseExpression"><a href="../../classes/Sequel/SQL/CaseExpression.html">Sequel::SQL::CaseExpression</a></h3>
            
            <p><a
            href="../../classes/Sequel/SQL/CaseExpression.html">Sequel::SQL::CaseExpression</a>
            objects represent SQL CASE expressions, which represent branches in the
            database, similar to ruby case expressions.  Like ruby&#39;s case
            expressions, these case expressions can have a implicit value you are
            comparing against:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">CaseExpression</span>.<span class="ruby-identifier">new</span>({<span class="ruby-value">2</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>}, <span class="ruby-value">0</span>, :<span class="ruby-identifier">a</span>) <span class="ruby-comment"># CASE &quot;a&quot; WHEN 2 THEN 1 ELSE 0 END</span></pre>
            
            <p>Or they can treat each condition separately:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">CaseExpression</span>.<span class="ruby-identifier">new</span>({{:<span class="ruby-identifier">a=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">2</span>}=<span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>}, <span class="ruby-value">0</span>) <span class="ruby-comment"># CASE WHEN (&quot;a&quot; = 2) THEN 1 ELSE 0 END</span></pre>
            
            <p>In addition to providing a hash, you can also provide an array of
            two-element arrays:</p>
            
            <pre>Sequel::SQL::CaseExpression.new([[2, 1]], 0, :a) # CASE &quot;a&quot; WHEN 2 THEN 1 ELSE 0 END</pre>
            
            <p>The following shortcuts exist for creating <a
            href="../../classes/Sequel/SQL/CaseExpression.html">Sequel::SQL::CaseExpression</a>
            objects:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">case</span>({<span class="ruby-value">2</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>}, <span class="ruby-value">0</span>, :<span class="ruby-identifier">a</span>)&#x000A;<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">case</span>({{:<span class="ruby-identifier">a=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">2</span>}=<span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>}, <span class="ruby-value">0</span>)&#x000A;&#x000A;{<span class="ruby-value">2</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>}.<span class="ruby-identifier">case</span>(<span class="ruby-value">0</span>, :<span class="ruby-identifier">a</span>) <span class="ruby-comment"># core_extensions extension</span>&#x000A;{{:<span class="ruby-identifier">a=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">2</span>}=<span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>}.<span class="ruby-identifier">case</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># core_extensions extension</span></pre>
            
            <h3 id="label-Sequel%3A%3ASQL%3A%3ACast"><a href="../../classes/Sequel/SQL/Cast.html">Sequel::SQL::Cast</a></h3>
            
            <p><a href="../../classes/Sequel/SQL/Cast.html">Sequel::SQL::Cast</a> objects
            represent CAST expressions in SQL, which does explicit typecasting in the
            database.  With <a href="../../classes/Sequel.html">Sequel</a>, you provide
            the expression to typecast as well as the type to cast to.  The type can
            either be a generic type, given as a ruby class:</p>
            
            <pre>Sequel::SQL::Cast.new(:a, String) # (CAST &quot;a&quot; AS text)</pre>
            
            <p>or a specific type, given as a symbol or string:</p>
            
            <pre>Sequel::SQL::Cast.new(:a, :int4) # (CAST &quot;a&quot; AS int4)</pre>
            
            <p>The following shortcuts exist for creating <a
            href="../../classes/Sequel/SQL/Cast.html">Sequel::SQL::Cast</a> objects:</p>
            
            <pre>Sequel.cast(:a, String)&#x000A;Sequel.cast(:a, :int4)&#x000A;:a.cast(String) # core_extensions extension&#x000A;:a.cast(:int4) # core_extensions extension</pre>
            
            <h3 id="label-Sequel%3A%3ASQL%3A%3AColumnAll"><a href="../../classes/Sequel/SQL/ColumnAll.html">Sequel::SQL::ColumnAll</a></h3>
            
            <p><a
            href="../../classes/Sequel/SQL/ColumnAll.html">Sequel::SQL::ColumnAll</a>
            objects represent the selection of all columns from a table.  They are
            pretty much only used as arguments to one of the Dataset select methods,
            and are not used much anymore since Dataset#select_all was expanded to take
            arguments.  Still, it&#39;s possible they are still useful in some code:</p>
            
            <pre>Sequel::SQL::ColumnAll.new(:table) # &quot;table&quot;.*</pre>
            
            <p>The following shortcut exists for creating <a
            href="../../classes/Sequel/SQL/ColumnAll.html">Sequel::SQL::ColumnAll</a>
            objects:</p>
            
            <pre>Sequel.expr(:table).*&#x000A;:table.* # core_extensions extension</pre>
            
            <h3 id="label-Sequel%3A%3ASQL%3A%3AConstant"><a href="../../classes/Sequel/SQL/Constant.html">Sequel::SQL::Constant</a></h3>
            
            <p><a href="../../classes/Sequel/SQL/Constant.html">Sequel::SQL::Constant</a>
            objects represent constants or psuedo-constants in SQL, such as TRUE, NULL,
            and CURRENT_TIMESTAMP.  These are not designed to be created or used by the
            end user, but some existing values are predefined under the <a
            href="../../classes/Sequel.html">Sequel</a> namespace:</p>
            
            <pre>Sequel::CURRENT_TIMESTAMP # CURRENT_TIMESTAMP</pre>
            
            <p>These objects are usually used as values in queries:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">insert</span>(:<span class="ruby-identifier">time=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">CURRENT_TIMESTAMP</span>)</pre>
            
            <h3 id="label-Sequel%3A%3ASQL%3A%3ADelayedEvaluation"><a href="../../classes/Sequel/SQL/DelayedEvaluation.html">Sequel::SQL::DelayedEvaluation</a></h3>
            
            <p><a
            href="../../classes/Sequel/SQL/DelayedEvaluation.html">Sequel::SQL::DelayedEvaluation</a>
            objects represent an evaluation that is delayed until query literalization.</p>
            
            <pre>Sequel::SQL::DelayedEvaluation.new(proc{some_model.updated_at})</pre>
            
            <p>The following shortcut exists for creating <a
            href="../../classes/Sequel/SQL/DelayedEvaluation.html">Sequel::SQL::DelayedEvaluation</a>
            objects:</p>
            
            <pre>Sequel.delay{some_model.updated_at}</pre>
            
            <p>Note how Sequel.delay requires a block, while <a
            href="../../classes/Sequel/SQL/DelayedEvaluation.html#method-c-new">Sequel::SQL::DelayedEvaluation.new</a>
            accepts a generic callable object.</p>
            
            <p>Let&#39;s say you wanted a dataset for the number of objects greater than
            some attribute of another object:</p>
            
            <pre>ds = DB[:table].where{updated_at &gt; some_model.updated_at}</pre>
            
            <p>The problem with the above query is that it evaluates
            "some_model.updated_at" statically, so if you change some_model.updated_at
            later, it won&#39;t affect this dataset.  You can use Sequel.delay to fix
            this:</p>
            
            <pre>ds = DB[:table].where{updated_at &gt; Sequel.delay{some_model.updated_at}}</pre>
            
            <p>This will evaluate "some_model.updated_at" every time you literalize the
            dataset (usually every time it is executed).</p>
            
            <h3 id="label-Sequel%3A%3ASQL%3A%3AFunction"><a href="../../classes/Sequel/SQL/Function.html">Sequel::SQL::Function</a></h3>
            
            <p><a href="../../classes/Sequel/SQL/Function.html">Sequel::SQL::Function</a>
            objects represents database function calls, which take a function name and
            any arguments:</p>
            
            <pre>Sequel::SQL::Function.new(:func, :a, 2) # func(&quot;a&quot;, 2)</pre>
            
            <p>The following shortcuts exist for creating <a
            href="../../classes/Sequel/SQL/Function.html">Sequel::SQL::Function</a>
            objects:</p>
            
            <pre>Sequel.function(:func, :a, 2)&#x000A;:func.sql_function(:a, 2) # core_extensions extension</pre>
            
            <h3 id="label-Sequel%3A%3ASQL%3A%3AJoinClause"><a href="../../classes/Sequel/SQL/JoinClause.html">Sequel::SQL::JoinClause</a></h3>
            
            <p><a
            href="../../classes/Sequel/SQL/JoinClause.html">Sequel::SQL::JoinClause</a>
            objects represent SQL JOIN clauses.  They are usually not created manually,
            as the Dataset join methods create them automatically.</p>
            
            <h3 id="label-Sequel%3A%3ASQL%3A%3APlaceholderLiteralString"><a href="../../classes/Sequel/SQL/PlaceholderLiteralString.html">Sequel::SQL::PlaceholderLiteralString</a></h3>
            
            <p><a
            href="../../classes/Sequel/SQL/PlaceholderLiteralString.html">Sequel::SQL::PlaceholderLiteralString</a>
            objects represent a literal SQL string with placeholders for variables. 
            There are three types of these objects. The first type uses question marks
            with multiple placeholder value objects:</p>
            
            <pre>Sequel::SQL::PlaceholderLiteralString.new(&#39;? = ?&#39;, [:a, 1]) # &quot;a&quot; = 1</pre>
            
            <p>The second uses named placeholders with colons and a hash of placeholder
            value objects:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">PlaceholderLiteralString</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;:b = :v&#39;</span>, [{:<span class="ruby-identifier">b=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">a</span>, :<span class="ruby-identifier">v=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>}]) <span class="ruby-comment"># &quot;a&quot; = 1</span></pre>
            
            <p>The third uses an array instead of a string, with multiple placeholder
            objects, each one going in between the members of the array:</p>
            
            <pre>Sequel::SQL::PlaceholderLiteralString.new([&#39;&#39;, &#39; = &#39;], [:a, 1]) # &quot;a&quot; = 1</pre>
            
            <p>For any of these three forms, you can also include a third argument for
            whether to include parentheses around the string:</p>
            
            <pre>Sequel::SQL::PlaceholderLiteralString.new(&#39;? = ?&#39;, [:a, 1], true) # (&quot;a&quot; = 1)</pre>
            
            <p>The following shortcuts exist for creating <a
            href="../../classes/Sequel/SQL/PlaceholderLiteralString.html">Sequel::SQL::PlaceholderLiteralString</a>
            objects:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">lit</span>(<span class="ruby-string">&#39;? = ?&#39;</span>, :<span class="ruby-identifier">a</span>, <span class="ruby-value">1</span>)&#x000A;<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">lit</span>(<span class="ruby-string">&#39;:b = :v&#39;</span>, :<span class="ruby-identifier">b=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">a</span>, :<span class="ruby-identifier">v=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>)&#x000A;<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">lit</span>([<span class="ruby-string">&#39;&#39;</span>, <span class="ruby-string">&#39; = &#39;</span>], :<span class="ruby-identifier">a</span>, <span class="ruby-value">1</span>)&#x000A;&#x000A;<span class="ruby-string">&#39;? = ?&#39;</span>.<span class="ruby-identifier">lit</span>(:<span class="ruby-identifier">a</span>, <span class="ruby-value">1</span>) <span class="ruby-comment"># core_extensions extension</span>&#x000A;<span class="ruby-string">&#39;:b = :v&#39;</span>.<span class="ruby-identifier">lit</span>(:<span class="ruby-identifier">b=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">a</span>, :<span class="ruby-identifier">v=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>) <span class="ruby-comment"># core_extensions extension</span></pre>
            
            <h3 id="label-Sequel%3A%3ASQL%3A%3AOrderedExpression"><a href="../../classes/Sequel/SQL/OrderedExpression.html">Sequel::SQL::OrderedExpression</a></h3>
            
            <p><a
            href="../../classes/Sequel/SQL/OrderedExpression.html">Sequel::SQL::OrderedExpression</a>
            objects represent ascending or descending sorts, used by the Dataset order
            methods.  They take an expression, and whether to sort it ascending or
            descending:</p>
            
            <pre>Sequel::SQL::OrderedExpression.new(:a) # &quot;a&quot; DESC&#x000A;Sequel::SQL::OrderedExpression.new(:a, false) # &quot;a&quot; ASC</pre>
            
            <p>Additionally, they take an options hash, which can be used to specify how
            nulls can be sorted:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">OrderedExpression</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">a</span>, <span class="ruby-keyword">true</span>, :<span class="ruby-identifier">nulls=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">first</span>) <span class="ruby-comment"># &quot;a&quot; DESC NULLS FIRST</span>&#x000A;<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">OrderedExpression</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">a</span>, <span class="ruby-keyword">false</span>, :<span class="ruby-identifier">nulls=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">last</span>) <span class="ruby-comment"># &quot;a&quot; ASC NULLS LAST</span></pre>
            
            <p>The following shortcuts exist for creating <a
            href="../../classes/Sequel/SQL/OrderedExpression.html">Sequel::SQL::OrderedExpression</a>
            objects:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">asc</span>(:<span class="ruby-identifier">a</span>)&#x000A;<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">desc</span>(:<span class="ruby-identifier">a</span>)&#x000A;<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">asc</span>(:<span class="ruby-identifier">a</span>, :<span class="ruby-identifier">nulls=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">first</span>)&#x000A;<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">desc</span>(:<span class="ruby-identifier">a</span>, :<span class="ruby-identifier">nulls=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">last</span>)&#x000A;&#x000A;:<span class="ruby-identifier">a</span>.<span class="ruby-identifier">asc</span> <span class="ruby-comment"># core_extensions extension</span>&#x000A;:<span class="ruby-identifier">a</span>.<span class="ruby-identifier">desc</span> <span class="ruby-comment"># core_extensions extension</span>&#x000A;:<span class="ruby-identifier">a</span>.<span class="ruby-identifier">asc</span>(:<span class="ruby-identifier">nulls=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">first</span>) <span class="ruby-comment"># core_extensions extension</span>&#x000A;:<span class="ruby-identifier">a</span>.<span class="ruby-identifier">desc</span>(:<span class="ruby-identifier">nulls=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">last</span>) <span class="ruby-comment"># core_extensions extension</span></pre>
            
            <h3 id="label-Sequel%3A%3ASQL%3A%3ASubscript"><a href="../../classes/Sequel/SQL/Subscript.html">Sequel::SQL::Subscript</a></h3>
            
            <p><a
            href="../../classes/Sequel/SQL/Subscript.html">Sequel::SQL::Subscript</a>
            objects represent SQL database array access.  They take an expression and
            an array of indexes (or a range for an SQL array slice):</p>
            
            <pre>Sequel::SQL::Subscript.new(:a, [1]) # &quot;a&quot;[1]&#x000A;Sequel::SQL::Subscript.new(:a, [1, 2]) # &quot;a&quot;[1, 2]&#x000A;Sequel::SQL::Subscript.new(:a, [1..2]) # &quot;a&quot;[1:2]</pre>
            
            <p>The following shortcuts exist for creating <a
            href="../../classes/Sequel/SQL/Subscript.html">Sequel::SQL::Subscript</a>
            objects:</p>
            
            <pre>Sequel.subscript(:a, 1)&#x000A;Sequel.subscript(:a, 1, 2)&#x000A;Sequel.subscript(:a, 1..2)&#x000A;:a.sql_subscript(1) # core_extensions extension&#x000A;:a.sql_subscript(1, 2) # core_extensions extension&#x000A;:a.sql_subscript(1..2) # core_extensions extension</pre>
            
            <h3 id="label-Sequel%3A%3ASQL%3A%3AVirtualRow"><a href="../../classes/Sequel/SQL/VirtualRow.html">Sequel::SQL::VirtualRow</a></h3>
            
            <p><a
            href="../../classes/Sequel/SQL/VirtualRow.html">Sequel::SQL::VirtualRow</a>
            is a BasicObject subclass that is the backbone behind the block expression
            support:</p>
            
            <pre>DB[:table].where{a &lt; 1}</pre>
            
            <p>In the above code, the block is instance-evaled inside a VirtualRow
            instance.</p>
            
            <p>These objects are usually not instantiated manually.  See the <a
            href="virtual_rows_rdoc.html">Virtual Row Guide</a> for details.</p>
            
            <h3 id="label-Sequel%3A%3ASQL%3A%3AWindow"><a href="../../classes/Sequel/SQL/Window.html">Sequel::SQL::Window</a></h3>
            
            <p><a href="../../classes/Sequel/SQL/Window.html">Sequel::SQL::Window</a>
            objects represent the windows used by <a
            href="../../classes/Sequel/SQL/WindowFunction.html">Sequel::SQL::WindowFunction</a>.
            They use a hash-based API, supporting the :frame, :order, :partition, and
            :window options:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Window</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">order=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">a</span>) <span class="ruby-comment"># (ORDER BY &quot;a&quot;)</span>&#x000A;<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Window</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">parition=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">a</span>) <span class="ruby-comment"># (PARTITION BY &quot;a&quot;)</span>&#x000A;&#x000A;<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Window</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">parition=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">a</span>, :<span class="ruby-identifier">frame=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">all</span>)&#x000A;<span class="ruby-comment"># (PARTITION BY &quot;a&quot; ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)</span></pre>
            
            <h3 id="label-Sequel%3A%3ASQL%3A%3AWindowFunction"><a href="../../classes/Sequel/SQL/WindowFunction.html">Sequel::SQL::WindowFunction</a></h3>
            
            <p><a
            href="../../classes/Sequel/SQL/WindowFunction.html">Sequel::SQL::WindowFunction</a>
            objects represent SQL window function calls.  These just combine a <a
            href="../../classes/Sequel/SQL/Function.html">Sequel::SQL::Function</a>
            with a Sequel::SQL::Window:</p>
            
            <pre class="ruby"><span class="ruby-identifier">function</span> = <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Function</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">f</span>, <span class="ruby-value">1</span>)&#x000A;<span class="ruby-identifier">window</span> = <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Window</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">order=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">a</span>)&#x000A;<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">WindowFunction</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">function</span>, <span class="ruby-identifier">window</span>) <span class="ruby-comment"># f(1) OVER (ORDER BY &quot;a&quot;)</span></pre>
            
            <p>Virtual rows offer a shortcut for creating <a
            href="../../classes/Sequel/SQL/Window.html">Sequel::SQL::Window</a>
            objects.</p>
            
            <h3 id="label-Sequel%3A%3ASQL%3A%3AWrapper"><a href="../../classes/Sequel/SQL/Wrapper.html">Sequel::SQL::Wrapper</a></h3>
            
            <p><a href="../../classes/Sequel/SQL/Wrapper.html">Sequel::SQL::Wrapper</a>
            objects wrap arbitrary objects so that they can be used in <a
            href="../../classes/Sequel.html">Sequel</a> expressions:</p>
            
            <pre class="ruby"><span class="ruby-identifier">o</span> = <span class="ruby-constant">Object</span>.<span class="ruby-identifier">new</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">sql_literal</span>(<span class="ruby-identifier">ds</span>) <span class="ruby-string">&quot;foo&quot;</span> <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Wrapper</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">o</span>) <span class="ruby-comment"># foo</span></pre>
            
            <p>The advantage of wrapping the object is that you can the call <a
            href="../../classes/Sequel.html">Sequel</a> methods on the wrapper that
            would not be defined on the object itself:</p>
            
            <pre>Sequel::SQL::Wrapper.new(o) + 1 # (foo + 1)</pre>
            
            <p>You can use the Sequel.expr method to wrap any object:</p>
            
            <pre>Sequel.expr(o)</pre>
            
            <p>However, note that that does not necessarily return a <a
            href="../../classes/Sequel/SQL/Wrapper.html">Sequel::SQL::Wrapper</a>
            object, it may return a different class of object, such as a <a
            href="../../classes/Sequel/SQL/ComplexExpression.html">Sequel::SQL::ComplexExpression</a>
            subclass object.</p>
          </div>
          <div id='context'>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
