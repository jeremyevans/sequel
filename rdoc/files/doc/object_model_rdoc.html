<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>object_model.rdoc</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      function popupCode(url) {
        window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
      }
      
      function toggleCode(id) {
        var code = document.getElementById(id)
      
        code.style.display = code.style.display != 'block' ? 'block' : 'none'
        return true
      }
      
      // Make codeblocks hidden by default
      document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
    </script>
  </head>
  <body class='page'>
    <div class='file' id='wrapper'>
      <div class='header'>
        <h1 class='name'>object_model.rdoc</h1>
        <div class='paths'>
          doc/object_model.rdoc
        </div>
        <div class='last-update'>
          Last Update:
          <span class='datetime'>2016-09-29 14:25:10 -0700</span>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <h1 id="label-The+Sequel+Object+Model">The <a href="../../classes/Sequel.html">Sequel</a> Object Model<span><a href="#label-The+Sequel+Object+Model">&para;</a> <a href="#top">&uarr;</a></span></h1>
            
            <p>Sequel&#39;s dataset layer is mostly structured as an DSL, so it often
            obscures what actual objects are being used.  For example, you don&#39;t
            usually create <a href="../../classes/Sequel.html">Sequel</a> objects by
            calling new on the object&#39;s class (other than <a
            href="../../classes/Sequel/Model.html">Sequel::Model</a> instances). 
            However, just as almost everything in ruby is an object, all  the methods
            you call in <a href="../../classes/Sequel.html">Sequel</a> deal with
            objects behind the scenes.</p>
            
            <p>There are five main types of Sequel-specific objects that you deal with in
            Sequel:</p>
            <ul><li>
            <p><a href="../../classes/Sequel/Database.html">Sequel::Database</a></p>
            </li><li>
            <p><a href="../../classes/Sequel/Dataset.html">Sequel::Dataset</a></p>
            </li><li>
            <p><a href="../../classes/Sequel/Model.html">Sequel::Model</a></p>
            </li><li>
            <p>Standard Ruby Types</p>
            </li><li>
            <p><a
            href="../../classes/Sequel/SQL/Expression.html">Sequel::SQL::Expression</a>
            (and subclasses)</p>
            </li></ul>
            
            <h2 id="label-Sequel-3A-3ADatabase"><a href="../../classes/Sequel/Database.html">Sequel::Database</a><span><a href="#label-Sequel-3A-3ADatabase">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p><a href="../../classes/Sequel/Database.html">Sequel::Database</a> is the
            main <a href="../../classes/Sequel.html">Sequel</a> object that you deal
            with.  It&#39;s usually created by the <a
            href="../../classes/Sequel.html#method-c-connect">Sequel.connect</a>
            method:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span> = <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">connect</span>(<span class="ruby-string">&#39;postgres://host/database&#39;</span>)</pre>
            
            <p>A <a href="../../classes/Sequel/Database.html">Sequel::Database</a> object
            represents the database you are connecting to. <a
            href="../../classes/Sequel/Database.html">Sequel::Database</a> handles
            things like <a href="../../classes/Sequel/Dataset.html">Sequel::Dataset</a>
            creation,</p>
            
            <pre class="ruby"><span class="ruby-identifier">dataset</span> = <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>]</pre>
            
            <p>schema modification,</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">table</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">primary_key</span> :<span class="ruby-identifier">id</span>&#x000A;  <span class="ruby-constant">String</span> :<span class="ruby-identifier">name</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>and transactions:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">transaction</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">insert</span>(:<span class="ruby-identifier">column=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">value</span>)&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p><a
            href="../../classes/Sequel/Database.html#method-i-literal">Sequel::Database#literal</a>
            can be used to take any object that <a
            href="../../classes/Sequel.html">Sequel</a> handles and literalize the
            object to an SQL string fragment:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">literal</span>(<span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>]) <span class="ruby-comment"># (SELECT * FROM &quot;table&quot;)</span></pre>
            
            <h2 id="label-Sequel-3A-3ADataset"><a href="../../classes/Sequel/Dataset.html">Sequel::Dataset</a><span><a href="#label-Sequel-3A-3ADataset">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p><a href="../../classes/Sequel/Dataset.html">Sequel::Dataset</a> objects
            represent SQL queries, or more generally, they represent abstract
            collections of rows in the database.  They are usually created from a <a
            href="../../classes/Sequel/Database.html">Sequel::Database</a> object:</p>
            
            <pre class="ruby"><span class="ruby-identifier">dataset</span> = <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>]         <span class="ruby-comment"># SELECT * FROM &quot;table&quot;</span>&#x000A;<span class="ruby-identifier">dataset</span> = <span class="ruby-constant">DB</span>.<span class="ruby-identifier">from</span>(<span class="ruby-identifier">table</span>)     <span class="ruby-comment"># SELECT * FROM &quot;table&quot;</span>&#x000A;<span class="ruby-identifier">dataset</span> = <span class="ruby-constant">DB</span>.<span class="ruby-identifier">select</span>(:<span class="ruby-identifier">column</span>) <span class="ruby-comment"># SELECT &quot;column&quot;</span></pre>
            
            <p>Most <a href="../../classes/Sequel/Dataset.html">Sequel::Dataset</a>
            methods return modified copies of the receiver, and the general way to
            build queries in <a href="../../classes/Sequel.html">Sequel</a> is via a
            method chain:</p>
            
            <pre class="ruby"><span class="ruby-identifier">dataset</span> = <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">test</span>].&#x000A;            <span class="ruby-identifier">select</span>(:<span class="ruby-identifier">column1</span>, :<span class="ruby-identifier">column2</span>).&#x000A;            <span class="ruby-identifier">where</span>(:<span class="ruby-identifier">column3</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">4</span>).&#x000A;            <span class="ruby-identifier">order</span>(:<span class="ruby-identifier">column5</span>)</pre>
            
            <p>Such a method chain is a more direct way of doing:</p>
            
            <pre class="ruby"><span class="ruby-identifier">dataset</span> = <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">test</span>]&#x000A;<span class="ruby-identifier">dataset</span> = <span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">select</span>(:<span class="ruby-identifier">column1</span>, :<span class="ruby-identifier">column2</span>)&#x000A;<span class="ruby-identifier">dataset</span> = <span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">column3</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">4</span>)&#x000A;<span class="ruby-identifier">dataset</span> = <span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">order</span>(:<span class="ruby-identifier">column5</span>)</pre>
            
            <p>When you are ready to execute your query, you call one of the <a
            href="../../classes/Sequel/Dataset.html">Sequel::Dataset</a> action
            methods.  For returning rows, you can do:</p>
            
            <pre class="ruby"><span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">first</span>&#x000A;<span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">all</span>&#x000A;<span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">row</span><span class="ruby-operator">|</span> <span class="ruby-identifier">row</span>}</pre>
            
            <p>For inserting, updating, or deleting rows, you can do:</p>
            
            <pre class="ruby"><span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">insert</span>(:<span class="ruby-identifier">column=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">value</span>)&#x000A;<span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">column=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">value</span>)&#x000A;<span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">delete</span></pre>
            
            <p>All datasets are related to their database object, which you can access via
            the <a
            href="../../classes/Sequel/Dataset.html#attribute-i-db">Sequel::Dataset#db</a>
            method:</p>
            
            <pre class="ruby"><span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">db</span> <span class="ruby-comment"># =&gt; DB</span></pre>
            
            <h2 id="label-Sequel-3A-3AModel"><a href="../../classes/Sequel/Model.html">Sequel::Model</a><span><a href="#label-Sequel-3A-3AModel">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p><a href="../../classes/Sequel/Model.html">Sequel::Model</a> objects are
            wrappers around a particular <a
            href="../../classes/Sequel/Dataset.html">Sequel::Dataset</a> object that
            add custom behavior, both custom behavior for the entire set of rows in the
            dataset (the model&#39;s class methods), custom behavior for a subset of
            rows in the dataset (the model&#39;s dataset methods), and custom behavior
            for single rows in the dataset (the model&#39;s instance methods).</p>
            
            <p>Unlike most other <a href="../../classes/Sequel.html">Sequel</a> objects,
            <a href="../../classes/Sequel/Model.html">Sequel::Model</a> classes and
            instances are generally created by the user using standard ruby syntax:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-identifier">album</span> = <span class="ruby-constant">Album</span>.<span class="ruby-identifier">new</span></pre>
            
            <p>All model classes are related to their <a
            href="../../classes/Sequel/Dataset.html">Sequel::Dataset</a> object, which
            you can access via the Sequel::Model.dataset method:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">dataset</span> <span class="ruby-comment"># SELECT * FROM &quot;albums&quot;</span></pre>
            
            <p>Additionally, all model classes are related to their dataset&#39;s <a
            href="../../classes/Sequel/Database.html">Sequel::Database</a> object,
            which you can access via the Sequel::Model.db method:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">db</span> <span class="ruby-comment"># =&gt; DB</span></pre>
            
            <h2 id="label-Standard+Ruby+Types">Standard Ruby Types<span><a href="#label-Standard+Ruby+Types">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>Where possible, <a href="../../classes/Sequel.html">Sequel</a> uses
            ruby&#39;s standard types to represent SQL concepts. In the examples here,
            the text to the right side of the # sign is the output if you pass the left
            side to <a
            href="../../classes/Sequel/Database.html#method-i-literal">Sequel::Database#literal</a>.</p>
            
            <h3 id="label-Symbol">Symbol<span><a href="#label-Symbol">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>For example, ruby symbols represent SQL identifiers (tables, columns,
            schemas):</p>
            
            <pre class="ruby">:<span class="ruby-identifier">table</span>  <span class="ruby-comment"># &quot;table&quot;</span>&#x000A;:<span class="ruby-identifier">column</span> <span class="ruby-comment"># &quot;column&quot;</span></pre>
            
            <p>However, they can also represent qualified identifiers by including a
            double underscore inside a symbol:</p>
            
            <pre class="ruby">:<span class="ruby-identifier">table__column</span> <span class="ruby-comment"># &quot;table&quot;.&quot;column&quot;</span></pre>
            
            <p>They can also represent an aliased identifier by including a triple
            underscore inside a symbol:</p>
            
            <pre class="ruby">:<span class="ruby-identifier">column___alias</span> <span class="ruby-comment"># &quot;column&quot; AS &quot;alias&quot;</span></pre>
            
            <p>You can combine both qualification and aliasing by using a double
            underscore and a triple underscore:</p>
            
            <pre class="ruby">:<span class="ruby-identifier">table__column___alias</span> <span class="ruby-comment"># &quot;table&quot;.&quot;column&quot; AS &quot;alias&quot;</span></pre>
            
            <h3 id="label-Integer-2C+Float-2C+BigDecimal-2C+String-2C+Date-2C+Time-2C+DateTime">Integer, Float, BigDecimal, String, Date, Time, DateTime<span><a href="#label-Integer-2C+Float-2C+BigDecimal-2C+String-2C+Date-2C+Time-2C+DateTime">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>Ruby&#39;s Integer, Float, BigDecimal, String, Date, Time, and DateTime
            classes represent similar types in SQL:</p>
            
            <pre class="ruby"><span class="ruby-value">1</span>                     <span class="ruby-comment"># 1</span>&#x000A;<span class="ruby-value">1.0</span>                   <span class="ruby-comment"># 1.0</span>&#x000A;<span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;1.0&#39;</span>) <span class="ruby-comment"># 1.0</span>&#x000A;<span class="ruby-string">&quot;string&quot;</span>              <span class="ruby-comment"># &#39;string&#39;</span>&#x000A;<span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2012</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>)  <span class="ruby-comment"># &#39;2012-05-06&#39;</span>&#x000A;<span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>              <span class="ruby-comment"># &#39;2012-05-06 10:20:30&#39;</span>&#x000A;<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">now</span>          <span class="ruby-comment"># &#39;2012-05-06 10:20:30&#39;</span></pre>
            
            <h3 id="label-Hash">Hash<span><a href="#label-Hash">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> generally uses hash objects
            to represent equality:</p>
            
            <pre class="ruby">{:<span class="ruby-identifier">column</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>} <span class="ruby-comment"># (&quot;column&quot; = 1)</span></pre>
            
            <p>However, if you use an array as the hash value, it will usually be used to
            represent inclusion:</p>
            
            <pre class="ruby">{:<span class="ruby-identifier">column</span> =<span class="ruby-operator">&gt;</span> [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]} <span class="ruby-comment"># (&quot;column&quot; IN (1, 2, 3))</span></pre>
            
            <p>You can also use a <a
            href="../../classes/Sequel/Dataset.html">Sequel::Dataset</a> instance as
            the hash value, which will be used to represent inclusion in the subselect:</p>
            
            <pre class="ruby">{:<span class="ruby-identifier">column</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">select</span>(:<span class="ruby-identifier">column</span>)} <span class="ruby-comment"># (&quot;column&quot; IN (SELECT &quot;column&quot; FROM &quot;table&quot;))</span></pre>
            
            <p>If you pass true, false, or nil as the hash value, it will be used to
            represent identity:</p>
            
            <pre class="ruby">{:<span class="ruby-identifier">column</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">nil</span>} <span class="ruby-comment"># (&quot;column&quot; IS NULL)</span></pre>
            
            <p>If you pass a Range object, it will be used as the bounds for a greater
            than and less than operation:</p>
            
            <pre class="ruby">{:<span class="ruby-identifier">column</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>} <span class="ruby-comment"># ((&quot;column&quot; &gt;= 1) AND (&quot;column&quot; &lt;= 2))</span>&#x000A;{:<span class="ruby-identifier">column</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span><span class="ruby-operator">...</span><span class="ruby-value">3</span>} <span class="ruby-comment"># ((&quot;column&quot; &gt;= 1) AND (&quot;column&quot; &lt; 3))</span></pre>
            
            <p>If you pass a Regexp object as the value, it will be used as a regular
            expression operation (only supported on PostgreSQL and MySQL currently):</p>
            
            <pre class="ruby">{:<span class="ruby-identifier">column</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-regexp">/a.*b/</span>} <span class="ruby-comment"># (&quot;column&quot; ~ &#39;a.*b&#39;)</span></pre>
            
            <h3 id="label-Array">Array<span><a href="#label-Array">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> generally treats arrays as
            an SQL value list:</p>
            
            <pre class="ruby">[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>] <span class="ruby-comment"># (1, 2, 3)</span></pre>
            
            <p>However, if all members of the array are arrays with two members, then the
            array is treated like a hash:</p>
            
            <pre class="ruby">[[:<span class="ruby-identifier">column</span>, <span class="ruby-value">1</span>]] <span class="ruby-comment"># (&quot;column&quot; = 1)</span></pre>
            
            <p>The advantage of using an array over a hash for such a case is that a hash
            cannot include multiple objects with the same key, while the array can.</p>
            
            <h2 id="label-Sequel-3A-3ASQL-3A-3AExpression+-28and+subclasses-29"><a href="../../classes/Sequel/SQL/Expression.html">Sequel::SQL::Expression</a> (and subclasses)<span><a href="#label-Sequel-3A-3ASQL-3A-3AExpression+-28and+subclasses-29">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>If <a href="../../classes/Sequel.html">Sequel</a> needs to represent an SQL
            concept that does not map directly to an existing ruby class, it will
            generally use a <a
            href="../../classes/Sequel/SQL/Expression.html">Sequel::SQL::Expression</a>
            subclass to represent that concept.</p>
            
            <p>Some of the examples below show examples that require the <a
            href="core_extensions_rdoc.html">core_extensions extension</a>.</p>
            
            <h3 id="label-Sequel-3A-3ALiteralString"><a href="../../classes/Sequel/LiteralString.html">Sequel::LiteralString</a><span><a href="#label-Sequel-3A-3ALiteralString">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p><a href="../../classes/Sequel/LiteralString.html">Sequel::LiteralString</a>
            is not actually a <a
            href="../../classes/Sequel/SQL/Expression.html">Sequel::SQL::Expression</a>
            subclass.  It is a subclass of String, but it is treated specially by <a
            href="../../classes/Sequel.html">Sequel</a>, in that it is treated as
            literal SQL code, instead of as an SQL string that needs to be escaped:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">LiteralString</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;co&#39;de&quot;</span>) <span class="ruby-comment"># co&#39;de</span></pre>
            
            <p>The following shortcuts exist for creating <a
            href="../../classes/Sequel/LiteralString.html">Sequel::LiteralString</a>
            objects:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">lit</span>(<span class="ruby-string">&quot;co&#39;de&quot;</span>)&#x000A;<span class="ruby-string">&quot;co&#39;de&quot;</span>.<span class="ruby-identifier">lit</span> <span class="ruby-comment"># core_extensions extension</span></pre>
            
            <h3 id="label-Sequel-3A-3ASQL-3A-3ABlob"><a href="../../classes/Sequel/SQL/Blob.html">Sequel::SQL::Blob</a><span><a href="#label-Sequel-3A-3ASQL-3A-3ABlob">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p><a href="../../classes/Sequel/SQL/Blob.html">Sequel::SQL::Blob</a> is also
            a String subclass, but it is treated as an SQL blob instead of an SQL
            string, as SQL blobs often have different literalization rules than SQL
            strings do:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Blob</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;blob&quot;</span>)</pre>
            
            <p>The following shortcuts exist for creating <a
            href="../../classes/Sequel/SQL/Blob.html">Sequel::SQL::Blob</a> objects:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">blob</span>(<span class="ruby-string">&quot;blob&quot;</span>)&#x000A;<span class="ruby-string">&quot;blob&quot;</span>.<span class="ruby-identifier">to_sequel_blob</span>  <span class="ruby-comment"># core_extensions extension</span></pre>
            
            <h3 id="label-Sequel-3A-3ASQLTime"><a href="../../classes/Sequel/SQLTime.html">Sequel::SQLTime</a><span><a href="#label-Sequel-3A-3ASQLTime">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p><a href="../../classes/Sequel/SQLTime.html">Sequel::SQLTime</a> is a Time
            subclass.  However, it is treated specially by <a
            href="../../classes/Sequel.html">Sequel</a> in that only the time component
            is literalized, not the date part.  This type is used to represent SQL time
            types, which do not contain date information.</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQLTime</span>.<span class="ruby-identifier">create</span>(<span class="ruby-value">10</span>, <span class="ruby-value">20</span>, <span class="ruby-value">30</span>) <span class="ruby-comment"># &quot;10:20:30&quot;</span></pre>
            
            <h3 id="label-Sequel-3A-3ASQL-3A-3AValueList"><a href="../../classes/Sequel/SQL/ValueList.html">Sequel::SQL::ValueList</a><span><a href="#label-Sequel-3A-3ASQL-3A-3AValueList">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p><a
            href="../../classes/Sequel/SQL/ValueList.html">Sequel::SQL::ValueList</a>
            objects always represent SQL value lists.  Most ruby arrays represent value
            lists in SQL, except that arrays of two-element arrays are treated similar
            to hashes.  Such arrays can be wrapped in this class to ensure they are
            treated as value lists.  This is important when doing a composite key IN
            lookup, which some databases support.  <a
            href="../../classes/Sequel/SQL/ValueList.html">Sequel::SQL::ValueList</a>
            is an ::Array subclass with no additional behavior, so it can be
            instantiated like a normal array:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">ValueList</span>.<span class="ruby-identifier">new</span>([[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>], [<span class="ruby-value">3</span>, <span class="ruby-value">4</span>]]) <span class="ruby-comment"># ((1, 2), (3, 4))</span></pre>
            
            <p>In old versions of <a href="../../classes/Sequel.html">Sequel</a>, these
            objects often needed to be created manually, but in newer versions of <a
            href="../../classes/Sequel.html">Sequel</a>, they are created automatically
            in most cases where they are required.</p>
            
            <p>The following shortcuts exist for creating <a
            href="../../classes/Sequel/SQL/ValueList.html">Sequel::SQL::ValueList</a>
            objects:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">value_list</span>([[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>], [<span class="ruby-value">3</span>, <span class="ruby-value">4</span>]])&#x000A;[[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>], [<span class="ruby-value">3</span>, <span class="ruby-value">4</span>]].<span class="ruby-identifier">sql_value_list</span> <span class="ruby-comment"># core_extensions extension</span></pre>
            
            <h3 id="label-Sequel-3A-3ASQL-3A-3AIdentifier"><a href="../../classes/Sequel/SQL/Identifier.html">Sequel::SQL::Identifier</a><span><a href="#label-Sequel-3A-3ASQL-3A-3AIdentifier">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p><a
            href="../../classes/Sequel/SQL/Identifier.html">Sequel::SQL::Identifier</a>
            objects represent single identifiers.  The main reason for their existence
            is that they are not checked for double or triple underscores, so no
            automatic qualification or aliasing happens for them:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Identifier</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">col__umn</span>) <span class="ruby-comment"># &quot;col__umn&quot;</span></pre>
            
            <p>The following shortcuts exist for creating <a
            href="../../classes/Sequel/SQL/Identifier.html">Sequel::SQL::Identifier</a>
            objects:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span>[:<span class="ruby-identifier">column</span>]&#x000A;<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">identifier</span>(:<span class="ruby-identifier">col__umn</span>)&#x000A;:<span class="ruby-identifier">col__umn</span>.<span class="ruby-identifier">identifier</span> <span class="ruby-comment"># core_extensions extension</span></pre>
            
            <h3 id="label-Sequel-3A-3ASQL-3A-3AQualifiedIdentifier"><a href="../../classes/Sequel/SQL/QualifiedIdentifier.html">Sequel::SQL::QualifiedIdentifier</a><span><a href="#label-Sequel-3A-3ASQL-3A-3AQualifiedIdentifier">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p><a
            href="../../classes/Sequel/SQL/QualifiedIdentifier.html">Sequel::SQL::QualifiedIdentifier</a>
            objects represent qualified identifiers:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">QualifiedIdentifier</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">table</span>, :<span class="ruby-identifier">column</span>) <span class="ruby-comment"># &quot;table&quot;.&quot;column&quot;</span></pre>
            
            <p>The following shortcuts exist for creating <a
            href="../../classes/Sequel/SQL/QualifiedIdentifier.html">Sequel::SQL::QualifiedIdentifier</a>
            objects:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span>[:<span class="ruby-identifier">table__column</span>]&#x000A;<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">qualify</span>(:<span class="ruby-identifier">table</span>, :<span class="ruby-identifier">column</span>)&#x000A;:<span class="ruby-identifier">column</span>.<span class="ruby-identifier">qualify</span>(:<span class="ruby-identifier">table</span>) <span class="ruby-comment"># core_extensions extension</span></pre>
            
            <h3 id="label-Sequel-3A-3ASQL-3A-3AAliasedExpression"><a href="../../classes/Sequel/SQL/AliasedExpression.html">Sequel::SQL::AliasedExpression</a><span><a href="#label-Sequel-3A-3ASQL-3A-3AAliasedExpression">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p><a
            href="../../classes/Sequel/SQL/AliasedExpression.html">Sequel::SQL::AliasedExpression</a>
            objects represent aliased expressions in SQL.  The alias is treated as an
            identifier, but the expression can be an arbitrary <a
            href="../../classes/Sequel.html">Sequel</a> expression:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">AliasedExpression</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">column</span>, :<span class="ruby-keyword">alias</span>)&#x000A;<span class="ruby-comment"># &quot;column&quot; AS &quot;alias&quot;</span>&#x000A;&#x000A;<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">AliasedExpression</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">table</span>, :<span class="ruby-keyword">alias</span>, [:<span class="ruby-identifier">column_alias1</span>, :<span class="ruby-identifier">column_alias2</span>])&#x000A;<span class="ruby-comment"># &quot;table&quot; AS &quot;alias&quot;(&quot;column_alias1&quot;, &quot;column_alias2&quot;)</span></pre>
            
            <p>The following shortcuts exist for creating <a
            href="../../classes/Sequel/SQL/AliasedExpression.html">Sequel::SQL::AliasedExpression</a>
            objects:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span>[:<span class="ruby-identifier">column___alias</span>]&#x000A;<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">as</span>(:<span class="ruby-identifier">column</span>, :<span class="ruby-keyword">alias</span>)&#x000A;<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">as</span>(:<span class="ruby-identifier">column</span>, :<span class="ruby-keyword">alias</span>, [:<span class="ruby-identifier">column_alias1</span>, :<span class="ruby-identifier">column_alias2</span>])&#x000A;:<span class="ruby-identifier">column</span>.<span class="ruby-identifier">as</span>(:<span class="ruby-keyword">alias</span>) <span class="ruby-comment"># core_extensions extension</span></pre>
            
            <h3 id="label-Sequel-3A-3ASQL-3A-3AComplexExpression"><a href="../../classes/Sequel/SQL/ComplexExpression.html">Sequel::SQL::ComplexExpression</a><span><a href="#label-Sequel-3A-3ASQL-3A-3AComplexExpression">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p><a
            href="../../classes/Sequel/SQL/ComplexExpression.html">Sequel::SQL::ComplexExpression</a>
            objects mostly represent SQL operations with arguments. There are separate
            subclasses for representing boolean operations such as AND and OR
            (Sequel::SQL::BooleanExpression), mathematical operations such as + and -
            (Sequel::SQL::NumericExpression), and string operations such as || and LIKE
            (Sequel::SQL::StringExpression).</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">BooleanExpression</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-constant">OR</span>, :<span class="ruby-identifier">col1</span>, :<span class="ruby-identifier">col2</span>) <span class="ruby-comment"># (&quot;col1&quot; OR &quot;col2&quot;)</span>&#x000A;<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">NumericExpression</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-operator">+</span>, :<span class="ruby-identifier">column</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># (&quot;column&quot; + 2)</span>&#x000A;<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">StringExpression</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-string">&quot;||&quot;</span>, :<span class="ruby-identifier">column</span>, <span class="ruby-string">&quot;b&quot;</span>) <span class="ruby-comment"># (&quot;column&quot; || &#39;b&#39;)</span></pre>
            
            <p>There are many shortcuts for creating <a
            href="../../classes/Sequel/SQL/ComplexExpression.html">Sequel::SQL::ComplexExpression</a>
            objects:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">or</span>(:<span class="ruby-identifier">col1</span>, :<span class="ruby-identifier">col2</span>)&#x000A;:<span class="ruby-identifier">col1</span> <span class="ruby-operator">|</span> :<span class="ruby-identifier">col2</span> <span class="ruby-comment"># core_extensions extension</span>&#x000A;&#x000A;<span class="ruby-constant">Sequel</span>.<span class="ruby-operator">+</span>(:<span class="ruby-identifier">column</span>, <span class="ruby-value">2</span>)&#x000A;:<span class="ruby-identifier">column</span> <span class="ruby-operator">+</span> <span class="ruby-value">2</span> <span class="ruby-comment"># core_extensions extension</span>&#x000A;&#x000A;<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">join</span>([:<span class="ruby-identifier">column</span>, <span class="ruby-string">&#39;b&#39;</span>])&#x000A;:<span class="ruby-identifier">column</span> <span class="ruby-operator">+</span> <span class="ruby-string">&#39;b&#39;</span> <span class="ruby-comment"># core_extensions extension</span></pre>
            
            <h3 id="label-Sequel-3A-3ASQL-3A-3ACaseExpression"><a href="../../classes/Sequel/SQL/CaseExpression.html">Sequel::SQL::CaseExpression</a><span><a href="#label-Sequel-3A-3ASQL-3A-3ACaseExpression">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p><a
            href="../../classes/Sequel/SQL/CaseExpression.html">Sequel::SQL::CaseExpression</a>
            objects represent SQL CASE expressions, which represent branches in the
            database, similar to ruby case expressions.  Like ruby&#39;s case
            expressions, these case expressions can have a implicit value you are
            comparing against:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">CaseExpression</span>.<span class="ruby-identifier">new</span>({<span class="ruby-value">2</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>}, <span class="ruby-value">0</span>, :<span class="ruby-identifier">a</span>) <span class="ruby-comment"># CASE &quot;a&quot; WHEN 2 THEN 1 ELSE 0 END</span></pre>
            
            <p>Or they can treat each condition separately:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">CaseExpression</span>.<span class="ruby-identifier">new</span>({{:<span class="ruby-identifier">a=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">2</span>}=<span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>}, <span class="ruby-value">0</span>) <span class="ruby-comment"># CASE WHEN (&quot;a&quot; = 2) THEN 1 ELSE 0 END</span></pre>
            
            <p>In addition to providing a hash, you can also provide an array of
            two-element arrays:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">CaseExpression</span>.<span class="ruby-identifier">new</span>([[<span class="ruby-value">2</span>, <span class="ruby-value">1</span>]], <span class="ruby-value">0</span>, :<span class="ruby-identifier">a</span>) <span class="ruby-comment"># CASE &quot;a&quot; WHEN 2 THEN 1 ELSE 0 END</span></pre>
            
            <p>The following shortcuts exist for creating <a
            href="../../classes/Sequel/SQL/CaseExpression.html">Sequel::SQL::CaseExpression</a>
            objects:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">case</span>({<span class="ruby-value">2</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>}, <span class="ruby-value">0</span>, :<span class="ruby-identifier">a</span>)&#x000A;<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">case</span>({{:<span class="ruby-identifier">a=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">2</span>}=<span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>}, <span class="ruby-value">0</span>)&#x000A;&#x000A;{<span class="ruby-value">2</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>}.<span class="ruby-identifier">case</span>(<span class="ruby-value">0</span>, :<span class="ruby-identifier">a</span>) <span class="ruby-comment"># core_extensions extension</span>&#x000A;{{:<span class="ruby-identifier">a=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">2</span>}=<span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>}.<span class="ruby-identifier">case</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># core_extensions extension</span></pre>
            
            <h3 id="label-Sequel-3A-3ASQL-3A-3ACast"><a href="../../classes/Sequel/SQL/Cast.html">Sequel::SQL::Cast</a><span><a href="#label-Sequel-3A-3ASQL-3A-3ACast">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p><a href="../../classes/Sequel/SQL/Cast.html">Sequel::SQL::Cast</a> objects
            represent CAST expressions in SQL, which does explicit typecasting in the
            database.  With <a href="../../classes/Sequel.html">Sequel</a>, you provide
            the expression to typecast as well as the type to cast to.  The type can
            either be a generic type, given as a ruby class:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Cast</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">a</span>, <span class="ruby-constant">String</span>) <span class="ruby-comment"># (CAST &quot;a&quot; AS text)</span></pre>
            
            <p>or a specific type, given as a symbol or string:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Cast</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">a</span>, :<span class="ruby-identifier">int4</span>) <span class="ruby-comment"># (CAST &quot;a&quot; AS int4)</span></pre>
            
            <p>The following shortcuts exist for creating <a
            href="../../classes/Sequel/SQL/Cast.html">Sequel::SQL::Cast</a> objects:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">cast</span>(:<span class="ruby-identifier">a</span>, <span class="ruby-constant">String</span>)&#x000A;<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">cast</span>(:<span class="ruby-identifier">a</span>, :<span class="ruby-identifier">int4</span>)&#x000A;&#x000A;:<span class="ruby-identifier">a</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-constant">String</span>) <span class="ruby-comment"># core_extensions extension</span>&#x000A;:<span class="ruby-identifier">a</span>.<span class="ruby-identifier">cast</span>(:<span class="ruby-identifier">int4</span>) <span class="ruby-comment"># core_extensions extension</span></pre>
            
            <h3 id="label-Sequel-3A-3ASQL-3A-3AColumnAll"><a href="../../classes/Sequel/SQL/ColumnAll.html">Sequel::SQL::ColumnAll</a><span><a href="#label-Sequel-3A-3ASQL-3A-3AColumnAll">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p><a
            href="../../classes/Sequel/SQL/ColumnAll.html">Sequel::SQL::ColumnAll</a>
            objects represent the selection of all columns from a table.  They are
            pretty much only used as arguments to one of the Dataset select methods,
            and are not used much anymore since Dataset#select_all was expanded to take
            arguments.  Still, it&#39;s possible they are still useful in some code:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">ColumnAll</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">table</span>) <span class="ruby-comment"># &quot;table&quot;.*</span></pre>
            
            <p>The following shortcut exists for creating <a
            href="../../classes/Sequel/SQL/ColumnAll.html">Sequel::SQL::ColumnAll</a>
            objects:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-operator">*</span>&#x000A;:<span class="ruby-identifier">table</span>.<span class="ruby-operator">*</span> <span class="ruby-comment"># core_extensions extension</span></pre>
            
            <h3 id="label-Sequel-3A-3ASQL-3A-3AConstant"><a href="../../classes/Sequel/SQL/Constant.html">Sequel::SQL::Constant</a><span><a href="#label-Sequel-3A-3ASQL-3A-3AConstant">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p><a href="../../classes/Sequel/SQL/Constant.html">Sequel::SQL::Constant</a>
            objects represent constants or pseudo-constants in SQL, such as TRUE, NULL,
            and CURRENT_TIMESTAMP.  These are not designed to be created or used by the
            end user, but some existing values are predefined under the <a
            href="../../classes/Sequel.html">Sequel</a> namespace:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">CURRENT_TIMESTAMP</span> <span class="ruby-comment"># CURRENT_TIMESTAMP</span></pre>
            
            <p>These objects are usually used as values in queries:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">insert</span>(:<span class="ruby-identifier">time=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">CURRENT_TIMESTAMP</span>)</pre>
            
            <h3 id="label-Sequel-3A-3ASQL-3A-3ADelayedEvaluation"><a href="../../classes/Sequel/SQL/DelayedEvaluation.html">Sequel::SQL::DelayedEvaluation</a><span><a href="#label-Sequel-3A-3ASQL-3A-3ADelayedEvaluation">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p><a
            href="../../classes/Sequel/SQL/DelayedEvaluation.html">Sequel::SQL::DelayedEvaluation</a>
            objects represent an evaluation that is delayed until query literalization.</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">DelayedEvaluation</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">proc</span>{<span class="ruby-identifier">some_model</span>.<span class="ruby-identifier">updated_at</span>})</pre>
            
            <p>The following shortcut exists for creating <a
            href="../../classes/Sequel/SQL/DelayedEvaluation.html">Sequel::SQL::DelayedEvaluation</a>
            objects:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">delay</span>{<span class="ruby-identifier">some_model</span>.<span class="ruby-identifier">updated_at</span>}</pre>
            
            <p>Note how Sequel.delay requires a block, while <a
            href="../../classes/Sequel/SQL/DelayedEvaluation.html#method-c-new">Sequel::SQL::DelayedEvaluation.new</a>
            accepts a generic callable object.</p>
            
            <p>Let&#39;s say you wanted a dataset for the number of objects greater than
            some attribute of another object:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span> = <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">where</span>{<span class="ruby-identifier">updated_at</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">some_model</span>.<span class="ruby-identifier">updated_at</span>}</pre>
            
            <p>The problem with the above query is that it evaluates
            “some_model.updated_at” statically, so if you change some_model.updated_at
            later, it won&#39;t affect this dataset.  You can use Sequel.delay to fix
            this:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span> = <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">where</span>{<span class="ruby-identifier">updated_at</span> <span class="ruby-operator">&gt;</span> <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">delay</span>{<span class="ruby-identifier">some_model</span>.<span class="ruby-identifier">updated_at</span>}}</pre>
            
            <p>This will evaluate “some_model.updated_at” every time you literalize the
            dataset (usually every time it is executed).</p>
            
            <h3 id="label-Sequel-3A-3ASQL-3A-3AFunction"><a href="../../classes/Sequel/SQL/Function.html">Sequel::SQL::Function</a><span><a href="#label-Sequel-3A-3ASQL-3A-3AFunction">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p><a href="../../classes/Sequel/SQL/Function.html">Sequel::SQL::Function</a>
            objects represents database function calls, which take a function name and
            any arguments:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Function</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">func</span>, :<span class="ruby-identifier">a</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># func(&quot;a&quot;, 2)</span></pre>
            
            <p>The following shortcuts exist for creating <a
            href="../../classes/Sequel/SQL/Function.html">Sequel::SQL::Function</a>
            objects:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">function</span>(:<span class="ruby-identifier">func</span>, :<span class="ruby-identifier">a</span>, <span class="ruby-value">2</span>)&#x000A;:<span class="ruby-identifier">func</span>.<span class="ruby-identifier">sql_function</span>(:<span class="ruby-identifier">a</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># core_extensions extension</span></pre>
            
            <h3 id="label-Sequel-3A-3ASQL-3A-3AJoinClause"><a href="../../classes/Sequel/SQL/JoinClause.html">Sequel::SQL::JoinClause</a><span><a href="#label-Sequel-3A-3ASQL-3A-3AJoinClause">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p><a
            href="../../classes/Sequel/SQL/JoinClause.html">Sequel::SQL::JoinClause</a>
            objects represent SQL JOIN clauses.  They are usually not created manually,
            as the Dataset join methods create them automatically.</p>
            
            <h3 id="label-Sequel-3A-3ASQL-3A-3APlaceholderLiteralString"><a href="../../classes/Sequel/SQL/PlaceholderLiteralString.html">Sequel::SQL::PlaceholderLiteralString</a><span><a href="#label-Sequel-3A-3ASQL-3A-3APlaceholderLiteralString">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p><a
            href="../../classes/Sequel/SQL/PlaceholderLiteralString.html">Sequel::SQL::PlaceholderLiteralString</a>
            objects represent a literal SQL string with placeholders for variables. 
            There are three types of these objects. The first type uses question marks
            with multiple placeholder value objects:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">PlaceholderLiteralString</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;? = ?&#39;</span>, [:<span class="ruby-identifier">a</span>, <span class="ruby-value">1</span>]) <span class="ruby-comment"># &quot;a&quot; = 1</span></pre>
            
            <p>The second uses named placeholders with colons and a hash of placeholder
            value objects:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">PlaceholderLiteralString</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;:b = :v&#39;</span>, [{:<span class="ruby-identifier">b=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">a</span>, :<span class="ruby-identifier">v=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>}]) <span class="ruby-comment"># &quot;a&quot; = 1</span></pre>
            
            <p>The third uses an array instead of a string, with multiple placeholder
            objects, each one going in between the members of the array:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">PlaceholderLiteralString</span>.<span class="ruby-identifier">new</span>([<span class="ruby-string">&#39;&#39;</span>, <span class="ruby-string">&#39; = &#39;</span>], [:<span class="ruby-identifier">a</span>, <span class="ruby-value">1</span>]) <span class="ruby-comment"># &quot;a&quot; = 1</span></pre>
            
            <p>For any of these three forms, you can also include a third argument for
            whether to include parentheses around the string:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">PlaceholderLiteralString</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;? = ?&#39;</span>, [:<span class="ruby-identifier">a</span>, <span class="ruby-value">1</span>], <span class="ruby-keyword">true</span>) <span class="ruby-comment"># (&quot;a&quot; = 1)</span></pre>
            
            <p>The following shortcuts exist for creating <a
            href="../../classes/Sequel/SQL/PlaceholderLiteralString.html">Sequel::SQL::PlaceholderLiteralString</a>
            objects:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">lit</span>(<span class="ruby-string">&#39;? = ?&#39;</span>, :<span class="ruby-identifier">a</span>, <span class="ruby-value">1</span>)&#x000A;<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">lit</span>(<span class="ruby-string">&#39;:b = :v&#39;</span>, :<span class="ruby-identifier">b=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">a</span>, :<span class="ruby-identifier">v=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>)&#x000A;<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">lit</span>([<span class="ruby-string">&#39;&#39;</span>, <span class="ruby-string">&#39; = &#39;</span>], :<span class="ruby-identifier">a</span>, <span class="ruby-value">1</span>)&#x000A;&#x000A;<span class="ruby-string">&#39;? = ?&#39;</span>.<span class="ruby-identifier">lit</span>(:<span class="ruby-identifier">a</span>, <span class="ruby-value">1</span>) <span class="ruby-comment"># core_extensions extension</span>&#x000A;<span class="ruby-string">&#39;:b = :v&#39;</span>.<span class="ruby-identifier">lit</span>(:<span class="ruby-identifier">b=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">a</span>, :<span class="ruby-identifier">v=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>) <span class="ruby-comment"># core_extensions extension</span></pre>
            
            <h3 id="label-Sequel-3A-3ASQL-3A-3AOrderedExpression"><a href="../../classes/Sequel/SQL/OrderedExpression.html">Sequel::SQL::OrderedExpression</a><span><a href="#label-Sequel-3A-3ASQL-3A-3AOrderedExpression">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p><a
            href="../../classes/Sequel/SQL/OrderedExpression.html">Sequel::SQL::OrderedExpression</a>
            objects represent ascending or descending sorts, used by the Dataset order
            methods.  They take an expression, and whether to sort it ascending or
            descending:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">OrderedExpression</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">a</span>) <span class="ruby-comment"># &quot;a&quot; DESC</span>&#x000A;<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">OrderedExpression</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">a</span>, <span class="ruby-keyword">false</span>) <span class="ruby-comment"># &quot;a&quot; ASC</span></pre>
            
            <p>Additionally, they take an options hash, which can be used to specify how
            nulls can be sorted:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">OrderedExpression</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">a</span>, <span class="ruby-keyword">true</span>, :<span class="ruby-identifier">nulls=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">first</span>) <span class="ruby-comment"># &quot;a&quot; DESC NULLS FIRST</span>&#x000A;<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">OrderedExpression</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">a</span>, <span class="ruby-keyword">false</span>, :<span class="ruby-identifier">nulls=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">last</span>) <span class="ruby-comment"># &quot;a&quot; ASC NULLS LAST</span></pre>
            
            <p>The following shortcuts exist for creating <a
            href="../../classes/Sequel/SQL/OrderedExpression.html">Sequel::SQL::OrderedExpression</a>
            objects:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">asc</span>(:<span class="ruby-identifier">a</span>)&#x000A;<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">desc</span>(:<span class="ruby-identifier">a</span>)&#x000A;<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">asc</span>(:<span class="ruby-identifier">a</span>, :<span class="ruby-identifier">nulls=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">first</span>)&#x000A;<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">desc</span>(:<span class="ruby-identifier">a</span>, :<span class="ruby-identifier">nulls=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">last</span>)&#x000A;&#x000A;:<span class="ruby-identifier">a</span>.<span class="ruby-identifier">asc</span> <span class="ruby-comment"># core_extensions extension</span>&#x000A;:<span class="ruby-identifier">a</span>.<span class="ruby-identifier">desc</span> <span class="ruby-comment"># core_extensions extension</span>&#x000A;:<span class="ruby-identifier">a</span>.<span class="ruby-identifier">asc</span>(:<span class="ruby-identifier">nulls=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">first</span>) <span class="ruby-comment"># core_extensions extension</span>&#x000A;:<span class="ruby-identifier">a</span>.<span class="ruby-identifier">desc</span>(:<span class="ruby-identifier">nulls=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">last</span>) <span class="ruby-comment"># core_extensions extension</span></pre>
            
            <h3 id="label-Sequel-3A-3ASQL-3A-3ASubscript"><a href="../../classes/Sequel/SQL/Subscript.html">Sequel::SQL::Subscript</a><span><a href="#label-Sequel-3A-3ASQL-3A-3ASubscript">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p><a
            href="../../classes/Sequel/SQL/Subscript.html">Sequel::SQL::Subscript</a>
            objects represent SQL database array access.  They take an expression and
            an array of indexes (or a range for an SQL array slice):</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Subscript</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">a</span>, [<span class="ruby-value">1</span>]) <span class="ruby-comment"># &quot;a&quot;[1]</span>&#x000A;<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Subscript</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">a</span>, [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>]) <span class="ruby-comment"># &quot;a&quot;[1, 2]</span>&#x000A;<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Subscript</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">a</span>, [<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>]) <span class="ruby-comment"># &quot;a&quot;[1:2]</span></pre>
            
            <p>The following shortcuts exist for creating <a
            href="../../classes/Sequel/SQL/Subscript.html">Sequel::SQL::Subscript</a>
            objects:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">subscript</span>(:<span class="ruby-identifier">a</span>, <span class="ruby-value">1</span>)&#x000A;<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">subscript</span>(:<span class="ruby-identifier">a</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>)&#x000A;<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">subscript</span>(:<span class="ruby-identifier">a</span>, <span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>)&#x000A;&#x000A;:<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sql_subscript</span>(<span class="ruby-value">1</span>) <span class="ruby-comment"># core_extensions extension</span>&#x000A;:<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sql_subscript</span>(<span class="ruby-value">1</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># core_extensions extension</span>&#x000A;:<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sql_subscript</span>(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>) <span class="ruby-comment"># core_extensions extension</span></pre>
            
            <h3 id="label-Sequel-3A-3ASQL-3A-3AVirtualRow"><a href="../../classes/Sequel/SQL/VirtualRow.html">Sequel::SQL::VirtualRow</a><span><a href="#label-Sequel-3A-3ASQL-3A-3AVirtualRow">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p><a
            href="../../classes/Sequel/SQL/VirtualRow.html">Sequel::SQL::VirtualRow</a>
            is a BasicObject subclass that is the backbone behind the block expression
            support:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">where</span>{<span class="ruby-identifier">a</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">1</span>}</pre>
            
            <p>In the above code, the block is instance-evaled inside a VirtualRow
            instance.</p>
            
            <p>These objects are usually not instantiated manually.  See the <a
            href="virtual_rows_rdoc.html">Virtual Row Guide</a> for details.</p>
            
            <h3 id="label-Sequel-3A-3ASQL-3A-3AWindow"><a href="../../classes/Sequel/SQL/Window.html">Sequel::SQL::Window</a><span><a href="#label-Sequel-3A-3ASQL-3A-3AWindow">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p><a href="../../classes/Sequel/SQL/Window.html">Sequel::SQL::Window</a>
            objects represent the windows used by <a
            href="../../classes/Sequel/SQL/Function.html">Sequel::SQL::Function</a>.
            They use a hash-based API, supporting the :frame, :order, :partition, and
            :window options:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Window</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">order=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">a</span>) <span class="ruby-comment"># (ORDER BY &quot;a&quot;)</span>&#x000A;<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Window</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">partition=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">a</span>) <span class="ruby-comment"># (PARTITION BY &quot;a&quot;)</span>&#x000A;&#x000A;<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Window</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">partition=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">a</span>, :<span class="ruby-identifier">frame=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">all</span>)&#x000A;<span class="ruby-comment"># (PARTITION BY &quot;a&quot; ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)</span></pre>
            
            <h3 id="label-Sequel-3A-3ASQL-3A-3AWrapper"><a href="../../classes/Sequel/SQL/Wrapper.html">Sequel::SQL::Wrapper</a><span><a href="#label-Sequel-3A-3ASQL-3A-3AWrapper">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p><a href="../../classes/Sequel/SQL/Wrapper.html">Sequel::SQL::Wrapper</a>
            objects wrap arbitrary objects so that they can be used in <a
            href="../../classes/Sequel.html">Sequel</a> expressions:</p>
            
            <pre class="ruby"><span class="ruby-identifier">o</span> = <span class="ruby-constant">Object</span>.<span class="ruby-identifier">new</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">sql_literal</span>(<span class="ruby-identifier">ds</span>) <span class="ruby-string">&quot;foo&quot;</span> <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Wrapper</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">o</span>) <span class="ruby-comment"># foo</span></pre>
            
            <p>The advantage of wrapping the object is that you can the call <a
            href="../../classes/Sequel.html">Sequel</a> methods on the wrapper that
            would not be defined on the object itself:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Wrapper</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">o</span>) <span class="ruby-operator">+</span> <span class="ruby-value">1</span> <span class="ruby-comment"># (foo + 1)</span></pre>
            
            <p>You can use the Sequel.[] method to wrap any object:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span>[<span class="ruby-identifier">o</span>]</pre>
            
            <p>However, note that that does not necessarily return a <a
            href="../../classes/Sequel/SQL/Wrapper.html">Sequel::SQL::Wrapper</a>
            object, it may return a different class of object, such as a <a
            href="../../classes/Sequel/SQL/ComplexExpression.html">Sequel::SQL::ComplexExpression</a>
            subclass object.</p>
          </div>
          <div id='context'>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="https://github.com/rdoc/hanna-nouveau"><strong>Hanna Nouveau</strong> RDoc template</a>
    </div>
  </body>
</html>
