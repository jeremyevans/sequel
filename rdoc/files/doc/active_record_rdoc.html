<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>active_record.rdoc</title>
    <meta content='text/html; charset=US-ASCII' http-equiv='Content-Type'>
    <link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='file' id='wrapper'>
      <div class='header'>
        <h1 class='name'>active_record.rdoc</h1>
        <div class='paths'>
          doc/active_record.rdoc
        </div>
        <div class='last-update'>
          Last Update:
          <span class='datetime'>2013-10-21 11:50:03 -0700</span>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <h1 id="label-Sequel+for+ActiveRecord+Users"><a href="../../classes/Sequel.html">Sequel</a> for ActiveRecord Users</h1>
            
            <p>This guide is aimed at helping ActiveRecord users transition to <a
            href="../../classes/Sequel.html">Sequel</a>.  It assumes the user is
            familiar with ActiveRecord 2, but if you are familiar with a newer
            ActiveRecord version, the transition should be even easier.</p>
            
            <h2 id="label-Introduction">Introduction</h2>
            
            <p>Both <a href="../../classes/Sequel.html">Sequel</a> and ActiveRecord use
            the active record pattern of database access, where model instances are
            objects that wrap a row in a database table or view, encapsulating the
            database access, and adding domain logic on that data.  Just like
            ActiveRecord, <a href="../../classes/Sequel.html">Sequel</a> supports both
            associations and inheritance, though <a
            href="../../classes/Sequel.html">Sequel</a> does so in a more flexible
            manner than ActiveRecord.</p>
            
            <p>Let&#39;s quickly run through the ActiveRecord <a
            href="../README_rdoc.html">README</a> and show how it applies to <a
            href="../../classes/Sequel.html">Sequel</a>.</p>
            
            <h2 id="label-Automatic+Mapping">Automatic Mapping</h2>
            
            <p>Just like ActiveRecord, <a href="../../classes/Sequel.html">Sequel</a> maps
            classes to tables and automatically creates accessor methods for the
            columns in the table, so if you have an albums table with a primary key
            named "id" and a string/varchar column named "name", the minimal model
            class is:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> will autogenerate the column
            accessors, so you can do:</p>
            
            <pre>album = Album.new&#x000A;album.name = &#39;RF&#39;</pre>
            
            <p>If the table name for the class doesn&#39;t match the default one <a
            href="../../classes/Sequel.html">Sequel</a> will choose, you can specify it
            manually:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>(:<span class="ruby-identifier">records</span>)&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h2 id="label-Associations">Associations</h2>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> supports most of the same
            association types as ActiveRecord, but it uses names that reflect the
            database relationships instead of ones that imply ownership:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">artist</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">tracks</span>&#x000A;  <span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">tags</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h2 id="label-Compositions">Compositions</h2>
            
            <p>Sequel&#39;s <code>composition</code> plugin allows you to easily create
            accessor methods that are composed of one or more of the database&#39;s
            columns, similar to ActiveRecord&#39;s <code>composed_of</code>:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">composition</span>&#x000A;  <span class="ruby-identifier">composition</span> :<span class="ruby-identifier">address</span>, :<span class="ruby-identifier">mapping=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">street</span>, :<span class="ruby-identifier">city</span>, :<span class="ruby-identifier">state</span>, :<span class="ruby-identifier">zip</span>]&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h2 id="label-Validations">Validations</h2>
            
            <p>Sequel&#39;s <code>validation_class_methods</code> plugin is modeled
            directly on ActiveRecord&#39;s validations, but the recommended approach is
            to use the <code>validation_helpers</code> plugin inside a
            <code>validate</code> instance method:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">validation_helpers</span>&#x000A;&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">validate</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-identifier">validates_presence</span> [:<span class="ruby-identifier">name</span>, :<span class="ruby-identifier">copies_sold</span>]&#x000A;    <span class="ruby-identifier">validates_unique</span> [:<span class="ruby-identifier">name</span>, :<span class="ruby-identifier">artist_id</span>]&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h2 id="label-Hooks%2FCallbacks">Hooks/Callbacks</h2>
            
            <p>Sequel&#39;s <code>hook_class_methods</code> plugin is modeled directly on
            ActiveRecord&#39;s callbacks, but the recommended approach is to define
            your hooks/callbacks as instance methods:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">before_create</span>&#x000A;    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">copies_sold</span> <span class="ruby-operator">||=</span> <span class="ruby-value">0</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">after_update</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-constant">AuditLog</span>.<span class="ruby-identifier">create</span>(:<span class="ruby-identifier">log=</span><span class="ruby-operator">&gt;</span><span class="ruby-node">&quot;Updated Album #{id}&quot;</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Observers can be implemented completely by hooks, so <a
            href="../../classes/Sequel.html">Sequel</a> doesn&#39;t offer a separate
            observer class.</p>
            
            <h2 id="label-Inheritance">Inheritance</h2>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> supports both single table
            inheritance and class table inheritance using plugins:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Employee</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">single_table_inheritance</span>, :<span class="ruby-identifier">class_name_column</span>&#x000A;  <span class="ruby-comment"># or</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">class_table_inheritance</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Staff</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Employee</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Manager</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Employee</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Executive</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Manager</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h2 id="label-Transactions">Transactions</h2>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> supports transactions via
            the Database object (we recommend using the DB constant for single database
            applications):</p>
            
            <pre>DB.transaction do&#x000A;  album.artist.num_albums -= 1&#x000A;  album.artist.save&#x000A;  album.delete&#x000A;end</pre>
            
            <p>For model classes, you can always access the database via <code>db</code>:</p>
            
            <pre>Album.db.transaction do&#x000A;  album.artist.num_albums -= 1&#x000A;  album.artist.save&#x000A;  album.delete&#x000A;end</pre>
            
            <h2 id="label-Reflection">Reflection</h2>
            
            <p>Just like ActiveRecord, <a href="../../classes/Sequel.html">Sequel</a> has
            full reflection support for columns, associations, and many other things:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">columns</span> <span class="ruby-comment"># =&gt; [:id, :name, :artist_id, :copies_sold]</span>&#x000A;<span class="ruby-identifier">reflection</span> = <span class="ruby-constant">Album</span>.<span class="ruby-identifier">association_reflection</span>(:<span class="ruby-identifier">artist</span>)&#x000A;<span class="ruby-identifier">reflection</span>[:<span class="ruby-identifier">type</span>] <span class="ruby-operator">==</span> :<span class="ruby-identifier">many_to_one</span></pre>
            
            <h2 id="label-Direct+Manipulation">Direct Manipulation</h2>
            
            <p>Just like ActiveRecord, <a href="../../classes/Sequel.html">Sequel</a>
            doesn&#39;t use sessions, it lets you modify objects and have them be saved
            inside the call to <code>save</code>:</p>
            
            <pre>album = Album[1234]&#x000A;# modify album&#x000A;album.save</pre>
            
            <h2 id="label-Database+Abstraction">Database Abstraction</h2>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> supports far more database
            abstractions than ActiveRecord, and setting up the database connection is
            easy:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span> = <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">sqlite</span> <span class="ruby-comment"># memory database</span>&#x000A;<span class="ruby-constant">DB</span> = <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">connect</span>(<span class="ruby-string">&#39;postgres://user:pass@host/database&#39;</span>) <span class="ruby-comment"># connection string</span>&#x000A;<span class="ruby-constant">DB</span> = <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">connect</span>(:<span class="ruby-identifier">adapter=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&#39;postgres&#39;</span>, :<span class="ruby-identifier">user=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&#39;?&#39;</span>, :<span class="ruby-identifier">password=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&#39;?&#39;</span>,&#x000A;  :<span class="ruby-identifier">host=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&#39;?&#39;</span>, :<span class="ruby-identifier">database=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&#39;?&#39;</span>) <span class="ruby-comment"># option hash</span></pre>
            
            <h2 id="label-Logging">Logging</h2>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> supports logging of all
            database queries by allowing multiple loggers for each database:</p>
            
            <pre>DB.loggers &lt;&lt; Logger.new($stdout)</pre>
            
            <h2 id="label-Migrations">Migrations</h2>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> supports migrations and has
            a migrator similar to ActiveRecord:</p>
            
            <pre>Sequel.migration do&#x000A;  change do&#x000A;    create_table(:albums) do&#x000A;      primary_key :id&#x000A;      String :name&#x000A;    end&#x000A;  end&#x000A;end</pre>
            
            <h2 id="label-Differences">Differences</h2>
            
            <p>By now, you should have the idea that <a
            href="../../classes/Sequel.html">Sequel</a> supports most things that
            ActiveRecord supports.  The rest of this guide is going to go over how <a
            href="../../classes/Sequel.html">Sequel</a> differs from ActiveRecord in
            terms of operation.</p>
            
            <h3 id="label-Method+Chaining">Method Chaining</h3>
            
            <p>Unlike ActiveRecord 2 (and similar to ActiveRecord 3+), <a
            href="../../classes/Sequel.html">Sequel</a> uses method chains on datasets
            for retrieving objects, so instead of:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">find</span>(:<span class="ruby-identifier">all</span>, :<span class="ruby-identifier">conditions=</span><span class="ruby-operator">&gt;</span>[<span class="ruby-string">&#39;name &gt; ? AND artist_id = ?&#39;</span>, <span class="ruby-string">&#39;RF&#39;</span>, <span class="ruby-value">1</span>],&#x000A;  :<span class="ruby-identifier">order=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&#39;copies_sold&#39;</span>, :<span class="ruby-identifier">select=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&#39;id, name&#39;</span>)</pre>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> uses:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">name</span> <span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;RF&#39;</span>}.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">artist_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>).<span class="ruby-identifier">order</span>(:<span class="ruby-identifier">copies_sold</span>).&#x000A;  <span class="ruby-identifier">select</span>(:<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">name</span>).<span class="ruby-identifier">all</span></pre>
            
            <p>Note that the records aren&#39;t retrieved until <code>all</code> is
            called.</p>
            
            <p>ActiveRecord 3 adopts this method chaining approach, so if you are familiar
            with it, it should be even easier to transition to <a
            href="../../classes/Sequel.html">Sequel</a>.</p>
            
            <h3 id="label-No+Need+for+SQL+String+Fragments">No Need for SQL <a href="../../classes/String.html">String</a> Fragments</h3>
            
            <p>Like the example above, most ActiveRecord code uses SQL string fragments. 
            With <a href="../../classes/Sequel.html">Sequel</a>, you rarely need to. 
            Sequel&#39;s DSL allows you to create complex queries without ever
            specifying SQL string fragments (called literal strings in <a
            href="../../classes/Sequel.html">Sequel</a>).</p>
            
            <p>If you want to use SQL string fragments, <a
            href="../../classes/Sequel.html">Sequel</a> makes it easy by using the
            <code>Sequel.lit</code> method:</p>
            
            <pre>Album.select(Sequel.lit(&#39;id, name&#39;))</pre>
            
            <p>This usage is not encouraged, though.  The recommended way is to use
            symbols to represent the columns:</p>
            
            <pre>Album.select(:id, :name)</pre>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> keeps datasets in an
            abstract format, allowing for powerful capabilities.  For example,
            let&#39;s say you wanted to join to the artists table.  <a
            href="../../classes/Sequel.html">Sequel</a> can automatically qualify all
            references in the current dataset, so that it can be safely joined:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">select</span>(:<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">name</span>).<span class="ruby-identifier">qualify</span>.<span class="ruby-identifier">join</span>(:<span class="ruby-identifier">artists</span>, :<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artist_id</span>)</pre>
            
            <p>This isn&#39;t possible when you use an SQL string fragment.  Another case
            where using an SQL string fragment hurts you is when the SQL syntax cannot
            handle all cases:</p>
            
            <pre>Album.filter(&#39;id NOT IN ?&#39;, ids_array)</pre>
            
            <p>That will work fine if <code>ids_array</code> is not empty, but will not
            work correctly if it is empty.  With <a
            href="../../classes/Sequel.html">Sequel</a>, you do:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">exclude</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">ids_array</span>)</pre>
            
            <p>That will handle cases where <code>ids_array</code> is empty correctly.</p>
            
            <p>A third reason to not use SQL string fragments is database independence. 
            For example, if you want a case insensitive search that works on both
            PostgreSQL and MySQL, the following won&#39;t work:</p>
            
            <pre>Album.filter(&#39;name LIKE ?&#39;, &#39;A%&#39;)</pre>
            
            <p>This is because LIKE is case sensitive on PostgreSQL, but case insensitive
            on MySQL.  With <a href="../../classes/Sequel.html">Sequel</a>, you would
            do:</p>
            
            <pre>Album.filter(Sequel.ilike(:name, &#39;A%&#39;))</pre>
            
            <p>This will do a case insensitive search on both databases.  If you want a
            case sensitive search on both, you can use <code>like</code> instead of
            <code>ilike</code>.</p>
            
            <p><a href="../../classes/String.html">String</a> concatenation is a similar
            area, where MySQL and PostgreSQL handle things differently.  With <a
            href="../../classes/Sequel.html">Sequel</a>, the same code can work on both
            databases:</p>
            
            <pre>Album.select(Sequel.join([:name, &#39; - Name&#39;]))</pre>
            
            <h2 id="label-Flexible+Overriding">Flexible Overriding</h2>
            
            <p>Unlike ActiveRecord 2, which forces you to alias methods if you want to
            override them, with <a href="../../classes/Sequel.html">Sequel</a> you just
            override the methods and call super:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">after_update</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-constant">AuditLog</span>.<span class="ruby-identifier">create</span>(:<span class="ruby-identifier">log=</span><span class="ruby-operator">&gt;</span><span class="ruby-node">&quot;#{model.name} with primary key #{pk} updated&quot;</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>With that code, you have enabled auditing for all model object updates.</p>
            
            <p>Let&#39;s say you want to override accessor methods.  In <a
            href="../../classes/Sequel.html">Sequel</a>, instead of using
            <code>read_attribute</code> and <code>write_attribute</code>, you can just
            call super:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Track</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-comment"># database holds length in integer seconds,</span>&#x000A;  <span class="ruby-comment"># but you want it in minutes as a float</span>&#x000A;&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">length=</span>(<span class="ruby-identifier">minutes</span>)&#x000A;    <span class="ruby-keyword">super</span>((<span class="ruby-identifier">minutes</span>*<span class="ruby-value">60</span>).<span class="ruby-identifier">to_i</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">length</span>&#x000A;    <span class="ruby-keyword">super</span><span class="ruby-operator">/</span><span class="ruby-value">60.0</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>You can override almost all model class or instance methods this way, just
            remember to call <code>super</code>.</p>
            
            <h2 id="label-method_missing+Missing"><code>method_missing</code> Missing</h2>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> does not use
            <code>method_missing</code> unless it&#39;s required that the object
            respond to potentially any method. Neither <code>Sequel::Model</code> nor
            <code>Sequel::Dataset</code> nor <code>Sequel::Database</code> implement
            <code>method_missing</code> at either a class or instance level.  So if you
            call <code>methods</code>, you can see which methods are available, and if
            they aren&#39;t listed, then the object won&#39;t respond to them.  Among
            other things, this means <a href="../../classes/Sequel.html">Sequel</a>
            does not support dynamic finders.  So instead of:</p>
            
            <pre>Album.find_or_create_by_name(&quot;RF&quot;)</pre>
            
            <p>You just use:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">find_or_create</span>(:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&quot;RF&quot;</span>)</pre>
            
            <p>At the instance level, this means that if you select columns that
            aren&#39;t in the models table, you need to use <code>Model#[]</code> to
            access them:</p>
            
            <pre class="ruby"><span class="ruby-identifier">album</span> = <span class="ruby-constant">Album</span>.<span class="ruby-identifier">join</span>(:<span class="ruby-identifier">artist</span>, :<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artist_id</span>).&#x000A; <span class="ruby-identifier">select</span>(:<span class="ruby-identifier">albums__id</span>, :<span class="ruby-identifier">albums__name</span>, :<span class="ruby-identifier">artists__name___artist</span>).<span class="ruby-identifier">first</span>&#x000A; <span class="ruby-comment"># SELECT albums.id, albums.name, artists.name AS artist</span>&#x000A;&#x000A;<span class="ruby-identifier">album</span>.<span class="ruby-identifier">artist</span> <span class="ruby-comment"># Error!</span>&#x000A;<span class="ruby-identifier">album</span>[:<span class="ruby-identifier">artist</span>] <span class="ruby-comment"># Works</span></pre>
            
            <h2 id="label-Associations">Associations</h2>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> associations are similar to
            ActiveRecord associations in some ways, and much different in others.  <a
            href="../../classes/Sequel.html">Sequel</a> provides four association
            creation methods that map to ActiveRecord&#39;s associations:</p>
            <dl class="rdoc-list note-list"><dt>ActiveRecord 
            <dd>
            <p><a href="../../classes/Sequel.html">Sequel</a></p>
            </dd><dt><code>belongs_to</code> 
            <dd>
            <p><code>many_to_one</code></p>
            </dd><dt><code>has_one</code> 
            <dd>
            <p><code>one_to_one</code></p>
            </dd><dt><code>has_many</code> 
            <dd>
            <p><code>one_to_many</code></p>
            </dd><dt><code>has_and_belongs_to_many</code> 
            <dd>
            <p><code>many_to_many</code></p>
            </dd></dl>
            
            <p>Like ActiveRecord, when you create an association in <a
            href="../../classes/Sequel.html">Sequel</a>, it creates an instance method
            with the same name that returns either the matching object or nil for the
            <code>*_to_one</code> associations, or an array of matching objects for the
            <code>*_to_many</code> associations.</p>
            
            <p>Updating <code>*_to_many</code> associations is very different, however. 
            ActiveRecord makes the association method returns an association proxy that
            looks like an array, but has a bunch of added methods to manipulate the
            associated records.  <a href="../../classes/Sequel.html">Sequel</a> uses
            instance methods on the object instead of a proxy to modify the
            association.  Here&#39;s a basic example:</p>
            
            <pre>Artist.one_to_many :albums&#x000A;Album.many_to_one :artist&#x000A;artist = Artist[1]&#x000A;album = Album[1]&#x000A;&#x000A;artist.albums # array of albums&#x000A;album.artist # Artist instance or nil&#x000A;&#x000A;artist.add_album(album) # associate album to artist&#x000A;artist.remove_album(album) # disassociate album from artist&#x000A;artist.remove_all_albums # disassociate all albums from artist</pre>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> doesn&#39;t have a
            <code>has_many :through</code> association, instead you can use a
            <code>many_to_many</code> association in most cases.  <a
            href="../../classes/Sequel.html">Sequel</a> ships with a
            <code>many_through_many</code> plugin that allows you to set up a many to
            many relationship through an arbitrary number of join tables.</p>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> doesn&#39;t come with
            support for polymorphic associations.  Using polymorphic associations is
            generally bad from a database design perspective, as it violates
            referential integrity.  If you have an old database and must have
            polymorphic associations, there is an external
            <code>sequel_polymorphic</code> plugin that can handle them, just by using
            the standard association options provided by <a
            href="../../classes/Sequel.html">Sequel</a>.</p>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> doesn&#39;t directly support
            creating a bunch of associated objects and delaying saving them to the
            database until the main object is saved, like you can with the
            <code>association.build</code> methods in ActiveRecord.  You can use
            +before_save or <code>after_save</code> hooks, or the
            <code>nested_attributes</code> or <code>instance_hooks</code> plugins to
            get similar support.</p>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> supports the same basic
            association hooks/callbacks as ActiveRecord.  It also supports
            <code>:after_load</code>, which is run after the associated objects are
            loaded.  For <code>*_to_one</code> associations, it supports
            <code>before_set</code> and <code>after_set</code> hooks, since a setter
            method is used instead of an add/remove method pair.</p>
            
            <p>If you pass a block to an association method, it&#39;s used to return a
            modified dataset used for the association, instead of to create an
            association extension:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">gold_albums</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span>:<span class="ruby-constant">Album</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">copies_sold</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">500000</span>}&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>If you want to create an association extension, you can use the
            <code>:extend</code> association option with a module, which ActiveRecord
            also supports.  In <a href="../../classes/Sequel.html">Sequel</a>, the
            extensions are applied to the association dataset, not to the array of
            associated objects.  You can access the association dataset using the
            <code>association_dataset</code> method:</p>
            
            <pre>artist.albums_dataset&#x000A;album.artist_dataset</pre>
            
            <p>Association datasets are just like any other <a
            href="../../classes/Sequel.html">Sequel</a> dataset, in that you can filter
            them and manipulate them further:</p>
            
            <pre>gold_albums = artist.albums_dataset.where{copies_sold &gt; 500000}.order(:name).all</pre>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> caches associated objects
            similarly to ActiveRecord, and you can skip the cache by passing
            <code>true</code> to the association method, just like ActiveRecord.</p>
            
            <h3 id="label-Eager+Loading">Eager Loading</h3>
            
            <p>ActiveRecord 2 tries to guess whether to use preloading or JOINs for eager
            loading by scanning the SQL string fragments you provide for table names. 
            This is error prone and <a href="../../classes/Sequel.html">Sequel</a>
            avoids it by giving you separate methods.  In <a
            href="../../classes/Sequel.html">Sequel</a>, <code>eager</code> is used for
            preloading and <code>eager_graph</code> is used for JOINs.  Both have the
            same API:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">albums=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">tags</span>, :<span class="ruby-identifier">tracks</span>])&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">eager_graph</span>(:<span class="ruby-identifier">artist</span>, :<span class="ruby-identifier">tracks</span>)</pre>
            
            <p>With either way of eager loading, you must call <code>all</code> to
            retrieve all records at once.  You cannot use <code>each</code>,
            <code>map</code>, or one of the other Enumerable methods.  Just like
            <code>each</code>, <code>all</code> takes a block that iterates over the
            records:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">albums=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">tags</span>, :<span class="ruby-identifier">tracks</span>]).<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-operator">...</span>} <span class="ruby-comment"># No cookie</span>&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">albums=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">tags</span>, :<span class="ruby-identifier">tracks</span>]).<span class="ruby-identifier">all</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-operator">...</span>} <span class="ruby-comment"># Cookie</span></pre>
            
            <p>Like ActiveRecord, <a href="../../classes/Sequel.html">Sequel</a> supports
            cascading of eager loading for both methods of eager loading.</p>
            
            <p>Unlike ActiveRecord, <a href="../../classes/Sequel.html">Sequel</a> allows
            you to eager load custom associations using the <code>:eager_loader</code>
            and <code>:eager_grapher</code> association options.  See the <a
            href="advanced_associations_rdoc.html">Advanced Associations guide</a> for
            more details.</p>
            
            <p>Table aliasing when eager loading via <code>eager_graph</code> is different
            in <a href="../../classes/Sequel.html">Sequel</a> than ActiveRecord.  <a
            href="../../classes/Sequel.html">Sequel</a> will always attempt to use the
            association name, not the table name, for any associations.  If the
            association name has already been used, <a
            href="../../classes/Sequel.html">Sequel</a> will append _N to it, where N
            starts at 0 and increases by 1.  For example, for a self referential
            association:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Node</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">parent</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span><span class="ruby-keyword">self</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">children</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span><span class="ruby-keyword">self</span>, :<span class="ruby-identifier">key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">parent_id</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-constant">Node</span>.<span class="ruby-identifier">eager_graph</span>(:<span class="ruby-identifier">parent=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">parent</span>, :<span class="ruby-identifier">children=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">children=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">children</span>}).<span class="ruby-identifier">all</span>&#x000A;&#x000A;<span class="ruby-comment"># SELECT nodes.id, nodes.parent_id, -- main table</span>&#x000A;<span class="ruby-comment">#  parent.id AS parent_id_0, parent.parent_id AS parent_parent_id, -- parent</span>&#x000A;<span class="ruby-comment">#  parent_0.id AS parent_0_id, parent_0.parent_id AS parent_0_parent_id, -- grandparent</span>&#x000A;<span class="ruby-comment">#  children.id AS children_id, children.parent_id AS children_parent_id, -- children</span>&#x000A;<span class="ruby-comment">#  children_0.id AS children_0_id, children_0.parent_id AS children_0_parent_id, -- grandchildren</span>&#x000A;<span class="ruby-comment">#  children_1.id AS children_1_id, children_1.parent_id AS children_1_parent_id -- great grandchidren</span>&#x000A;<span class="ruby-comment"># FROM nodes -- main table</span>&#x000A;<span class="ruby-comment">#  LEFT OUTER JOIN nodes AS parent ON (parent.id = nodes.parent_id) -- parent</span>&#x000A;<span class="ruby-comment">#  LEFT OUTER JOIN nodes AS parent_0 ON (parent_0.id = parent.parent_id) -- grandparent</span>&#x000A;<span class="ruby-comment">#  LEFT OUTER JOIN nodes AS children ON (children.parent_id = nodes.id) -- children</span>&#x000A;<span class="ruby-comment">#  LEFT OUTER JOIN nodes AS children_0 ON (children_0.parent_id = children.id) -- grandchildren</span>&#x000A;<span class="ruby-comment">#  LEFT OUTER JOIN nodes AS children_1 ON (children_1.parent_id = children_0.id) -- great grandchildren</span></pre>
            
            <p>You can specify aliases on a per join basis, too:</p>
            
            <pre class="ruby"><span class="ruby-constant">Node</span>.<span class="ruby-identifier">eager_graph</span>(:<span class="ruby-identifier">parent=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">as</span>(:<span class="ruby-identifier">parent</span>, :<span class="ruby-identifier">grandparent</span>),&#x000A;  :<span class="ruby-identifier">children=</span><span class="ruby-operator">&gt;</span>{<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">as</span>(:<span class="ruby-identifier">children</span>, :<span class="ruby-identifier">grandchildren</span>)=<span class="ruby-operator">&gt;</span><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">as</span>(:<span class="ruby-identifier">children</span>, :<span class="ruby-identifier">great_grandchildren</span>)}).<span class="ruby-identifier">all</span>&#x000A;&#x000A;<span class="ruby-comment"># SELECT nodes.id, nodes.parent_id,</span>&#x000A;<span class="ruby-comment">#  parent.id AS parent_id_0, parent.parent_id AS parent_parent_id,</span>&#x000A;<span class="ruby-comment">#  grandparent.id AS grandparent_id, grandparent.parent_id AS grandparent_parent_id,</span>&#x000A;<span class="ruby-comment">#  children.id AS children_id, children.parent_id AS children_parent_id,</span>&#x000A;<span class="ruby-comment">#  grandchildren.id AS grandchildren_id, grandchildren.parent_id AS grandchildren_parent_id,</span>&#x000A;<span class="ruby-comment"># great_grandchildren.id AS great_grandchildren_id, great_grandchildren.parent_id AS great_grandchildren_parent_id</span>&#x000A;<span class="ruby-comment"># FROM nodes</span>&#x000A;<span class="ruby-comment">#  LEFT OUTER JOIN nodes AS parent ON (parent.id = nodes.parent_id)</span>&#x000A;<span class="ruby-comment">#  LEFT OUTER JOIN nodes AS grandparent ON (grandparent.id = parent.parent_id)</span>&#x000A;<span class="ruby-comment">#  LEFT OUTER JOIN nodes AS children ON (children.parent_id = nodes.id)</span>&#x000A;<span class="ruby-comment">#  LEFT OUTER JOIN nodes AS grandchildren ON (grandchildren.parent_id = children.id)</span>&#x000A;<span class="ruby-comment">#  LEFT OUTER JOIN nodes AS great_grandchildren ON (great_grandchildren.parent_id = grandchildren.id)</span></pre>
            
            <h3 id="label-Options+">Options </h3>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> supports many more
            association options than ActiveRecord, but here&#39;s a mapping of
            ActiveRecord association options to <a
            href="../../classes/Sequel.html">Sequel</a> association options.  Note that
            when you specify columns in <a href="../../classes/Sequel.html">Sequel</a>,
            you use symbols, not strings.  Where ActiveRecord would use an SQL string
            fragment with embedded commas for multiple columns, <a
            href="../../classes/Sequel.html">Sequel</a> would use an array of column
            symbols.</p>
            
            <h3 id="label-Shared+options">Shared options</h3>
            
            <p>These options are shared by more than one ActiveRecord association.</p>
            <dl class="rdoc-list note-list"><dt>ActiveRecord option 
            <dd>
            <p><a href="../../classes/Sequel.html">Sequel</a> option</p>
            </dd><dt><code>:class_name</code> 
            <dd>
            <p><code>:class</code></p>
            </dd><dt><code>:conditions</code> 
            <dd>
            <p><code>:conditions</code></p>
            </dd><dt><code>:select</code> 
            <dd>
            <p><code>:select</code></p>
            </dd><dt><code>:order</code> 
            <dd>
            <p><code>:order</code></p>
            </dd><dt><code>:extend</code> 
            <dd>
            <p><code>:extend</code></p>
            </dd><dt><code>:limit</code> 
            <dd>
            <p><code>:limit</code></p>
            </dd><dt><code>:offset</code> 
            <dd>
            <p><code>:limit</code> with an array with the second element being the offset</p>
            </dd><dt><code>:uniq</code> 
            <dd>
            <p><code>:uniq</code></p>
            </dd><dt><code>:validate</code> 
            <dd>
            <p><code>:validate</code></p>
            </dd><dt><code>:dependent</code> 
            <dd>
            <p>The <code>associations_dependencies</code> plugin</p>
            </dd><dt><code>:polymorphic</code>, <code>:as</code>, <code>:source_type</code> 
            <dd>
            <p>The <code>sequel_polymorphic</code> external plugin</p>
            </dd><dt><code>:include</code> 
            <dd>
            <p><code>:eager</code>, <code>:eager_graph</code></p>
            </dd><dt><code>:readonly</code> 
            <dd>
            <p>No equivalent, the <a href="../../classes/Sequel.html">Sequel</a>
            <code>:read_only</code> option just means the modification methods are not
            created (it makes the association read only, not records retrieved through
            the association)</p>
            </dd><dt><code>:through</code>, <code>:source</code> 
            <dd>
            <p>Use a <code>many_to_many</code> association, or the
            <code>many_through_many</code> plugin</p>
            </dd><dt><code>:touch</code> 
            <dd>
            <p>The <code>touch</code> plugin</p>
            </dd><dt><code>:autosave</code> 
            <dd>
            <p>A <code>before_save</code> or <code>after_save</code> hook</p>
            </dd><dt><code>:finder_sql</code> 
            <dd>
            <p><code>:dataset</code> to set a custom dataset</p>
            </dd><dt><code>:counter_sql</code> 
            <dd>
            <p>No direct equivalent, but a count on the dataset will use the custom
            dataset specified by <code>:dataset</code></p>
            </dd><dt><code>:group</code> 
            <dd>
            <p>Use the association block to add the group to the dataset</p>
            </dd><dt><code>:having</code> 
            <dd>
            <p>Use the association block to add the having to the dataset</p>
            </dd></dl>
            
            <h3 id="label-belongs_to"><code>belongs_to</code></h3>
            <dl class="rdoc-list note-list"><dt><code>belongs_to</code> option 
            <dd>
            <p><code>many_to_one</code> option</p>
            </dd><dt><code>:foreign_key</code> 
            <dd>
            <p><code>:key</code></p>
            </dd><dt><code>:primary_key</code> 
            <dd>
            <p><code>:primary_key</code></p>
            </dd><dt><code>:counter_cache</code> 
            <dd>
            <p>No equivalent</p>
            </dd></dl>
            
            <h3 id="label-has_one%2C+has_many"><code>has_one</code>, <code>has_many</code></h3>
            <dl class="rdoc-list note-list"><dt><code>has_one</code>, <code>has_many</code> option 
            <dd>
            <p><code>one_to_one</code>, <code>one_to_many</code> option</p>
            </dd><dt><code>:foreign_key</code> 
            <dd>
            <p><code>:key</code></p>
            </dd></dl>
            
            <h3 id="label-has_and_belongs_to_many"><code>has_and_belongs_to_many</code></h3>
            <dl class="rdoc-list note-list"><dt><code>has_and_belongs_to_many</code> option 
            <dd>
            <p><code>many_to_many</code> option</p>
            </dd><dt><code>:foreign_key</code> 
            <dd>
            <p><code>:left_key</code></p>
            </dd><dt><code>:association_foreign_key</code> 
            <dd>
            <p><code>:right_key</code></p>
            </dd><dt><code>:join_table</code> 
            <dd>
            <p><code>:join_table</code></p>
            </dd><dt><code>:delete_sql</code> 
            <dd>
            <p><code>:remover</code></p>
            </dd><dt><code>:insert_sql</code> 
            <dd>
            <p><code>:adder</code></p>
            </dd></dl>
            
            <h2 id="label-Validation+Errors">Validation Errors</h2>
            
            <p>If there are errors when validating an object in <a
            href="../../classes/Sequel.html">Sequel</a>, they are stored in a
            <code>Sequel::Model::Errors</code> instance.  It&#39;s mostly similar to
            <code>ActiveRecord::Errors</code>, so this section will just go over the
            differences.</p>
            
            <p><code>Sequel::Model::Errors</code> is a hash subclass where keys are
            usually column symbols (not required), and values are arrays of error
            messages.  So if you have two error messages on the same column,
            <code>each</code> will only yield once, not twice.</p>
            
            <p>The <code>add_on_blank</code>, <code>add_on_empty</code>,
            <code>add_to_base</code>, <code>each_full</code>,
            <code>generate_message</code>, <code>invalid?</code>, <code>on_base</code>,
            and <code>to_xml</code> methods don&#39;t exist.  <code>[]</code> should
            not be used directly, instead you should use <code>on</code>.</p>
            
            <p>You can think of <code>Sequel::Model::Errors</code> as a subset of
            <code>ActiveRecord::Errors</code> if you stick to <code>on</code>,
            <code>add</code>, and <code>full_messages</code>.</p>
            
            <h2 id="label-Sequel+Configuration+Flags"><a href="../../classes/Sequel.html">Sequel</a> Configuration Flags</h2>
            
            <p>Unlike ActiveRecord, Sequel&#39;s behavior depends on how you configure it.
            In <a href="../../classes/Sequel.html">Sequel</a>, you can set flags at the
            global, class, and instance level that change the behavior of <a
            href="../../classes/Sequel.html">Sequel</a>.  Here&#39;s a brief
            description of the flags:</p>
            <dl class="rdoc-list note-list"><dt><code>raise_on_save_failure</code> 
            <dd>
            <p>Whether to raise an error instead of returning nil on a failure to
            save/create/save_changes/etc due to a validation failure or a before_* hook
            returning false. By default, an error is raised, when this is set to false,
            nil is returned instead.</p>
            </dd><dt><code>raise_on_typecast_failure</code> 
            <dd>
            <p>Whether to raise an error when unable to typecast data for a column
            (default: true). This should be set to false if you want to use validations
            to display nice error messages to the user (e.g. most web applications).
            You can use the <code>validates_schema_types</code> validation in
            connection with this option to check for typecast failures.</p>
            </dd><dt><code>require_modification</code> 
            <dd>
            <p>Whether to raise an error if an UPDATE or DELETE query related to a model
            instance does not modify exactly 1 row. If set to false, <a
            href="../../classes/Sequel.html">Sequel</a>  will not check the number of
            rows modified (default: true if the database supports it).</p>
            </dd><dt><code>strict_param_setting</code> 
            <dd>
            <p>Whether new/set/update and their variants should raise an error if an
            invalid key is used. A key is invalid if no setter method exists for that
            key or the access to the setter method is restricted (e.g. due to it being
            a primary key field). If set to false, silently skip any key where the
            setter method doesn&#39;t exist or access to it is restricted.</p>
            </dd><dt><code>typecast_empty_string_to_nil</code> 
            <dd>
            <p>Whether to typecast the empty string (&#39;&#39;) to nil for columns that
            are not string or blob. In most cases the empty string would be the way to
            specify a NULL SQL value in string form (nil.to_s == &#39;&#39;), and an
            empty string would not usually be typecast correctly for other types, so
            the default is true.</p>
            </dd><dt><code>typecast_on_assignment</code> 
            <dd>
            <p>Whether to typecast attribute values on assignment (default: true). If set
            to false, no typecasting is done, so it will be left up to the database to
            typecast the value correctly.</p>
            </dd><dt><code>use_transactions</code> 
            <dd>
            <p>Whether to use a transaction by default when saving/deleting records
            (default: true). If you are sending database queries in before or after
            hooks, you shouldn&#39;t change the default setting without a good reason.</p>
            </dd></dl>
            
            <h2 id="label-ActiveRecord+Method+to+Sequel+Method+Mapping+">ActiveRecord Method to <a href="../../classes/Sequel.html">Sequel</a> Method Mapping </h2>
            
            <p>This part of the guide will list <a
            href="../../classes/Sequel.html">Sequel</a> equivalents for ActiveRecord
            methods, hopefully allowing you to convert your existing ActiveRecord code
            to <a href="../../classes/Sequel.html">Sequel</a> code more easily.</p>
            
            <h3 id="label-Class+Methods+with+Significantly+Different+Behavior">Class Methods with Significantly Different Behavior</h3>
            
            <h4 id="label-abstract_class%2C+abstract_class%3D%2C+abstract_class%3F"><code>abstract_class</code>, <code>abstract_class=</code>, <code>abstract_class?</code></h4>
            
            <p>With <a href="../../classes/Sequel.html">Sequel</a>, these methods
            don&#39;t exist because it doesn&#39;t default to using single table
            inheritance in subclasses.  ActiveRecord assumes that subclasses of Model
            classes use single table inheritance, and you have to set
            <code>abstract_class = true</code> to use an abstract class.  In <a
            href="../../classes/Sequel.html">Sequel</a>, you must use the
            <code>single_table_inheritance</code> or
            <code>class_table_inheritance</code> plugin to configure inheritance in the
            database.</p>
            
            <h4 id="label-all"><code>all</code></h4>
            
            <p>In both <a href="../../classes/Sequel.html">Sequel</a> and ActiveRecord,
            calling <code>all</code> will give you an array of all records.  However,
            while in ActiveRecord you pass options to <code>all</code> to filter or
            order the results, in <a href="../../classes/Sequel.html">Sequel</a> you
            call dataset methods to filter or order the results, and then end the
            method chain with a call to <code>all</code> to return the records.</p>
            
            <h4 id="label-column_names"><code>column_names</code></h4>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> uses symbols for columns, so
            the <code>columns</code> method returns an array of symbols.  If you want
            an array of strings:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">columns</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">to_s</span>}</pre>
            
            <h4 id="label-columns"><code>columns</code></h4>
            
            <p><code>Sequel::Model.columns</code> returns an array of column name symbols.
            The closest similar thing would be to get the database schema hash for each
            column:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">columns</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-constant">Album</span>.<span class="ruby-identifier">db_schema</span>[<span class="ruby-identifier">x</span>]}</pre>
            
            <h4 id="label-composed_of"><code>composed_of</code></h4>
            
            <p>As mentioned earlier, <a href="../../classes/Sequel.html">Sequel</a> uses
            the <code>composition</code> plugin for this:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">composition</span>&#x000A;  <span class="ruby-identifier">composition</span> :<span class="ruby-identifier">address</span>, :<span class="ruby-identifier">mapping=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">street</span>, :<span class="ruby-identifier">city</span>, :<span class="ruby-identifier">state</span>, :<span class="ruby-identifier">zip</span>]&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-connected%3F"><code>connected?</code></h4>
            
            <p><code>Sequel::Model</code> raises an exception if you haven&#39;t
            instantiated a <code>Sequel::Database</code> object before loading the
            model class.  However, if you want to test the connection to the database:</p>
            
            <pre>Sequel::Model.db.test_connection</pre>
            
            <p>Note that <code>test_connection</code> will return true if a connection can
            be made, but will probably raise an exception if it cannot be made.</p>
            
            <h4 id="label-connection"><code>connection</code></h4>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> only uses connections for
            the minimum amount of time necessary, checking them out to do a query, and
            returning them as soon as the query finishes.  If you do want direct access
            to the connection object:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>.<span class="ruby-identifier">db</span>.<span class="ruby-identifier">synchronize</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">connection</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-operator">...</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Note that the connection is yielded to the block, and the block ensures it
            is returned to the pool.  <a href="../../classes/Sequel.html">Sequel</a>
            doesn&#39;t have a method that returns a connection, since that would check
            it out with no ability to ensure it is returned to the pool.</p>
            
            <h4 id="label-count_by_sql"><code>count_by_sql</code></h4>
            
            <p>You can call <code>with_sql</code> to set the SQL to use, and the
            <code>single_value</code> to retrieve the result.</p>
            
            <pre>Album.with_sql(&quot;SELECT COUNT(*) ...&quot;).single_value</pre>
            
            <h4 id="label-delete%2C+delete_all"><code>delete</code>, <code>delete_all</code></h4>
            
            <p>You probably want to filter first, then call <code>delete</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">id</span>).<span class="ruby-identifier">delete</span>&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(<span class="ruby-string">&quot;artist_id = ?&quot;</span>, <span class="ruby-value">5</span>).<span class="ruby-identifier">delete</span></pre>
            
            <p>If you really want to delete all rows in the table,call <code>delete</code>
            on the Model&#39;s dataset:</p>
            
            <pre>Album.dataset.delete</pre>
            
            <h4 id="label-destroy%2C+destroy_all"><code>destroy</code>, <code>destroy_all</code></h4>
            
            <p>Similar to <code>delete</code>, you filter first, then
            <code>destroy</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">id</span>).<span class="ruby-identifier">destroy</span>&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(<span class="ruby-string">&quot;artist_id = ?&quot;</span>, <span class="ruby-value">5</span>).<span class="ruby-identifier">destroy</span></pre>
            
            <p>If you really want to destroy all rows in the table,call
            <code>destroy</code> on the Model&#39;s dataset:</p>
            
            <pre>Album.dataset.destroy</pre>
            
            <h4 id="label-establish_connection"><code>establish_connection</code></h4>
            
            <p>If you want to use a specific <code>Sequel::Database</code> object, you can
            use <code>db=</code>:</p>
            
            <pre>BACKUP_DB = Sequel.connect(...)&#x000A;Album.db = BACKUP_DB</pre>
            
            <p>If you want a specific dataset in that database, you can use
            <code>set_dataset</code> or <code>dataset=</code>:</p>
            
            <pre>Album.set_dataset BACKUP_DB[:albums]&#x000A;Album.dataset = BACKUP_DB[:albums]</pre>
            
            <h4 id="label-exists%3F"><code>exists?</code></h4>
            
            <p>You need to filter the dataset first, then call <code>empty?</code> and
            invert the result:</p>
            
            <pre class="ruby"><span class="ruby-operator">!</span><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>).<span class="ruby-identifier">empty?</span></pre>
            
            <h4 id="label-find"><code>find</code></h4>
            
            <p>ActiveRecord&#39;s <code>find</code> can be used for a lot of different
            things.  If you are trying to find a single object given a primary key:</p>
            
            <pre>Album[1]</pre>
            
            <p>Note that <a href="../../classes/Sequel.html">Sequel</a> returns nil if no
            record is found, it doesn&#39;t raise an exception.  To raise an exception
            if no record is found:</p>
            
            <pre>Album.with_pk!(1)</pre>
            
            <p>If you want to find multiple objects using an array of primary keys:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span>[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]).<span class="ruby-identifier">all</span></pre>
            
            <p>If you are using <code>find(:first, ...)</code>, you use a method chain
            instead of passing the options, and end it with <code>first</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">artist_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>).<span class="ruby-identifier">order</span>(:<span class="ruby-identifier">name</span>).<span class="ruby-identifier">first</span></pre>
            
            <p>If you are using <code>find(:last, ...)</code>, you need to specify an
            order in <a href="../../classes/Sequel.html">Sequel</a>, but the same
            method chain approach is used, which you end with <code>last</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">artist_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>).<span class="ruby-identifier">order</span>(:<span class="ruby-identifier">name</span>).<span class="ruby-identifier">last</span>&#x000A;<span class="ruby-comment"># You could also do:</span>&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">artist_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>).<span class="ruby-identifier">reverse_order</span>(:<span class="ruby-identifier">name</span>).<span class="ruby-identifier">first</span></pre>
            
            <p>If you are using <code>find(:all, ...)</code>, you use a method chain
            instead of passing the options, and end it with <code>all</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">artist_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>).<span class="ruby-identifier">order</span>(:<span class="ruby-identifier">name</span>).<span class="ruby-identifier">all</span></pre>
            
            <p>Here&#39;s a mapping of ActiveRecord <code>find</code> options to
            <code>Sequel::Dataset</code> methods:</p>
            <dl class="rdoc-list note-list"><dt>:conditions 
            <dd>
            <p>filter, where</p>
            </dd><dt>:order 
            <dd>
            <p>order</p>
            </dd><dt>:group 
            <dd>
            <p>group</p>
            </dd><dt>:limit 
            <dd>
            <p>limit</p>
            </dd><dt>:offset 
            <dd>
            <p>offset</p>
            </dd><dt>:joins 
            <dd>
            <p>join, left_join, etc. # many other join methods</p>
            </dd><dt>:include 
            <dd>
            <p>eager, eager_graph # eager does preloading, eager_graph does JOINs</p>
            </dd><dt>:select 
            <dd>
            <p>select</p>
            </dd><dt>:from 
            <dd>
            <p>from</p>
            </dd><dt>:read_only 
            <dd>
            <p># No <a href="../../classes/Sequel.html">Sequel</a> equivalent</p>
            </dd><dt>:lock 
            <dd>
            <p>for_update, lock_style</p>
            </dd></dl>
            
            <h4 id="label-find_by_sql"><code>find_by_sql</code></h4>
            
            <p>Similar to <code>count_by_sql</code>, you use <code>with_sql</code>,
            followed by <code>all</code>:</p>
            
            <pre>Album.with_sql(&quot;SELECT * FROM albums WHERE ...&quot;).all</pre>
            
            <h4 id="label-first"><code>first</code></h4>
            
            <p>Just like with <code>find(:first, ...)</code>, you use a method chain
            instead of passing the options, and end it with <code>first</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">artist_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>).<span class="ruby-identifier">order</span>(:<span class="ruby-identifier">name</span>).<span class="ruby-identifier">first</span></pre>
            
            <h4 id="label-last"><code>last</code></h4>
            
            <p>Just like with <code>find(:last, ...)</code>, you use a method chain
            instead of passing the options, make sure it includes an order, and end it
            with <code>last</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">artist_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>).<span class="ruby-identifier">order</span>(:<span class="ruby-identifier">name</span>).<span class="ruby-identifier">last</span></pre>
            
            <h4 id="label-named_scope"><code>named_scope</code></h4>
            
            <p>For a pure filter, you can use <code>subset</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">subset</span>(:<span class="ruby-identifier">debut</span>, :<span class="ruby-identifier">position</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>)&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">subset</span>(:<span class="ruby-identifier">gold</span>){<span class="ruby-identifier">copies_sold</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">500000</span>}</pre>
            
            <p>For anything more complex, you can use <code>dataset_module</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">dataset_module</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">by_artist</span>(<span class="ruby-identifier">artist_id</span>)&#x000A;    <span class="ruby-identifier">where</span>(:<span class="ruby-identifier">artist_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">artist_id</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">by_release_date</span>&#x000A;    <span class="ruby-identifier">order</span>(:<span class="ruby-identifier">release_date</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-reset_column_information"><code>reset_column_information</code></h4>
            
            <p>If you want to completely reload the schema for the table:</p>
            
            <pre>Album.instance_variable_set(:@db_schema, nil)&#x000A;Album.send(:get_db_schema, true)</pre>
            
            <h4 id="label-serialize%2C+seralized_attributes"><code>serialize</code>, <code>seralized_attributes</code></h4>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> ships with a
            <code>serialization</code> plugin that you can use.</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">serialization</span>, :<span class="ruby-identifier">json</span>, :<span class="ruby-identifier">permissions</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>For <code>serialized_attributes</code>, you can use
            <code>serialization_map</code>, which is also a hash, but keys are column
            symbols and values are callable objects used to serialize the values.</p>
            
            <h4 id="label-set_inheritance_column"><code>set_inheritance_column</code></h4>
            
            <p>This is something that must be specified when you are loading the
            <code>single_table_inheritance</code> plugin:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">single_table_inheritance</span>, :<span class="ruby-identifier">column</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-set_sequence_name"><code>set_sequence_name</code></h4>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> will usually auto discover
            the sequence to use.  However, on Oracle this should be specified by making
            sure the model&#39;s dataset includes a sequence:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>(<span class="ruby-constant">ORACLE_DB</span>[:<span class="ruby-identifier">albums</span>].<span class="ruby-identifier">sequence</span>(<span class="ruby-string">&#39;albums_seq&#39;</span>))&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-table_exists%3F"><code>table_exists?</code></h4>
            
            <p>This is a <code>Sequel::Database</code> method:</p>
            
            <pre>Album.db.table_exists?(Album.table_name)</pre>
            
            <p>With the <code>schema</code> plugin, you can use it directly:</p>
            
            <pre>Album.plugin :schema&#x000A;Album.table_exists?</pre>
            
            <h4 id="label-transaction"><code>transaction</code></h4>
            
            <p>As mentioned earlier, <code>transaction</code> is a database method in <a
            href="../../classes/Sequel.html">Sequel</a>, which you can access via the
            <code>db</code> method:</p>
            
            <pre>Album.db.transaction{}</pre>
            
            <h4 id="label-update%2C+update_all"><code>update</code>, <code>update_all</code></h4>
            
            <p>Just like <code>delete</code> and <code>destroy</code>, you filter first,
            then <code>update</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">id</span>).<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&#39;RF&#39;</span>)&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(<span class="ruby-string">&quot;artist_id = ?&quot;</span>, <span class="ruby-value">5</span>).<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">copies_sold=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">0</span>)</pre>
            
            <p>Likewise, to update all rows in the model:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&#39;RF&#39;</span>)</pre>
            
            <p>Note that <code>update</code> in that case will operate on a dataset, so it
            won&#39;t run model validations or hooks.  If you want those run:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>[<span class="ruby-identifier">id</span>].<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&#39;RF&#39;</span>)&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(<span class="ruby-string">&quot;artist_id = ?&quot;</span>, <span class="ruby-value">5</span>).<span class="ruby-identifier">all</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">copies_sold=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">0</span>)}</pre>
            
            <h4 id="label-with_scope"><code>with_scope</code></h4>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> works a little differently
            than with_scope.  Instead of using nested blocks, you just use a cleaner
            method chain.  <code>with_scope</code> is often used as an around_filter or
            similar construct, where in <a href="../../classes/Sequel.html">Sequel</a>,
            you would just need to assign to a dataset in a before filter, and use that
            dataset in the action.</p>
            
            <h3 id="label-Class+Methods+with+Roughly+the+Same+Behavior">Class Methods with Roughly the Same Behavior</h3>
            
            <p>Note that <a href="../../classes/Sequel.html">Sequel</a> uses symbols
            almost everywhere to represent columns, while ActiveRecord often returns
            columns as strings.</p>
            <dl class="rdoc-list note-list"><dt>ActiveRecord Method 
            <dd>
            <p><a href="../../classes/Sequel.html">Sequel</a> Method</p>
            </dd><dt><code>attr_accessible</code> 
            <dd>
            <p><code>set_allowed_columns</code></p>
            </dd><dt><code>attr_protected</code> 
            <dd>
            <p><code>set_restricted_columns</code></p>
            </dd><dt><code>average</code> 
            <dd>
            <p><code>avg</code></p>
            </dd><dt><code>belongs_to</code> 
            <dd>
            <p><code>many_to_one</code></p>
            </dd><dt><code>columns_hash</code> 
            <dd>
            <p><code>db_schema</code></p>
            </dd><dt><code>count</code> 
            <dd>
            <p><code>count</code></p>
            </dd><dt><code>changed</code> 
            <dd>
            <p><code>changed_columns</code></p>
            </dd><dt><code>create</code> 
            <dd>
            <p><code>create</code></p>
            </dd><dt><code>has_and_belongs_to_many</code> 
            <dd>
            <p><code>many_to_many</code></p>
            </dd><dt><code>has_one</code> 
            <dd>
            <p><code>one_to_one</code></p>
            </dd><dt><code>has_many</code> 
            <dd>
            <p><code>one_to_many</code></p>
            </dd><dt><code>inheritance_column</code> 
            <dd>
            <p><code>sti_key</code></p>
            </dd><dt><code>inspect</code> 
            <dd>
            <p><code>inspect</code></p>
            </dd><dt><code>maximum</code> 
            <dd>
            <p><code>max</code></p>
            </dd><dt><code>minimum</code> 
            <dd>
            <p><code>min</code></p>
            </dd><dt><code>new</code> 
            <dd>
            <p><code>new</code></p>
            </dd><dt><code>primary_key</code> 
            <dd>
            <p><code>primary_key</code></p>
            </dd><dt><code>respond_to?</code> 
            <dd>
            <p><code>respond_to?</code></p>
            </dd><dt><code>set_primary_key</code> 
            <dd>
            <p><code>set_primary_key</code></p>
            </dd><dt><code>sum</code> 
            <dd>
            <p><code>sum</code></p>
            </dd><dt><code>table_name</code> 
            <dd>
            <p><code>table_name</code></p>
            </dd><dt><code>unscoped</code> 
            <dd>
            <p><code>unfiltered</code></p>
            </dd></dl>
            
            <h3 id="label-Class+Methods+without+an+Equivalent">Class Methods without an Equivalent</h3>
            <dl class="rdoc-list note-list"><dt>ActiveRecord Method 
            <dd>
            <p>Notes, Workarounds</p>
            </dd><dt><code>accepts_nested_attributes_for</code> 
            <dd>
            <p>Use the <code>nested_attributes</code> plugin</p>
            </dd><dt><code>attr_readonly</code> 
            <dd>
            <p>Don&#39;t update the columns (duh!), or add a before_update hook that
            deletes them from the values hash</p>
            </dd><dt><code>attribute_method_suffix</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>alias_attribute_with_dirty</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>base_class</code> 
            <dd>
            <p>Not needed internally, you can probably use <code>sti_dataset.model</code>
            if you are using single table inheritance</p>
            </dd><dt><code>benchmark</code> 
            <dd>
            <p>Just use the <code>benchmark</code> library from ruby&#39;s stdlib</p>
            </dd><dt><code>calculate</code> 
            <dd>
            <p>No direct equivalent, just build the query manually and execute it</p>
            </dd><dt><code>cache</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>cache_attribute?</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>cache_attributes</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>cached_attributes</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>changed?</code> 
            <dd>
            <p><code>changed_columns.include?(column)</code></p>
            </dd><dt><code>changes</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>clear_active_connections!</code> 
            <dd>
            <p><a href="../../classes/Sequel.html">Sequel</a> doesn&#39;t leak connections
            like ActiveRecord, so you don&#39;t need to worry about this</p>
            </dd><dt><code>clear_reloadable_connections!</code> 
            <dd>
            <p><a href="../../classes/Sequel.html">Sequel</a> doesn&#39;t leak connections
            like ActiveRecord, so you don&#39;t need to worry about this</p>
            </dd><dt><code>content_columns</code> 
            <dd>
            <p>Not needed internally, you can probably do <code>Album.columns.map{|x|&#x000A;x.to_s}.delete_if{|x| x == Album.primary_key || x =~&#x000A;/_(id|count)\z/}</code></p>
            </dd><dt><code>decrement_counter</code> 
            <dd>
            <p><code>Album.where(:id=&gt;:id).update(:counter_name=&gt;Sequel.-(:counter_name,&#x000A;1))</code></p>
            </dd><dt><code>define_attribute_methods</code>, <code>define_read_methods</code> 
            <dd>
            <p><code>def_column_accessor(*columns)</code>, a private method</p>
            </dd><dt><code>descends_from_active_record?</code> 
            <dd>
            <p>Not needed internally, if using single table inheritance,
            <code>Album.sti_dataset.model == Album</code></p>
            </dd><dt><code>find_each</code>, <code>find_in_batches</code> 
            <dd>
            <p>Use the <code>pagination</code> extension</p>
            </dd><dt><code>generated_methods?</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>increment_counter</code> 
            <dd>
            <p><code>Album.where(:id=&gt;:id).update(:counter_name=&gt;Sequel.+(:counter_name,&#x000A;1))</code></p>
            </dd><dt><code>instance_method_already_implemented?</code> 
            <dd>
            <p>No equivalent, <a href="../../classes/Sequel.html">Sequel</a> does not
            create column accessors that override other methods, it just skips them.</p>
            </dd><dt><code>match_attribute_method?</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>readonly_attributes</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>remove_connection</code> 
            <dd>
            <p>Not necessary in <a href="../../classes/Sequel.html">Sequel</a>.  If you
            want to disconnect an existing connection: <code>Album.db.disconnect</code></p>
            </dd><dt><code>require_mysql</code> 
            <dd>
            <p>A public method, really?</p>
            </dd><dt><code>silence</code> 
            <dd>
            <p>No equivalent.  Because the logger is handled at the
            <code>Sequel::Database</code> level, there is no thread-safe way to turn it
            off for specific blocks.</p>
            </dd><dt><code>scopes</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>sti_name</code> 
            <dd>
            <p>No equivalent.</p>
            </dd><dt><code>update_counters</code> 
            <dd>
            <p><code>Album.where(:id=&gt;:id).update(:counter_name=&gt;:counter_name + 1,&#x000A;:other_counter=&gt;:other_counter - 1)</code></p>
            </dd><dt><code>uncached</code> 
            <dd>
            <p>No equivalent</p>
            </dd></dl>
            
            <h3 id="label-Instance+Methods+with+Significantly+Different+Behavior">Instance Methods with Significantly Different Behavior</h3>
            
            <h4 id="label-attribute_names"><code>attribute_names</code></h4>
            
            <p><code>keys</code> returns the columns as unsorted symbols, so:</p>
            
            <pre class="ruby"><span class="ruby-identifier">album</span>.<span class="ruby-identifier">keys</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">to_s</span>}.<span class="ruby-identifier">sort</span></pre>
            
            <h4 id="label-becomes"><code>becomes</code></h4>
            
            <p>Assuming the record already exists in the database:</p>
            
            <pre>gold_album = GoldAlbum[1]&#x000A;album = Album.load(gold_album.values)</pre>
            
            <p>If it is a new record:</p>
            
            <pre class="ruby"><span class="ruby-identifier">gold_album</span> = <span class="ruby-constant">GoldAlbum</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&#39;a&#39;</span>)&#x000A;<span class="ruby-identifier">album</span> = <span class="ruby-constant">Album</span>.<span class="ruby-identifier">new</span>&#x000A;<span class="ruby-identifier">album</span>.<span class="ruby-identifier">send</span>(:<span class="ruby-identifier">set_values</span>, <span class="ruby-identifier">gold_album</span>.<span class="ruby-identifier">values</span>)</pre>
            
            <h4 id="label-column_for_attribute"><code>column_for_attribute</code></h4>
            
            <p>You can access this through the <code>db_schema</code> hash:</p>
            
            <pre>album.db_schema[:column]</pre>
            
            <h4 id="label-connection"><code>connection</code></h4>
            
            <p>Just like in the class method, you have to access it through the database:</p>
            
            <pre class="ruby"><span class="ruby-identifier">album</span>.<span class="ruby-identifier">db</span>.<span class="ruby-identifier">synchronize</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">connection</span><span class="ruby-operator">|</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-decrement%2C+increment"><code>decrement</code>, <code>increment</code></h4>
            
            <p>You can just modify the values hash directly:</p>
            
            <pre>album.values[:column] ||= 0&#x000A;album.values[:column] -= 1 # or += 1 for increment</pre>
            
            <h4 id="label-decrement%21%2C+increment%21"><code>decrement!</code>, <code>increment!</code></h4>
            
            <p>Assuming you want the full behavior of saving just one column without
            validating:</p>
            
            <pre class="ruby"><span class="ruby-identifier">album</span>.<span class="ruby-identifier">values</span>[:<span class="ruby-identifier">column</span>] <span class="ruby-operator">||=</span> <span class="ruby-value">0</span>&#x000A;<span class="ruby-identifier">album</span>.<span class="ruby-identifier">values</span>[:<span class="ruby-identifier">column</span>] <span class="ruby-operator">-=</span> <span class="ruby-value">1</span> <span class="ruby-comment"># or += 1 for increment!</span>&#x000A;<span class="ruby-identifier">album</span>.<span class="ruby-identifier">save</span>(:<span class="ruby-identifier">columns=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">column</span>], :<span class="ruby-identifier">validate=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">false</span>)</pre>
            
            <h4 id="label-has_attribute%3F"><code>has_attribute?</code></h4>
            
            <p>You have to check the values hash:</p>
            
            <pre>album.values.has_key?(:column)</pre>
            
            <h4 id="label-invalid%3F"><code>invalid?</code></h4>
            
            <p>You can use <code>unless valid?</code> or <code>!valid?</code>.</p>
            
            <h4 id="label-save%2C+save%21%2C+save_with_validation%2C+save_with_validation%21"><code>save</code>, <code>save!</code>, <code>save_with_validation</code>, <code>save_with_validation!</code></h4>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> defaults to raising
            exceptions when <code>save</code> fails, but this is configurable behavior
            by setting the <code>raise_on_save_failure</code> flag on the class or
            instance:</p>
            
            <pre>album.raise_on_save_failure = true&#x000A;album.save # raise exception if failure&#x000A;album.raise_on_save_failure = false&#x000A;album.save # return nil if failure</pre>
            
            <p>You can pass the <code>:validate=&gt;false</code> option to not validate
            the object when saving.</p>
            
            <h4 id="label-toggle%2C+toggle"><code>toggle</code>, <code>toggle</code></h4>
            
            <p>No equivalent, but very easy to add:</p>
            
            <pre>album.column = !album.column</pre>
            
            <p>If you want to save just that column:</p>
            
            <pre class="ruby"><span class="ruby-identifier">album</span>.<span class="ruby-identifier">save</span>(:<span class="ruby-identifier">columns=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">column</span>], :<span class="ruby-identifier">validate=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">false</span>)</pre>
            
            <h4 id="label-transaction"><code>transaction</code></h4>
            
            <p>Just like in the class, you can access the transaction method through the
            <code>db</code>:</p>
            
            <pre>album.db.transaction{}</pre>
            
            <h4 id="label-update_attribute"><code>update_attribute</code></h4>
            
            <p>To only set and save a specific column:</p>
            
            <pre class="ruby"><span class="ruby-identifier">album</span>.<span class="ruby-identifier">set</span>(:<span class="ruby-identifier">column</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">value</span>)&#x000A;<span class="ruby-identifier">album</span>.<span class="ruby-identifier">save</span>(:<span class="ruby-identifier">columns=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">column</span>], :<span class="ruby-identifier">validate=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">false</span>)</pre>
            
            <h4 id="label-update_attributes%2C+update_attributes%21"><code>update_attributes</code>, <code>update_attributes!</code></h4>
            
            <p>These would both use <code>update</code>, but see the notes on the
            <code>raise_on_save_failure</code> flag:</p>
            
            <pre class="ruby"><span class="ruby-identifier">album</span>.<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">column1=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">value1</span>, :<span class="ruby-identifier">column2=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">value2</span>)</pre>
            
            <h3 id="label-Instance+Methods+with+Roughly+the+Same+Behavior">Instance Methods with Roughly the Same Behavior</h3>
            
            <p>Note that <a href="../../classes/Sequel.html">Sequel</a> uses symbols
            almost everywhere to represent columns, while ActiveRecord often returns
            columns as strings.</p>
            <dl class="rdoc-list note-list"><dt>ActiveRecord Method 
            <dd>
            <p><a href="../../classes/Sequel.html">Sequel</a> Method</p>
            </dd><dt><code>==</code> 
            <dd>
            <p><code>===</code>, <code>==</code> compares by all values, not just id</p>
            </dd><dt><code>[]</code> 
            <dd>
            <p><code>[]</code></p>
            </dd><dt><code>[]=</code> 
            <dd>
            <p><code>[]=</code></p>
            </dd><dt><code>after_create</code> 
            <dd>
            <p><code>after_create</code></p>
            </dd><dt><code>after_destroy</code> 
            <dd>
            <p><code>after_destroy</code></p>
            </dd><dt><code>after_save</code> 
            <dd>
            <p><code>after_save</code></p>
            </dd><dt><code>after_update</code> 
            <dd>
            <p><code>after_update</code></p>
            </dd><dt><code>after_validation</code> 
            <dd>
            <p><code>after_validation</code></p>
            </dd><dt><code>attributes</code> 
            <dd>
            <p><code>values</code></p>
            </dd><dt><code>attributes=</code> 
            <dd>
            <p><code>set</code></p>
            </dd><dt><code>before_create</code> 
            <dd>
            <p><code>before_create</code></p>
            </dd><dt><code>before_destroy</code> 
            <dd>
            <p><code>before_destroy</code></p>
            </dd><dt><code>before_save</code> 
            <dd>
            <p><code>before_save</code></p>
            </dd><dt><code>before_update</code> 
            <dd>
            <p><code>before_update</code></p>
            </dd><dt><code>before_validation</code> 
            <dd>
            <p><code>before_validation</code></p>
            </dd><dt><code>cache_key</code> 
            <dd>
            <p><code>cache_key</code>, if using the <code>caching</code> plugin</p>
            </dd><dt><code>destroy</code> 
            <dd>
            <p><code>destroy</code></p>
            </dd><dt><code>eql?</code> 
            <dd>
            <p><code>===</code></p>
            </dd><dt><code>errors</code> 
            <dd>
            <p><code>errors</code></p>
            </dd><dt><code>freeze</code> 
            <dd>
            <p><code>freeze</code></p>
            </dd><dt><code>frozen?</code> 
            <dd>
            <p><code>frozen?</code></p>
            </dd><dt><code>hash</code> 
            <dd>
            <p><code>hash</code></p>
            </dd><dt><code>id</code> 
            <dd>
            <p><code>pk</code></p>
            </dd><dt><code>inspect</code> 
            <dd>
            <p><code>inspect</code></p>
            </dd><dt><code>lock!</code> 
            <dd>
            <p><code>lock!</code></p>
            </dd><dt><code>new_record?</code> 
            <dd>
            <p><code>new?</code></p>
            </dd><dt><code>reload_with_autosave_associations</code> 
            <dd>
            <p><code>reload</code></p>
            </dd><dt><code>to_param</code> 
            <dd>
            <p><code>to_param</code>, if using the <code>active_model</code> plugin</p>
            </dd><dt><code>touch</code> 
            <dd>
            <p><code>touch</code>, if using the <code>touch</code> plugin</p>
            </dd><dt><code>valid?</code> 
            <dd>
            <p><code>valid?</code></p>
            </dd></dl>
            
            <h3 id="label-Instance+Methods+without+an+Equivalent">Instance Methods without an Equivalent</h3>
            <dl class="rdoc-list note-list"><dt>ActiveRecord Method 
            <dd>
            <p>Notes, Workarounds</p>
            </dd><dt><code>after_validation_on_create</code>, <code>after_validation_on_update</code> 
            <dd>
            <p>Use <code>after_validation</code> and <code>if new?</code> or <code>unless&#x000A;new?</code></p>
            </dd><dt><code>as_json</code>, <code>from_json</code>, <code>to_json</code> 
            <dd>
            <p>Use the <code>json_serializer</code> plugin</p>
            </dd><dt><code>from_xml</code>, <code>to_xml</code> 
            <dd>
            <p>Use the <code>xml_serializer</code> plugin</p>
            </dd><dt><code>attribute_for_inspect</code> 
            <dd>
            <p><code>album[:column].inspect</code></p>
            </dd><dt><code>attribute_present?</code> 
            <dd>
            <p><code>!album[:column].blank?</code> if using the <code>blank</code>
            extension</p>
            </dd><dt><code>attributes_before_type_cast</code> 
            <dd>
            <p><a href="../../classes/Sequel.html">Sequel</a> typecasts at a low level, so
            model objects never see values before they are type cast</p>
            </dd><dt><code>before_validation_on_create</code>, <code>before_validation_on_update</code> 
            <dd>
            <p>Use <code>before_validation</code> and <code>if new?</code> or <code>unless&#x000A;new?</code></p>
            </dd><dt><code>id=</code> 
            <dd>
            <p><a href="../../classes/Sequel.html">Sequel</a> doesn&#39;t have a special
            primary key setter method, but you can use:
            <code>album.send(&quot;#{Album.primary_key}=&quot;, value)</code></p>
            </dd><dt><code>mark_for_destruction</code>, <code>marked_for_destruction?</code> 
            <dd>
            <p>Use a <code>before_save</code> or <code>after_save</code> hook or the
            <code>instance_hooks</code> plugin</p>
            </dd><dt><code>readonly!</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>readonly?</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>rollback_active_record_state!</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>with_transaction_returning_status</code> 
            <dd>
            <p>No equivalent</p>
            </dd></dl>
          </div>
          <div id='context'>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
