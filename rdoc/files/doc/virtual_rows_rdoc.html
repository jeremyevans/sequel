<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>virtual_rows.rdoc</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='file' id='wrapper'>
      <div class='header'>
        <h1 class='name'>virtual_rows.rdoc</h1>
        <div class='paths'>
          doc/virtual_rows.rdoc
        </div>
        <div class='last-update'>
          Last Update:
          <span class='datetime'>2015-03-24 08:02:02 -0700</span>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <h1 id="label-Virtual+Row+Blocks">Virtual Row Blocks<span><a href="#label-Virtual+Row+Blocks">&para;</a> <a href="#top">&uarr;</a></span></h1>
            
            <p>Dataset methods where, order, and select all take blocks that are referred
            to as virtual row blocks.  Many other dataset methods pass the blocks they
            are given into one of those three methods, so there are actually many <a
            href="../../classes/Sequel/Dataset.html">Sequel::Dataset</a> methods that
            take virtual row blocks.</p>
            
            <h2 id="label-Why+Virtual+Rows">Why Virtual Rows<span><a href="#label-Why+Virtual+Rows">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>Virtual Rows were created to work around the issue that some parts of
            Sequel&#39;s standard DSL could not be used on ruby 1.9.  For example, the
            following <a href="../../classes/Sequel.html">Sequel</a> code historically
            worked on ruby 1.8, but not ruby 1.9:</p>
            
            <pre class="ruby"><span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">a</span> <span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">b</span>[:<span class="ruby-identifier">c</span>])&#x000A;<span class="ruby-comment"># WHERE a &gt; b(c)</span></pre>
            
            <p>This code does not work on ruby 1.9 for two reasons.  First, Symbol#&gt;
            (like other inequality methods) is already defined in ruby 1.9, so <a
            href="../../classes/Sequel.html">Sequel</a> does not override it to return
            an SQL inequality expression.  Second, Symbol#[] is already defined on ruby
            1.9, so <a href="../../classes/Sequel.html">Sequel</a> does not override it
            to return an SQL function expression.</p>
            
            <p>It&#39;s possible to use Sequel&#39;s DSL to represent such expressions,
            but it is a little verbose:</p>
            
            <pre class="ruby"><span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">where</span>(<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">expr</span>(:<span class="ruby-identifier">a</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">function</span>(:<span class="ruby-identifier">b</span>, :<span class="ruby-identifier">c</span>))&#x000A;<span class="ruby-comment"># WHERE a &gt; b(c)</span></pre>
            
            <p>The virtual row DSL makes such code more concise:</p>
            
            <pre class="ruby"><span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">a</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">b</span>(<span class="ruby-identifier">c</span>)}</pre>
            
            <h2 id="label-Regular+Procs+vs+Instance+Evaled+Procs">Regular Procs vs Instance Evaled Procs<span><a href="#label-Regular+Procs+vs+Instance+Evaled+Procs">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>Virtual row blocks behave differently depending on whether the block
            accepts an argument.  If the block accepts an argument, it is called with
            an instance of <a
            href="../../classes/Sequel/SQL/VirtualRow.html">Sequel::SQL::VirtualRow</a>.
            If it does not accept an argument, it is evaluated in the context of an
            instance of <a
            href="../../classes/Sequel/SQL/VirtualRow.html">Sequel::SQL::VirtualRow</a>.</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span> = <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">items</span>]&#x000A;<span class="ruby-comment"># Regular proc</span>&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">column</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>}&#x000A;<span class="ruby-comment"># WHERE column &gt; 1</span>&#x000A;&#x000A;<span class="ruby-comment"># Instance-evaled proc</span>&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">column</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>}&#x000A;<span class="ruby-comment"># WHERE column &gt; 1</span></pre>
            
            <p>If you aren&#39;t familiar with the difference between regular blocks and
            instance evaled blocks, you should probably consult a general ruby
            reference, but briefly, with regular procs, methods called without an
            explicit receiver inside the proc call the method on the receiver in the
            surrounding scope, while instance evaled procs call the method on the
            receiver of the instance_eval call.  However, in both cases, local
            variables available in the surrounding scope will be available inside the
            proc.  If that doesn&#39;t make sense, maybe this example will help:</p>
            
            <pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">a</span>&#x000A;  <span class="ruby-value">42</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-identifier">b</span> = <span class="ruby-value">32</span>&#x000A;&#x000A;<span class="ruby-comment"># Regular proc</span>&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">c</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">b</span>}&#x000A;<span class="ruby-comment"># WHERE c &gt; 10</span>&#x000A;&#x000A;<span class="ruby-comment"># Instance-evaled proc</span>&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">c</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">b</span>}&#x000A;<span class="ruby-comment"># WHERE c &gt; (a - 32)</span></pre>
            
            <p>There are two related differences here.  First is the usage of
            <code>o.c</code> vs <code>c</code>, and second is the difference between
            the use of <code>a</code>.  In the regular proc, you couldn&#39;t call
            <code>c</code> without an explicit receiver in the proc, unless the self of
            the surrounding scope responded to it.  For <code>a</code>, note how ruby
            calls the method on the receiver of the surrounding scope in the regular
            proc, which returns an integer, and does the subtraction before <a
            href="../../classes/Sequel.html">Sequel</a> gets access to it.  In the
            instance evaled proc, calling <code>a</code> without a receiver calls the a
            method on the VirtualRow instance. For <code>b</code>, note that it
            operates the same in both cases, as it is a local variable.</p>
            
            <p>Basically, the choice for whether to use a regular proc or an instance
            evaled proc is completely up to you.  The same things can be accomplished
            with both. Instance evaled procs tend to produce shorter code, but by
            modifying the scope can be more difficult for a new user to understand. 
            That being said, I usually use instance evaled procs unless I need to call
            methods on the receiver of the surrounding scope inside the proc.</p>
            
            <h2 id="label-Local+Variables+vs+Method+Calls">Local Variables vs Method Calls<span><a href="#label-Local+Variables+vs+Method+Calls">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>If you have a method that accepts 0 arguments and has the same name as a
            local variable, you can call it with () to differentiate the method call
            from the local variable access.  This is mostly useful in instance_evaled
            procs:</p>
            
            <pre class="ruby"><span class="ruby-identifier">b</span> = <span class="ruby-value">32</span>&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">b</span>() <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">b</span>}&#x000A;<span class="ruby-comment"># WHERE b &gt; 32</span></pre>
            
            <h2 id="label-VirtualRow+Methods">VirtualRow Methods<span><a href="#label-VirtualRow+Methods">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>VirtualRow is a class that returns SQL::Identifiers,
            SQL::QualifiedIdentifiers, or SQL::Functions depending on how it is called.</p>
            
            <h2 id="label-SQL-3A-3AIdentifiers+-+Regular+columns">SQL::Identifiers - Regular columns<span><a href="#label-SQL-3A-3AIdentifiers+-+Regular+columns">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>SQL::Identifiers can be thought of as regular column references in SQL, not
            qualified by any table. You get an SQL::Identifier if the method is called
            without a block or arguments, and doesn&#39;t have a double underscore in
            the method name:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">column</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">column</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>}&#x000A;<span class="ruby-comment"># WHERE column &gt; 1</span></pre>
            
            <h2 id="label-SQL-3A-3AQualifiedIdentifiers+-+Qualified+columns">SQL::QualifiedIdentifiers - Qualified columns<span><a href="#label-SQL-3A-3AQualifiedIdentifiers+-+Qualified+columns">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>SQL::QualifiedIdentifiers can be thought of as column references in SQL
            that are qualified to a specific table.  You get an
            SQL::QualifiedIdentifier if the method is called without a block or
            arguments, and has a double underscore in the method name:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">table__column</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">table__column</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>}&#x000A;<span class="ruby-comment"># WHERE table.column &gt; 1</span></pre>
            
            <p>Using the double underscore for SQL::QualifiedIdentifiers was done to make
            usage very similar to using symbols, which also translate the double
            underscore into a qualified column.</p>
            
            <h2 id="label-SQL-3A-3AFunctions+-+SQL+function+calls">SQL::Functions - SQL function calls<span><a href="#label-SQL-3A-3AFunctions+-+SQL+function+calls">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>SQL::Functions can be thought of as function calls in SQL.  You get a
            simple function call if you call a method with arguments and without a
            block:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">function</span>(<span class="ruby-value">1</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">function</span>(<span class="ruby-value">1</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>}&#x000A;<span class="ruby-comment"># WHERE function(1) &gt; 1</span></pre>
            
            <p>To call a SQL function with multiple arguments, just use those arguments in
            your function call:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">function</span>(<span class="ruby-value">1</span>, <span class="ruby-identifier">o</span>.<span class="ruby-identifier">a</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">function</span>(<span class="ruby-value">1</span>, <span class="ruby-identifier">a</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>}&#x000A;<span class="ruby-comment"># WHERE function(1, a) &gt; 1</span></pre>
            
            <p>If the SQL function does not accept any arguments, create an identifier,
            then call the function method on it to produce a function:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">version</span>.<span class="ruby-identifier">function</span>}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-identifier">version</span>.<span class="ruby-identifier">function</span>}&#x000A;<span class="ruby-comment"># SELECT version()</span></pre>
            
            <p>To use the SQL wildcard (*) as the sole argument in a function call, create
            a function without arguments, then call the * method on the function:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">count</span>.<span class="ruby-identifier">function</span>.<span class="ruby-operator">*</span>}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-identifier">count</span>.<span class="ruby-identifier">function</span>.<span class="ruby-operator">*</span>}&#x000A;<span class="ruby-comment"># SELECT count(*)</span></pre>
            
            <p>To append the DISTINCT keyword before the method arguments, just call the
            distinct method on the returned Function:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">count</span>(<span class="ruby-identifier">o</span>.<span class="ruby-identifier">col1</span>).<span class="ruby-identifier">distinct</span>}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-identifier">count</span>(<span class="ruby-identifier">col1</span>).<span class="ruby-identifier">distinct</span>}&#x000A;<span class="ruby-comment"># SELECT count(DISTINCT col1)</span>&#x000A;&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">count</span>(<span class="ruby-identifier">o</span>.<span class="ruby-identifier">col1</span>, <span class="ruby-identifier">o</span>.<span class="ruby-identifier">col2</span>).<span class="ruby-identifier">distinct</span>}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-identifier">count</span>(<span class="ruby-identifier">col1</span>, <span class="ruby-identifier">col2</span>).<span class="ruby-identifier">distinct</span>}&#x000A;<span class="ruby-comment"># SELECT count(DISTINCT col1, col2)</span></pre>
            
            <h2 id="label-SQL-3A-3AFunctions+with+windows+-+SQL+window+function+calls">SQL::Functions with windows - SQL window function calls<span><a href="#label-SQL-3A-3AFunctions+with+windows+-+SQL+window+function+calls">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>Not all databases support window functions, but they are very helpful for
            certain types of queries.  To use them, you should just call the over
            method on the Function object returned, with the options for the window:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">rank</span>.<span class="ruby-identifier">function</span>.<span class="ruby-identifier">over</span>}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-identifier">rank</span>.<span class="ruby-identifier">function</span>.<span class="ruby-identifier">over</span>}&#x000A;<span class="ruby-comment"># SELECT rank() OVER ()</span>&#x000A;&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">count</span>.<span class="ruby-identifier">function</span>.<span class="ruby-operator">*</span>.<span class="ruby-identifier">over</span>}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-identifier">count</span>.<span class="ruby-identifier">function</span>.<span class="ruby-operator">*</span>.<span class="ruby-identifier">over</span>}&#x000A;<span class="ruby-comment"># SELECT count(*) OVER ()</span>&#x000A;&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">sum</span>(<span class="ruby-identifier">o</span>.<span class="ruby-identifier">col1</span>).<span class="ruby-identifier">over</span>(:<span class="ruby-identifier">partition=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">o</span>.<span class="ruby-identifier">col2</span>, :<span class="ruby-identifier">order=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">o</span>.<span class="ruby-identifier">col3</span>)}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-identifier">sum</span>(<span class="ruby-identifier">col1</span>).<span class="ruby-identifier">over</span>(:<span class="ruby-identifier">partition=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">col2</span>, :<span class="ruby-identifier">order=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">col3</span>)}&#x000A;<span class="ruby-comment"># SELECT sum(col1) OVER (PARTITION BY col2 ORDER BY col3)</span></pre>
            
            <h2 id="label-Operators">Operators<span><a href="#label-Operators">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>VirtualRows use method_missing to handle almost all method calls.  Since
            the objects given by method_missing are SQL::Identifiers,
            SQL::QualifiedIdentifiers or SQL::Functions, you can use all operators that
            they provide (see <a
            href="http://sequel.jeremyevans.net/rdoc/files/doc/dataset_filtering_rdoc.html#label-Filtering+using+expressions">DatasetFiltering</a>):</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">price</span> <span class="ruby-operator">-</span> <span class="ruby-value">100</span>}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-identifier">o</span>.<span class="ruby-identifier">price</span> <span class="ruby-operator">-</span> <span class="ruby-value">100</span>}&#x000A;<span class="ruby-comment"># SELECT (price - 100)</span>&#x000A;&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> (<span class="ruby-identifier">o</span>.<span class="ruby-identifier">price</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">200</span>) <span class="ruby-operator">&amp;</span> (<span class="ruby-identifier">o</span>.<span class="ruby-identifier">tax</span> <span class="ruby-operator">*</span> <span class="ruby-value">100</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">23</span>)}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{(<span class="ruby-identifier">price</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">200</span>) <span class="ruby-operator">&amp;</span> (<span class="ruby-identifier">tax</span> <span class="ruby-operator">*</span> <span class="ruby-value">100</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0.23</span>)}&#x000A;<span class="ruby-comment"># WHERE ((price &lt; 200) AND ((tax * 100) &gt;= 0.23))</span></pre>
            
            <p>However, VirtualRows have special handling of some operator methods to make
            certain things easier.  The operators all use a prefix form.</p>
            
            <h3 id="label-Math+Operators">Math Operators<span><a href="#label-Math+Operators">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>The standard +, -, *, and / mathematical operators are defined:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-operator">-</span>(<span class="ruby-value">1</span>, <span class="ruby-identifier">o</span>.<span class="ruby-identifier">a</span>).<span class="ruby-identifier">as</span>(<span class="ruby-identifier">b</span>)}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-keyword">self</span>.<span class="ruby-operator">-</span>(<span class="ruby-value">1</span>, <span class="ruby-identifier">a</span>).<span class="ruby-identifier">as</span>(<span class="ruby-identifier">b</span>)}&#x000A;<span class="ruby-comment"># SELECT (1 - a) AS b</span></pre>
            
            <h3 id="label-Boolean+Operators">Boolean Operators<span><a href="#label-Boolean+Operators">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>The &amp; and | methods are defined to use AND and OR:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-operator">&amp;</span>({:<span class="ruby-identifier">a=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">b</span>}, :<span class="ruby-identifier">c</span>)}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-keyword">self</span>.<span class="ruby-operator">&amp;</span>({:<span class="ruby-identifier">a=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">b</span>}, :<span class="ruby-identifier">c</span>)}&#x000A;<span class="ruby-comment"># WHERE ((a = b) AND c)</span></pre>
            
            <p>The ~ method is defined to do inversion:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-operator">~</span>({:<span class="ruby-identifier">a=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>, :<span class="ruby-identifier">b=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">2</span>})}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-keyword">self</span>.<span class="ruby-operator">~</span>({:<span class="ruby-identifier">a=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>, :<span class="ruby-identifier">b=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">2</span>})}&#x000A;<span class="ruby-comment"># WHERE ((a != 1) OR (b != 2))</span></pre>
            
            <h3 id="label-Inequality+Operators">Inequality Operators<span><a href="#label-Inequality+Operators">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>The standard &gt;, &lt;, &gt;=, and &lt;= inequality operators are defined:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-operator">&gt;</span>(<span class="ruby-value">1</span>, :<span class="ruby-identifier">c</span>)}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-keyword">self</span>.<span class="ruby-operator">&gt;</span>(<span class="ruby-value">1</span>, :<span class="ruby-identifier">c</span>)}&#x000A;<span class="ruby-comment"># WHERE (1 &gt; c)</span></pre>
            
            <h2 id="label-Literal+Strings">Literal Strings<span><a href="#label-Literal+Strings">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>The backtick operator can be used inside an instance-evaled virtual row
            block to create a literal string:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">a</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">%x`some SQL`</span>}&#x000A;<span class="ruby-comment"># WHERE (a &gt; some SQL)</span></pre>
            
            <p>You can use this on a regular virtual row block too, but it doesn&#39;t
            look as nice:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-operator">&gt;</span>(:<span class="ruby-identifier">a</span>, <span class="ruby-identifier">o</span>.<span class="ruby-value">%x`(&#39;some SQL&#39;))}&#x000A;</span></pre>
            
            <h2 id="label-Returning+multiple+values">Returning multiple values<span><a href="#label-Returning+multiple+values">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>It&#39;s common when using select and order virtual row blocks to want to
            return multiple values.  If you want to do that, you just need to return an
            array:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">o</span>.<span class="ruby-identifier">column1</span>, <span class="ruby-identifier">o</span>.<span class="ruby-identifier">sum</span>(<span class="ruby-identifier">o</span>.<span class="ruby-identifier">column2</span>).<span class="ruby-identifier">as</span>(<span class="ruby-identifier">o</span>.<span class="ruby-identifier">sum</span>)]}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{[<span class="ruby-identifier">column1</span>, <span class="ruby-identifier">sum</span>(<span class="ruby-identifier">column2</span>).<span class="ruby-identifier">as</span>(<span class="ruby-identifier">sum</span>)]}&#x000A;<span class="ruby-comment"># SELECT column1, sum(column2) AS sum</span></pre>
            
            <p>Note that if you forget the array brackets, you&#39;ll end up with a syntax
            error:</p>
            
            <pre># Invalid ruby syntax&#x000A;ds.select{|o| o.column1, o.sum(o.column2).as(o.sum)}&#x000A;ds.select{column1, sum(column2).as(sum)}</pre>
            
            <h2 id="label-Alternative+Description+of+the+VirtualRow+method+call+rules">Alternative Description of the VirtualRow method call rules<span><a href="#label-Alternative+Description+of+the+VirtualRow+method+call+rules">&para;</a> <a href="#top">&uarr;</a></span></h2>
            <ul><li>
            <p>If a block is given:</p>
            <ul><li>
            <p>The block is currently not called.  This may change in a future version.</p>
            </li><li>
            <p>If there are no arguments, an SQL::Function with the name of method used,
            and no arguments.</p>
            </li><li>
            <p>If the first argument is :*, an SQL::Function is created with a single
            wildcard argument (*).</p>
            </li><li>
            <p>If the first argument is :distinct, an SQL::Function is created with the
            keyword DISTINCT prefacing all remaining arguments.</p>
            </li><li>
            <p>If the first argument is :over, the second argument if provided should be a
            hash of options to pass to SQL::Window.  The options hash can also contain
            :*=&gt;true to use a wildcard argument as the function argument, or
            :args=&gt;â€¦ to specify an array of arguments to use as the function
            arguments.</p>
            </li></ul>
            </li><li>
            <p>If a block is not given:</p>
            <ul><li>
            <p>If there are arguments, an SQL::Function is returned with the name of the
            method used and the arguments given.</p>
            </li><li>
            <p>If there are no arguments and the method contains a double underscore,
            split on the double underscore and return an SQL::QualifiedIdentifier with
            the table and column.</p>
            </li><li>
            <p>Otherwise, create an SQL::Identifier with the name of the method.</p>
            </li></ul>
            </li></ul>
          </div>
          <div id='context'>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
