<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>postgresql.rdoc</title>
    <meta content='text/html; charset=US-ASCII' http-equiv='Content-Type'>
    <link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='file' id='wrapper'>
      <div class='header'>
        <h1 class='name'>postgresql.rdoc</h1>
        <div class='paths'>
          doc/postgresql.rdoc
        </div>
        <div class='last-update'>
          Last Update:
          <span class='datetime'>2014-03-05 09:51:37 -0800</span>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <h1 id="label-PostgreSQL-specific+Support+in+Sequel">PostgreSQL-specific Support in <a href="../../classes/Sequel.html">Sequel</a></h1>
            
            <p>Sequel&#39;s core database and dataset functions are designed to support
            the features shared by most common SQL database implementations.  However,
            Sequel&#39;s database adapters extend the core support to include support
            for database-specific features.</p>
            
            <p>By far the most extensive database-specific support in <a
            href="../../classes/Sequel.html">Sequel</a> is for PostgreSQL. This support
            is roughly broken into the following areas:</p>
            <ul><li>
            <p>Database Types</p>
            </li><li>
            <p>DDL Support</p>
            </li><li>
            <p>DML Support</p>
            </li><li>
            <p>sequel_pg</p>
            </li></ul>
            
            <p>Note that while this guide is extensive, it is not exhaustive.  There are
            additional rarely used PostgreSQL features that <a
            href="../../classes/Sequel.html">Sequel</a> supports which are not
            mentioned here.</p>
            
            <h2 id="label-Adapter%2FDriver+Specific+Support">Adapter/Driver Specific Support</h2>
            
            <p>Some of this this support depends on the specific adapter or underlying
            driver in use.</p>
            
            <p><code>postgres only</code> will denote support specific to the postgres
            adapter (i.e. not available when connecting to PostgreSQL via the jdbc, do,
            or swift adapters). <code>postgres/pg only</code> will denote support
            specific to the postgres adapter when pg is used as the underlying driver
            (i.e. not available when using the postgres-pr or postgres drivers).</p>
            
            <h2 id="label-PostgreSQL-specific+Database+Type+Support">PostgreSQL-specific Database Type Support</h2>
            
            <p>Sequel&#39;s default support on PostgreSQL only includes common database
            types.  However, <a href="../../classes/Sequel.html">Sequel</a> ships with
            support for many PostgreSQL-specific types via extensions.  In general, you
            load these extensions via <code>Database#extension</code>.  For example, to
            load support for arrays, you would do:</p>
            
            <pre>DB.extension :pg_array</pre>
            
            <p>The following PostgreSQL-specific type extensions are available:</p>
            <dl class="rdoc-list note-list"><dt>pg_array 
            <dd>
            <p>arrays (single and multidimensional, for any scalar type), as a ruby
            Array-like object</p>
            </dd><dt>pg_hstore 
            <dd>
            <p>hstore, as a ruby Hash-like object</p>
            </dd><dt>pg_inet 
            <dd>
            <p>inet/cidr, as ruby IPAddr objects</p>
            </dd><dt>pg_interval 
            <dd>
            <p>interval, as ActiveSupport::Duration objects</p>
            </dd><dt>pg_json 
            <dd>
            <p>json, as either ruby Array-like or Hash-like objects</p>
            </dd><dt>pg_range 
            <dd>
            <p>ranges (for any scalar type), as a ruby Range-like object</p>
            </dd><dt>pg_row 
            <dd>
            <p>row-valued/composite types, as a ruby Hash-like or <a
            href="../../classes/Sequel/Model.html">Sequel::Model</a> object</p>
            </dd></dl>
            
            <p>In general, these extensions just add support for Database objects to
            return retrieved column values as the appropriate type (<code>postgres and&#x000A;jdbc/postgres only</code>), and support for literalizing the objects
            correctly for use in an SQL string, or using them as bound variable values
            (<code>postgres/pg and jdbc/postgres only</code>).</p>
            
            <p>There are also type-specific extensions that make it easy to use database
            functions and operators related to the type.  These extensions are:</p>
            <dl class="rdoc-list note-list"><dt>pg_array_ops 
            <dd>
            <p>array-related functions and operators</p>
            </dd><dt>pg_hstore_ops 
            <dd>
            <p>hstore-related functions and operators</p>
            </dd><dt>pg_json_ops 
            <dd>
            <p>json-related functions and operators</p>
            </dd><dt>pg_range_ops 
            <dd>
            <p>range-related functions and operators</p>
            </dd><dt>pg_row_ops 
            <dd>
            <p>row-valued/composite type syntax support</p>
            </dd></dl>
            
            <h2 id="label-PostgreSQL-specific+DDL+Support">PostgreSQL-specific DDL Support</h2>
            
            <h3 id="label-Exclusion+Constraints">Exclusion Constraints</h3>
            
            <p>In <code>create_table</code> blocks, you can use the <code>exclude</code>
            method to set up exclusion constraints:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">table</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">daterange</span> :<span class="ruby-identifier">during</span>&#x000A;  <span class="ruby-identifier">exclude</span>([[:<span class="ruby-identifier">during</span>, <span class="ruby-string">&#39;&amp;&amp;&#39;</span>]], :<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">table_during_excl</span>)&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-comment"># CREATE TABLE &quot;table&quot; (&quot;during&quot; daterange,</span>&#x000A;<span class="ruby-comment">#   CONSTRAINT &quot;table_during_excl&quot; EXCLUDE USING gist (&quot;during&quot; WITH &amp;&amp;))</span></pre>
            
            <p>You can also add exclusion constraints in <code>alter_table</code> blocks
            using add_exclusion_constraint:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">alter_table</span>(:<span class="ruby-identifier">table</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">add_exclusion_constraint</span>([[:<span class="ruby-identifier">during</span>, <span class="ruby-string">&#39;&amp;&amp;&#39;</span>]], :<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">table_during_excl</span>)&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-comment"># ALTER TABLE &quot;table&quot; ADD CONSTRAINT &quot;table_during_excl&quot; EXCLUDE USING gist (&quot;during&quot; WITH &amp;&amp;)</span></pre>
            
            <h3 id="label-Adding+Foreign+Key+and+Check+Constraints+Without+Initial+Validation">Adding Foreign Key and Check Constraints Without Initial Validation</h3>
            
            <p>You can add a <code>:not_valid=&gt;true</code> option when adding
            constraints to existing tables so that it doesn&#39;t check if all current
            rows are valid:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">alter_table</span>(:<span class="ruby-identifier">table</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-comment"># Assumes t_id column already exists</span>&#x000A;  <span class="ruby-identifier">add_foreign_key</span>([:<span class="ruby-identifier">t_id</span>], :<span class="ruby-identifier">table</span>, :<span class="ruby-identifier">not_valid=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>, :<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">table_fk</span>)&#x000A;&#x000A;  <span class="ruby-identifier">constraint</span>({:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">col_123</span>, :<span class="ruby-identifier">not_valid=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>}, :<span class="ruby-identifier">col=</span><span class="ruby-operator">&gt;</span>[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>])&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-comment"># ALTER TABLE &quot;table&quot; ADD CONSTRAINT &quot;table_fk&quot; FOREIGN KEY (&quot;t_id&quot;) REFERENCES &quot;table&quot; NOT VALID</span>&#x000A;<span class="ruby-comment"># ALTER TABLE &quot;table&quot; ADD CONSTRAINT &quot;col_123&quot; CHECK (col IN (1, 2, 3)) NOT VALID</span></pre>
            
            <p>Such constraints will be enforced for newly inserted and updated rows, but
            not for existing rows. After all existing rows have been fixed, you can
            validate the constraint:</p>
            
            <pre>DB.alter_table(:table) do&#x000A;  validate_constraint(:table_fk)&#x000A;  validate_constraint(:col_123)&#x000A;end&#x000A;# ALTER TABLE &quot;table&quot; VALIDATE CONSTRAINT &quot;table_fk&quot;&#x000A;# ALTER TABLE &quot;table&quot; VALIDATE CONSTRAINT &quot;col_123&quot;</pre>
            
            <h3 id="label-Creating+Indexes+Concurrently">Creating Indexes Concurrently</h3>
            
            <p>You can create indexes concurrently using the
            <code>:concurrently=&gt;true</code> option:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">add_index</span>(:<span class="ruby-identifier">table</span>, :<span class="ruby-identifier">t_id</span>, :<span class="ruby-identifier">concurrently=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>)&#x000A;<span class="ruby-comment"># CREATE INDEX CONCURRENTLY &quot;table_t_id_index&quot; ON &quot;table&quot; (&quot;t_id&quot;)</span></pre>
            
            <p>Similarly, you can drop indexes concurrently as well:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">drop_index</span>(:<span class="ruby-identifier">table</span>, :<span class="ruby-identifier">t_id</span>, :<span class="ruby-identifier">concurrently=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>)&#x000A;<span class="ruby-comment"># DROP INDEX CONCURRENTLY &quot;table_t_id_index&quot;</span></pre>
            
            <h3 id="label-Specific+Conversions+When+Altering+Column+Types">Specific Conversions When Altering Column Types</h3>
            
            <p>When altering a column type, PostgreSQL allows the user to specify how to
            do the conversion via a USING clause, and <a
            href="../../classes/Sequel.html">Sequel</a> supports this using the
            <code>:using</code> option:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">alter_table</span>(:<span class="ruby-identifier">table</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-comment"># Assume unix_time column is stored as an integer, and you want to change it to timestamp</span>&#x000A;  <span class="ruby-identifier">set_column_type</span> :<span class="ruby-identifier">unix_time</span>, <span class="ruby-constant">Time</span>, :<span class="ruby-identifier">using=</span><span class="ruby-operator">&gt;</span>(<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-string">&#39;epoch&#39;</span>, <span class="ruby-constant">Time</span>) <span class="ruby-operator">+</span> <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-string">&#39;1 second&#39;</span>, :<span class="ruby-identifier">interval</span>) * :<span class="ruby-identifier">unix_time</span>)&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-comment"># ALTER TABLE &quot;table&quot; ALTER COLUMN &quot;unix_time&quot; TYPE timestamp</span>&#x000A;<span class="ruby-comment">#   USING (CAST(&#39;epoch&#39; AS timestamp) + (CAST(&#39;1 second&#39; AS interval) * &quot;unix_time&quot;))</span></pre>
            
            <h3 id="label-Creating+Unlogged+Tables">Creating Unlogged Tables</h3>
            
            <p>PostgreSQL allows users to create unlogged tables, which are faster but not
            crash safe.  <a href="../../classes/Sequel.html">Sequel</a> allows you do
            create an unlogged table by specifying the <code>:unlogged=&gt;true</code>
            option to <code>create_table</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">table</span>, :<span class="ruby-identifier">unlogged=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>){<span class="ruby-constant">Integer</span> :<span class="ruby-identifier">i</span>}&#x000A;<span class="ruby-comment"># CREATE UNLOGGED TABLE &quot;table&quot; (&quot;i&quot; integer)</span></pre>
            
            <h3 id="label-Creating%2FDropping+Schemas%2C+Languages%2C+Functions%2C+and+Triggers">Creating/Dropping Schemas, Languages, Functions, and Triggers</h3>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> has built in support for
            creating and dropping PostgreSQL schemas, procedural languages, functions,
            and triggers:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_schema</span>(:<span class="ruby-identifier">s</span>)&#x000A;<span class="ruby-comment"># CREATE SCHEMA &quot;s&quot;</span>&#x000A;<span class="ruby-constant">DB</span>.<span class="ruby-identifier">drop_schema</span>(:<span class="ruby-identifier">s</span>)&#x000A;<span class="ruby-comment"># DROP SCHEMA &quot;s&quot;</span>&#x000A;&#x000A;<span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_language</span>(:<span class="ruby-identifier">plperl</span>)&#x000A;<span class="ruby-comment"># CREATE LANGUAGE plperl</span>&#x000A;<span class="ruby-constant">DB</span>.<span class="ruby-identifier">drop_language</span>(:<span class="ruby-identifier">plperl</span>)&#x000A;<span class="ruby-comment"># DROP LANGUAGE plperl</span>&#x000A;&#x000A;<span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_function</span>(:<span class="ruby-identifier">set_updated_at</span>, <span class="ruby-string">&quot;  BEGIN&#x000A;    NEW.updated_at := CURRENT_TIMESTAMP;&#x000A;    RETURN NEW;&#x000A;  END;&#x000A;&quot;</span>, :<span class="ruby-identifier">language=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">plpgsql</span>, :<span class="ruby-identifier">returns=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">trigger</span>)&#x000A;<span class="ruby-comment"># CREATE FUNCTION set_updated_at() RETURNS trigger LANGUAGE plpgsql AS &#39;</span>&#x000A;<span class="ruby-comment">#  BEGIN</span>&#x000A;<span class="ruby-comment">#    NEW.updated_at := CURRENT_TIMESTAMP;</span>&#x000A;<span class="ruby-comment">#    RETURN NEW;</span>&#x000A;<span class="ruby-comment">#  END;&#39;</span>&#x000A;<span class="ruby-constant">DB</span>.<span class="ruby-identifier">drop_function</span>(:<span class="ruby-identifier">set_updated_at</span>)&#x000A;<span class="ruby-comment"># DROP FUNCTION set_updated_at()</span>&#x000A;&#x000A;<span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_trigger</span>(:<span class="ruby-identifier">table</span>, :<span class="ruby-identifier">trg_updated_at</span>, :<span class="ruby-identifier">set_updated_at</span>, :<span class="ruby-identifier">events=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">insert</span>, :<span class="ruby-identifier">update</span>], :<span class="ruby-identifier">each_row=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>)&#x000A;<span class="ruby-comment"># CREATE TRIGGER trg_updated_at BEFORE INSERT OR UPDATE ON &quot;table&quot; FOR EACH ROW EXECUTE PROCEDURE set_updated_at()</span>&#x000A;<span class="ruby-constant">DB</span>.<span class="ruby-identifier">drop_trigger</span>(:<span class="ruby-identifier">table</span>, :<span class="ruby-identifier">trg_updated_at</span>)&#x000A;<span class="ruby-comment"># DROP TRIGGER trg_updated_at ON &quot;table&quot;</span></pre>
            
            <h2 id="label-PostgreSQL-specific+DML+Support">PostgreSQL-specific DML Support</h2>
            
            <h3 id="label-Returning+Rows+From+Insert%2C+Update%2C+and+Delete+Statements">Returning Rows From Insert, Update, and Delete Statements</h3>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> supports the ability to
            return rows from insert, update, and delete statements, via
            <code>Dataset#returning</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">returning</span>.<span class="ruby-identifier">insert</span>&#x000A;<span class="ruby-comment"># INSERT INTO &quot;table&quot; DEFAULT VALUES RETURNING *</span>&#x000A;&#x000A;<span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">returning</span>(:<span class="ruby-identifier">id</span>).<span class="ruby-identifier">delete</span>&#x000A;<span class="ruby-comment"># DELETE FROM &quot;table&quot; RETURNING &quot;id&quot;</span>&#x000A;&#x000A;<span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">returning</span>(:<span class="ruby-identifier">id</span>, <span class="ruby-constant">Sequel</span>.*(:<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">id</span>).<span class="ruby-identifier">as</span>(:<span class="ruby-identifier">idsq</span>)).<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">2</span>)&#x000A;<span class="ruby-comment"># UPDATE &quot;table&quot; SET &quot;id&quot; = 2 RETURNING &quot;id&quot;, (&quot;id&quot; * &quot;id&quot;) AS &quot;idsq&quot;</span></pre>
            
            <p>When returning is used, instead of returning the number of rows affected
            (for updated/delete) or the serial primary key value (for insert), it will
            return an array of hashes with the returned results.</p>
            
            <h3 id="label-Distinct+On+Specific+Columns">Distinct On Specific Columns</h3>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> allows passing columns to
            <code>Dataset#distinct</code>, which will make the dataset return rows that
            are distinct on just those columns:</p>
            
            <pre>DB[:table].distinct(:id).all&#x000A;# SELECT DISTINCT ON (&quot;id&quot;) * FROM &quot;table&quot;</pre>
            
            <h3 id="label-Using+a+Cursor+to+Process+Large+Datasets+postgres+only">Using a Cursor to Process Large Datasets <code>postgres only</code></h3>
            
            <p>The postgres adapter offers a <code>Dataset#use_cursor</code> method to
            process large result sets without keeping all rows in memory:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">use_cursor</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">row</span><span class="ruby-operator">|</span> }&#x000A;<span class="ruby-comment"># BEGIN;</span>&#x000A;<span class="ruby-comment"># DECLARE sequel_cursor NO SCROLL CURSOR WITHOUT HOLD FOR SELECT * FROM &quot;table&quot;;</span>&#x000A;<span class="ruby-comment"># FETCH FORWARD 1000 FROM sequel_cursor</span>&#x000A;<span class="ruby-comment"># FETCH FORWARD 1000 FROM sequel_cursor</span>&#x000A;<span class="ruby-comment"># ...</span>&#x000A;<span class="ruby-comment"># FETCH FORWARD 1000 FROM sequel_cursor</span>&#x000A;<span class="ruby-comment"># CLOSE sequel_cursor</span>&#x000A;<span class="ruby-comment"># COMMIT</span></pre>
            
            <p>This support is used by default when using <code>Dataset#paged_each</code>.</p>
            
            <p>Using cursors, it is possible to update individual rows of a large dataset
            easily using the <code>:rows_per_fetch=&gt;1</code> option in conjunction
            with <code>Dataset#where_current_of</code>.  This is useful if the logic
            needed to update the rows exists in the application and not in the
            database:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">use_cursor</span>(:<span class="ruby-identifier">rows_per_fetch=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">row</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where_current_of</span>.<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">col=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">new_col_value</span>(<span class="ruby-identifier">row</span>))&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-Truncate+Modifiers">Truncate Modifiers</h3>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> supports PostgreSQL-specific
            truncate options:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">truncate</span>(:<span class="ruby-identifier">cascade</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>, :<span class="ruby-identifier">only=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>, :<span class="ruby-identifier">restart=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>)&#x000A;<span class="ruby-comment"># TRUNCATE TABLE ONLY &quot;table&quot; RESTART IDENTITY CASCADE</span></pre>
            
            <h3 id="label-COPY+Support+postgres%2Fpg+and+jdbc%2Fpostgres+only+">COPY Support <code>postgres/pg and jdbc/postgres only</code> </h3>
            
            <p>PostgreSQL&#39;s COPY feature is pretty much the fastest way to get data in
            or out of the database. <a href="../../classes/Sequel.html">Sequel</a>
            supports getting data out of the database via
            <code>Database#copy_table</code>, either for a specific table or for an
            arbitrary dataset:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">copy_table</span>(:<span class="ruby-identifier">table</span>, :<span class="ruby-identifier">format=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">csv</span>)&#x000A;<span class="ruby-comment"># COPY &quot;table&quot; TO STDOUT (FORMAT csv)</span>&#x000A;<span class="ruby-constant">DB</span>.<span class="ruby-identifier">copy_table</span>(<span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>], :<span class="ruby-identifier">format=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">csv</span>)&#x000A;<span class="ruby-comment"># COPY (SELECT * FROM &quot;table&quot;) TO STDOUT (FORMAT csv)</span></pre>
            
            <p>It supports putting data into the database via
            <code>Database#copy_into</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">copy_into</span>(:<span class="ruby-identifier">table</span>, :<span class="ruby-identifier">format=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">csv</span>, :<span class="ruby-identifier">columns=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">column1</span>, :<span class="ruby-identifier">column2</span>], :<span class="ruby-identifier">data=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&quot;1,2\n2,3\n&quot;</span>)&#x000A;<span class="ruby-comment"># COPY &quot;table&quot;(&quot;column1&quot;, &quot;column2&quot;) FROM STDIN (FORMAT csv)</span></pre>
            
            <h3 id="label-Anonymous+Function+Execution">Anonymous Function Execution</h3>
            
            <p>You can execute anonymous functions using a database procedural language
            via <code>Database#do</code> (the plpgsql language is the default):</p>
            
            <pre>DB.do &lt;&lt;-SQL&#x000A;  DECLARE r record;&#x000A;  BEGIN&#x000A;   FOR r IN SELECT table_schema, table_name FROM information_schema.tables&#x000A;     WHERE table_type = &#39;VIEW&#39; AND table_schema = &#39;public&#39;&#x000A;   LOOP&#x000A;     EXECUTE &#39;GRANT ALL ON &#39; || quote_ident(r.table_schema) || &#39;.&#39; || quote_ident(r.table_name) || &#39; TO webuser&#39;;&#x000A;   END LOOP;&#x000A;  END;&#x000A;SQL</pre>
            
            <h3 id="label-Listening+On+and+Notifying+Channels">Listening On and Notifying Channels</h3>
            
            <p>You can use <code>Database#notify</code> to send notification to channels:</p>
            
            <pre>DB.notify(:channel)&#x000A;# NOTIFY &quot;channel&quot;</pre>
            
            <p><code>postgres/pg only</code> You can listen on channels via
            <code>Database#listen</code>.  Note that this blocks until the listening
            thread is notified:</p>
            
            <pre>DB.listen(:channel)&#x000A;# LISTEN &quot;channel&quot;&#x000A;# after notification received:&#x000A;# UNLISTEN *</pre>
            
            <p>Note that <code>listen</code> by default only listens for a single
            notification.  If you want to loop and process notifications:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">listen</span>(:<span class="ruby-identifier">channel</span>, :<span class="ruby-identifier">loop=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>){<span class="ruby-operator">|</span><span class="ruby-identifier">channel</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">channel</span>}</pre>
            
            <p>The <code>pg_static_cache_updater</code> extension uses this support to
            automatically update the caches for models using the
            <code>static_cache</code> plugin.  Look at the documentation of that plugin
            for details.</p>
            
            <h3 id="label-Locking+Tables">Locking Tables</h3>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> makes it easy to lock
            tables, though it is generally better to let the database handle locking:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">lock</span>(<span class="ruby-string">&#39;EXCLUSIVE&#39;</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">insert</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">max</span>(:<span class="ruby-identifier">id</span>)<span class="ruby-operator">+</span><span class="ruby-value">1</span>)&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-comment"># BEGIN;</span>&#x000A;<span class="ruby-comment"># LOCK TABLE &quot;table&quot; IN EXCLUSIVE MODE;</span>&#x000A;<span class="ruby-comment"># SELECT max(&quot;id&quot;) FROM &quot;table&quot; LIMIT 1;</span>&#x000A;<span class="ruby-comment"># INSERT INTO &quot;table&quot; (&quot;id&quot;) VALUES (2) RETURNING NULL;</span>&#x000A;<span class="ruby-comment"># COMMIT;</span></pre>
            
            <h2 id="label-sequel_pg+%28postgres%2Fpg+only%29">sequel_pg (<code>postgres/pg only</code>)</h2>
            
            <p>When the postgres adapter is used with the pg driver, <a
            href="../../classes/Sequel.html">Sequel</a> automatically checks for
            sequel_pg, and loads it if it is available.  sequel_pg is a C extension
            that optimizes the fetching of rows, generally resulting in a 2-6x speedup.
            It is highly recommended to install sequel_pg if you are using the postgres
            adapter with pg.</p>
            
            <p>sequel_pg has additional optimizations when using the Dataset
            <code>map</code>, <code>to_hash</code>, <code>to_hash_groups</code>,
            <code>select_hash</code>, <code>select_hash_groups</code>,
            <code>select_map</code>, and <code>select_order_map</code> methods, which
            avoids creating intermediate hashes and can add further speedups.</p>
            
            <p>In addition to optimization, sequel_pg also adds streaming support if used
            on PostgreSQL 9.2. Streaming support is similar to using a cursor, but it
            is faster and more transparent.</p>
            
            <p>You can enable the streaming support:</p>
            
            <pre>DB.extension(:pg_streaming)</pre>
            
            <p>Then you can stream individual datasets:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">stream</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">row</span><span class="ruby-operator">|</span> }</pre>
            
            <p>Or stream all datasets by default:</p>
            
            <pre>DB.stream_all_queries = true</pre>
            
            <p>When streaming is enabled, <code>Dataset#paged_each</code> will use
            streaming to implement paging.</p>
          </div>
          <div id='context'>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
