<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>advanced_associations.rdoc</title>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='file' id='wrapper'>
<div class='header'>
<h1 class='name'>advanced_associations.rdoc
</h1>
<div class='paths'>
doc/advanced_associations.rdoc
</div>
<div class='last-update'>
Last Update:
<span class='datetime'>2020-04-01 09:49:55 -0700</span>
</div>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<h1 id="label-Advanced+Associations">Advanced Associations<span><a href="#label-Advanced+Associations">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p><a href="../../classes/Sequel/Model.html"><code>Sequel::Model</code></a>‘s association support is powerful and flexible, but it can be difficult for new users to understand what the support enables.  This guide shows off some of the more advanced <a href="../../classes/Sequel/Model.html"><code>Sequel::Model</code></a> association features.</p>

<p>You should probably review the <a href="association_basics_rdoc.html">Model Associations Basics and Options guide</a> before reviewing this guide.</p>

<h2 id="label-Sequel-3A-3AModel+Eager+Loading"><a href="../../classes/Sequel/Model.html"><code>Sequel::Model</code></a> Eager Loading<span><a href="#label-Sequel-3A-3AModel+Eager+Loading">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="../../classes/Sequel/Model.html"><code>Sequel::Model</code></a> offers two different ways to perform eager loading, <code>eager</code> and <code>eager_graph</code>. <code>eager</code> uses an SQL query per association, <code>eager_graph</code> uses a single SQL query containing JOINs.</p>

<p>Assuming the following associations:</p>

<pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> <span class="ruby-value">:albums</span>
<span class="ruby-constant">Album</span>.<span class="ruby-identifier">one_to_many</span> <span class="ruby-value">:tracks</span>
<span class="ruby-constant">Tracks</span>.<span class="ruby-identifier">many_to_one</span> <span class="ruby-value">:lyric</span>
</pre>

<p>Let’s say you wanted to load all artists and eagerly load the related albums, tracks, and lyrics.</p>

<pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager</span>(<span class="ruby-value">albums:</span> {<span class="ruby-value">tracks:</span> <span class="ruby-value">:lyric</span>})
<span class="ruby-comment"># 4 Queries:</span>
<span class="ruby-comment"># SELECT * FROM artists;</span>
<span class="ruby-comment"># SELECT * FROM albums WHERE (artist_id IN (...));</span>
<span class="ruby-comment"># SELECT * FROM tracks WHERE (album_id IN (...));</span>
<span class="ruby-comment"># SELECT * FROM lyrics WHERE (id IN (...));</span>

<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager_graph</span>(<span class="ruby-value">albums:</span> {<span class="ruby-value">tracks:</span> <span class="ruby-value">:lyric</span>})
<span class="ruby-comment"># 1 Query:</span>
<span class="ruby-comment"># SELECT artists.id, artists.name, ...</span>
<span class="ruby-comment">#        albums.id AS albums_id, albums.name AS albums_name, ...</span>
<span class="ruby-comment">#        tracks.id AS tracks_id, tracks.name AS tracks_name, ...</span>
<span class="ruby-comment">#        lyric.id AS lyric_id, ...</span>
<span class="ruby-comment"># FROM artists</span>
<span class="ruby-comment"># LEFT OUTER JOIN albums ON (albums.artist_id = artists.id)</span>
<span class="ruby-comment"># LEFT OUTER JOIN tracks ON (tracks.album_id = albums.id)</span>
<span class="ruby-comment"># LEFT OUTER JOIN lyrics AS lyric ON (lyric.id = tracks.lyric_id);</span>
</pre>

<p>In general, the recommendation is to use <code>eager</code> unless you have a reason to use <code>eager_graph</code>. <code>eager_graph</code> is needed when you want to reference columns in an associated table.  For example, if you want to order the loading of returned artists based on the names of the albums, you cannot do:</p>

<pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager</span>(<span class="ruby-value">albums:</span> {<span class="ruby-value">tracks:</span> <span class="ruby-value">:lyric</span>}).<span class="ruby-identifier">order</span>{<span class="ruby-identifier">albums</span>[<span class="ruby-value">:name</span>]}
</pre>

<p>because the initial query <a href="../../classes/Sequel.html"><code>Sequel</code></a> will use would be:</p>

<pre class="ruby"><span class="ruby-comment"># SELECT * FROM artists ORDER BY albums.name;</span>
</pre>

<p>and <code>albums</code> is not a valid qualifier in such a query.  In this situation, you must use <code>eager_graph</code>:</p>

<pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager_graph</span>(<span class="ruby-value">albums:</span> {<span class="ruby-value">tracks:</span> <span class="ruby-value">:lyric</span>}).<span class="ruby-identifier">order</span>{<span class="ruby-identifier">albums</span>[<span class="ruby-value">:name</span>]}
</pre>

<p>Whether <code>eager</code> or <code>eager_graph</code> performs better is association and database dependent. If you are concerned about performance, you should try benchmarking both cases with appropriate data to see which performs better.</p>

<h3 id="label-Mixing+eager+and+eager_graph">Mixing eager and eager_graph<span><a href="#label-Mixing+eager+and+eager_graph">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="../../classes/Sequel.html"><code>Sequel</code></a> offers the ability to mix <code>eager</code> and <code>eager_graph</code> when loading results.  This can be done at the main level by calling both <code>eager</code> and <code>eager_graph</code> on the same dataset:</p>

<pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">eager</span>(<span class="ruby-value">:artist</span>).<span class="ruby-identifier">eager_graph</span>(<span class="ruby-value">:tracks</span>)
<span class="ruby-comment"># 2 Queries:</span>
<span class="ruby-comment"># SELECT albums.id, albums.name, ...</span>
<span class="ruby-comment">#        artist.id AS artist_id, artist.name AS artist_name, ...</span>
<span class="ruby-comment"># FROM albums</span>
<span class="ruby-comment"># LEFT OUTER JOIN artists AS artist ON (artist.id = albums.artist_id);</span>
<span class="ruby-comment"># SELECT * FROM artists WHERE (id IN (...));</span>
</pre>

<p>You can also use <code>eager</code> to load initial associations, and <code>eager_graph</code> to load remaining associations, by using <code>eager_graph</code> in an eager load callback:</p>

<pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager</span>(<span class="ruby-value">albums:</span> {<span class="ruby-value">tracks:</span> <span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">eager_graph</span>(<span class="ruby-value">:lyric</span>)}})
<span class="ruby-comment"># 3 Queries:</span>
<span class="ruby-comment"># SELECT * FROM artists;</span>
<span class="ruby-comment"># SELECT * FROM albums WHERE (artist_id IN (...));</span>
<span class="ruby-comment"># SELECT tracks.id, tracks.name, ...</span>
<span class="ruby-comment">#        lyric.id AS lyric_id, ...</span>
<span class="ruby-comment"># FROM tracks</span>
<span class="ruby-comment"># LEFT OUTER JOIN lyrics AS lyric ON (lyric.id = tracks.lyric_id)</span>
<span class="ruby-comment"># WHERE (tracks.album_id IN (...));</span>
</pre>

<p>Using the <code>eager_graph_eager</code> plugin, you can use <code>eager_graph</code> to load the initial associations, and <code>eager</code> to load the remaining associations.  When you call <code>eager_graph_eager</code>, you must specify the dependency chain at which to start the eager loading via <code>eager</code>:</p>

<pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:eager_graph_eager</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager_graph</span>(<span class="ruby-value">albums:</span> <span class="ruby-value">:tracks</span>).<span class="ruby-identifier">eager_graph_eager</span>([<span class="ruby-value">:albums</span>, <span class="ruby-value">:tracks</span>], <span class="ruby-value">:lyric</span>)
<span class="ruby-comment"># 2 Queries:</span>
<span class="ruby-comment"># SELECT artists.id, artists.name, ...</span>
<span class="ruby-comment">#        albums.id AS albums_id, albums.name AS albums_name, ...</span>
<span class="ruby-comment">#        tracks.id AS tracks_id, tracks.name AS tracks_name, ...</span>
<span class="ruby-comment"># FROM artists</span>
<span class="ruby-comment"># LEFT OUTER JOIN albums ON (albums.artist_id = artists.id)</span>
<span class="ruby-comment"># LEFT OUTER JOIN tracks ON (tracks.album_id= albums.id);</span>
<span class="ruby-comment"># SELECT * FROM lyrics WHERE (id IN (...));</span>
</pre>

<p>These two approaches can also be nested, with <code>eager</code> -&gt; <code>eager_graph</code> -&gt; <code>eager</code>:</p>

<pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:eager_graph_eager</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager</span>(<span class="ruby-value">albums:</span> <span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">eager_graph</span>(<span class="ruby-value">:tracks</span>).<span class="ruby-identifier">eager_graph_eager</span>([<span class="ruby-value">:tracks</span>], <span class="ruby-value">:lyric</span>)})
<span class="ruby-comment"># 3 Queries:</span>
<span class="ruby-comment"># SELECT * FROM artists;</span>
<span class="ruby-comment"># SELECT albums.id, albums.name, ...</span>
<span class="ruby-comment">#        tracks.id AS tracks_id, tracks.name AS tracks_name, ...</span>
<span class="ruby-comment"># FROM albums</span>
<span class="ruby-comment"># LEFT OUTER JOIN tracks ON (tracks.album_id = albums.id)</span>
<span class="ruby-comment"># WHERE (albums.artist_id IN (...));</span>
<span class="ruby-comment"># SELECT * FROM lyrics WHERE (id IN (...));</span>
</pre>

<p>Or with 2 separate <code>eager_graph</code> queries:</p>

<pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager_graph</span>(<span class="ruby-value">:albums</span>).<span class="ruby-identifier">eager_graph_eager</span>([<span class="ruby-value">:albums</span>], <span class="ruby-value">:tracks</span><span class="ruby-operator">=&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">eager_graph</span>(<span class="ruby-value">:lyric</span>)})
<span class="ruby-comment"># 2 Queries:</span>
<span class="ruby-comment"># SELECT artists.id, artists.name, ...</span>
<span class="ruby-comment">#        albums.id AS albums_id, albums.name AS albums_name, ...</span>
<span class="ruby-comment"># FROM artists</span>
<span class="ruby-comment"># LEFT OUTER JOIN albums ON (albums.artist_id = artists.id);</span>
<span class="ruby-comment"># SELECT tracks.id, tracks.name, ...</span>
<span class="ruby-comment">#        lyric.id AS lyric_id, ...</span>
<span class="ruby-comment"># FROM tracks</span>
<span class="ruby-comment"># LEFT OUTER JOIN lyrics AS lyric ON (lyric.id = tracks.lyric_id)</span>
<span class="ruby-comment"># WHERE (tracks.album_id IN (...));</span>
</pre>

<h2 id="label-Sequel-3A-3AModel+Association+Loading+Options"><a href="../../classes/Sequel/Model.html"><code>Sequel::Model</code></a> Association Loading Options<span><a href="#label-Sequel-3A-3AModel+Association+Loading+Options">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>There are a bunch of advanced association options that are available to handle more complex cases.  First we’ll go over some of the simpler ones:</p>

<p>All associations take a block that can be used to further filter/modify the default dataset:</p>

<pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> <span class="ruby-value">:gold_albums</span>, <span class="ruby-value">class:</span> <span class="ruby-value">:Album</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">copies_sold</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">500000</span>}
<span class="ruby-keyword">end</span>
</pre>

<p>There’s also an :eager_block option if you want to use a different block when eager loading via <code>Dataset#eager</code>.</p>

<p>There are many options for changing how the association is eagerly loaded via <code>Dataset#eager_graph</code>:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:graph_join_type </td><td>
<p>The type of join to do (<code>:inner</code>, <code>:left</code>, <code>:right</code>)</p>
</td></tr><tr><td class='label'>:graph_conditions </td><td>
<p>Additional conditions to put on join (needs to be a hash or array of all two pairs).  Automatically assumes unqualified symbols or first element of the pair to be columns of the associated model, and unqualified symbols of the second element of the pair to be columns of the current model.</p>
</td></tr><tr><td class='label'>:graph_block </td><td>
<p>A block passed to <code>join_table</code>, allowing you to specify conditions other than equality, or to use OR, or set up any arbitrary condition.  The block is passed the associated table alias, current table  alias, and an array of previous joins clause objects.</p>
</td></tr><tr><td class='label'>:graph_only_conditions </td><td>
<p>Use these conditions instead of the standard association conditions. This is necessary when you don’t want to have an equal condition between the foreign key and primary key of the tables. You can also use this to have a JOIN USING (array of symbols), or a NATURAL or CROSS JOIN (nil, with the appropriate <code>:graph_join_type</code>).</p>
</td></tr></tbody></table>

<p>These can be used like this:</p>

<pre class="ruby"><span class="ruby-comment"># Makes Artist.eager_graph(:required_albums).all not return artists that</span>
<span class="ruby-comment"># don&#39;t have any albums</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> <span class="ruby-value">:required_albums</span>, <span class="ruby-value">class:</span> <span class="ruby-value">:Album</span>, <span class="ruby-value">graph_join_type:</span> <span class="ruby-value">:inner</span>

<span class="ruby-comment"># Makes sure all returned albums have the active flag set</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> <span class="ruby-value">:active_albums</span>, <span class="ruby-value">class:</span> <span class="ruby-value">:Album</span>, <span class="ruby-value">graph_conditions:</span> {<span class="ruby-value">active:</span> <span class="ruby-keyword">true</span>}

<span class="ruby-comment"># Only returns albums that have sold more than 500,000 copies</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> <span class="ruby-value">:gold_albums</span>, <span class="ruby-value">class:</span> <span class="ruby-value">:Album</span>,
  <span class="ruby-value">graph_block:</span> <span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">j</span>,<span class="ruby-identifier">lj</span>,<span class="ruby-identifier">js</span><span class="ruby-operator">|</span> <span class="ruby-constant">Sequel</span>[<span class="ruby-identifier">j</span>][<span class="ruby-value">:copies_sold</span>] <span class="ruby-operator">&gt;</span> <span class="ruby-value">500000</span>}

<span class="ruby-comment"># Handles the case where the tables are associated by a case insensitive name string</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> <span class="ruby-value">:albums</span>, <span class="ruby-value">key:</span> <span class="ruby-value">:artist_name</span>,
  <span class="ruby-value">graph_only_conditions:</span> <span class="ruby-keyword">nil</span>,
  <span class="ruby-value">graph_block:</span> <span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">j</span>,<span class="ruby-identifier">lj</span>,<span class="ruby-identifier">js</span><span class="ruby-operator">|</span> {<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">function</span>(<span class="ruby-value">:lower</span>, <span class="ruby-constant">Sequel</span>[<span class="ruby-identifier">j</span>][<span class="ruby-value">:artist_name</span>])<span class="ruby-operator">=&gt;</span><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">function</span>(<span class="ruby-value">:lower</span>, <span class="ruby-constant">Sequel</span>[<span class="ruby-identifier">lj</span>][<span class="ruby-value">:name</span>])}}

<span class="ruby-comment"># Handles the case where both key columns have the name artist_name, and you want to use</span>
<span class="ruby-comment"># a JOIN USING</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> <span class="ruby-value">:albums</span>, <span class="ruby-value">key:</span> <span class="ruby-value">:artist_name</span>, <span class="ruby-value">graph_only_conditions:</span> [<span class="ruby-value">:artist_name</span>]
</pre>

<p>One advantage of using <code>eager_graph</code> is that you can easily filter/order on columns in an associated table on a per-query basis, using regular <a href="../../classes/Sequel.html"><code>Sequel</code></a> dataset methods.  For example, if you only want to retrieve artists who have albums that start with A, and eager load just those albums, ordered by the albums name, you can do:</p>

<pre class="ruby"><span class="ruby-identifier">albums</span> = <span class="ruby-constant">Artist</span>.
  <span class="ruby-identifier">eager_graph</span>(<span class="ruby-value">:albums</span>).
  <span class="ruby-identifier">where</span>{<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">like</span>(<span class="ruby-identifier">albums</span>[<span class="ruby-value">:name</span>], <span class="ruby-string">&#39;A%&#39;</span>)}.
  <span class="ruby-identifier">order</span>{<span class="ruby-identifier">albums</span>[<span class="ruby-value">:name</span>]}.
  <span class="ruby-identifier">all</span>
</pre>

<p>For lazy loading (e.g. <a href="1">Model</a>.association), the <code>:dataset</code> option can be used to specify an arbitrary dataset (one that uses different keys, multiple keys, joins to other tables, etc.).</p>

<h2 id="label-Custom+Eager+Loaders">Custom Eager Loaders<span><a href="#label-Custom+Eager+Loaders">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>For eager loading via <code>eager</code>, the <code>:eager_loader</code> option can be used to specify how to eagerly load a complex association.  This is an extremely powerful option.  Though it can often be verbose (compared to other things in <a href="../../classes/Sequel.html"><code>Sequel</code></a>), it allows you complete control over how to eagerly load associations for a group of objects.</p>

<p>:eager_loader should be a proc that takes a single hash argument, which will have at least the following keys:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:id_map </td><td>
<p>A mapping of key values to arrays of current model instances, usage described below</p>
</td></tr><tr><td class='label'>:rows </td><td>
<p>An array of model objects</p>
</td></tr><tr><td class='label'>:associations </td><td>
<p>A hash of dependent associations to eagerly load</p>
</td></tr><tr><td class='label'>:self </td><td>
<p>The dataset that is doing the eager loading</p>
</td></tr><tr><td class='label'>:eager_block </td><td>
<p>A dynamic callback for this eager load.</p>
</td></tr></tbody></table>

<p>Since you are given all of the records, you can do things like filter on associations that are specified by multiple keys, or do multiple queries depending on the content of the records (which would be necessary for polymorphic associations).  Inside the <code>:eager_loader</code> proc, you should get the related objects and populate the associations cache for all objects in the array of records.  The hash of dependent associations is available for you to cascade the eager loading down multiple levels, but it is up to you to use it.</p>

<p>The id_map is a performance enhancement that is used by the default association loaders and is also available to you.  It is a hash with keys foreign/primary key values, and values being arrays of current model objects having the foreign/primary key value associated with the key.  This may be hard to visualize, so I’ll give an example.  Let’s say you have the following associations</p>

<pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">many_to_one</span> <span class="ruby-value">:artist</span>
<span class="ruby-constant">Album</span>.<span class="ruby-identifier">one_to_many</span> <span class="ruby-value">:tracks</span>
</pre>

<p>and the following three albums in the database:</p>

<pre class="ruby"><span class="ruby-identifier">album1</span> = <span class="ruby-constant">Album</span>.<span class="ruby-identifier">create</span>(<span class="ruby-value">:artist_id</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">3</span>) <span class="ruby-comment"># id: 1</span>
<span class="ruby-identifier">album2</span> = <span class="ruby-constant">Album</span>.<span class="ruby-identifier">create</span>(<span class="ruby-value">:artist_id</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">3</span>) <span class="ruby-comment"># id: 2</span>
<span class="ruby-identifier">album3</span> = <span class="ruby-constant">Album</span>.<span class="ruby-identifier">create</span>(<span class="ruby-value">:artist_id</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">2</span>) <span class="ruby-comment"># id: 3</span>
</pre>

<p>If you try to eager load this dataset:</p>

<pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">eager</span>(<span class="ruby-value">:artist</span>, <span class="ruby-value">:tracks</span>).<span class="ruby-identifier">all</span>
</pre>

<p>Then the id_map provided to the artist :eager_loader proc would be:</p>

<pre class="ruby">{<span class="ruby-value">3</span><span class="ruby-operator">=&gt;</span>[<span class="ruby-identifier">album1</span>, <span class="ruby-identifier">album2</span>], <span class="ruby-value">2</span><span class="ruby-operator">=&gt;</span>[<span class="ruby-identifier">album3</span>]}
</pre>

<p>The artist id_map contains a mapping of artist_id values to arrays of album objects.  Since both album1 and album2 have the same artist_id, the are both in the array related to that key.  album3 has a different artist_id, so it is in a different array. Eager loading of artists is done by looking for any artist having one of the keys in the hash:</p>

<pre class="ruby"><span class="ruby-identifier">artists</span> = <span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">:id</span><span class="ruby-operator">=&gt;</span><span class="ruby-identifier">id_map</span>.<span class="ruby-identifier">keys</span>).<span class="ruby-identifier">all</span>
</pre>

<p>When the artists are retrieved, you can iterate over them, find entries with matching keys, and manually associate them to the albums:</p>

<pre class="ruby"><span class="ruby-identifier">artists</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">artist</span><span class="ruby-operator">|</span>
  <span class="ruby-comment"># Find related albums using the artist_id_map</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">albums</span> = <span class="ruby-identifier">id_map</span>[<span class="ruby-identifier">artist</span>.<span class="ruby-identifier">id</span>]
    <span class="ruby-comment"># Iterate over the albums</span>
    <span class="ruby-identifier">albums</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">album</span><span class="ruby-operator">|</span>
      <span class="ruby-comment"># Manually set the artist association for each album</span>
      <span class="ruby-identifier">album</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-value">:artist</span>] = <span class="ruby-identifier">artist</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>The id_map provided to the tracks :eager_loader proc would be:</p>

<pre class="ruby">{<span class="ruby-value">1</span><span class="ruby-operator">=&gt;</span>[<span class="ruby-identifier">album1</span>], <span class="ruby-value">2</span><span class="ruby-operator">=&gt;</span>[<span class="ruby-identifier">album2</span>], <span class="ruby-value">3</span><span class="ruby-operator">=&gt;</span>[<span class="ruby-identifier">album3</span>]}
</pre>

<p>Now the id_map contains a mapping of id values to arrays of album objects (in this case each array only has a single object, because id is the primary key).  So when looking for tracks to eagerly load, you only need to look for ones that have an album_id with one of the keys in the hash:</p>

<pre class="ruby"><span class="ruby-identifier">tracks</span> = <span class="ruby-constant">Track</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">:album_id</span><span class="ruby-operator">=&gt;</span><span class="ruby-identifier">id_map</span>.<span class="ruby-identifier">keys</span>).<span class="ruby-identifier">all</span>
</pre>

<p>When the tracks are retrieved, you can iterate over them, find entries with matching keys, and manually associate them to the albums:</p>

<pre class="ruby"><span class="ruby-identifier">tracks</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">track</span><span class="ruby-operator">|</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">albums</span> = <span class="ruby-identifier">id_map</span>[<span class="ruby-identifier">track</span>.<span class="ruby-identifier">album_id</span>]
    <span class="ruby-identifier">albums</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">album</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">album</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-value">:tracks</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">track</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<h3 id="label-Two+basic+example+eager+loaders">Two basic example eager loaders<span><a href="#label-Two+basic+example+eager+loaders">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Putting the code in the above examples together, you almost have enough for a basic working eager loader.  The main important thing that is missing is you need to set initial values for the eagerly loaded associations.  For the artist association, you need to initial the values to nil:</p>

<pre class="ruby"><span class="ruby-comment"># rows here is the :rows entry in the hash passed to the eager loader</span>
<span class="ruby-identifier">rows</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">album</span><span class="ruby-operator">|</span> <span class="ruby-identifier">album</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-value">:artist</span>] = <span class="ruby-keyword">nil</span>}
</pre>

<p>For the tracks association, you set the initial value to an empty array:</p>

<pre class="ruby"><span class="ruby-identifier">rows</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">album</span><span class="ruby-operator">|</span> <span class="ruby-identifier">album</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-value">:track</span>] = []}
</pre>

<p>These are done so that if an album currently being loaded doesn’t have an associated artist or any associated tracks, the lack of them will be cached, so calling the artist or tracks method on the album will not do another database lookup.</p>

<p>So putting everything together, the artist eager loader looks like:</p>

<pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">many_to_one</span> <span class="ruby-value">:artist</span>, <span class="ruby-value">:eager_loader</span><span class="ruby-operator">=&gt;</span>(<span class="ruby-identifier">proc</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">eo_opts</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">eo_opts</span>[<span class="ruby-value">:rows</span>].<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">album</span><span class="ruby-operator">|</span> <span class="ruby-identifier">album</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-value">:artist</span>] = <span class="ruby-keyword">nil</span>}
  <span class="ruby-identifier">id_map</span> = <span class="ruby-identifier">eo_opts</span>[<span class="ruby-value">:id_map</span>]
  <span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">:id</span><span class="ruby-operator">=&gt;</span><span class="ruby-identifier">id_map</span>.<span class="ruby-identifier">keys</span>).<span class="ruby-identifier">all</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">artist</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">albums</span> = <span class="ruby-identifier">id_map</span>[<span class="ruby-identifier">artist</span>.<span class="ruby-identifier">id</span>]
      <span class="ruby-identifier">albums</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">album</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">album</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-value">:artist</span>] = <span class="ruby-identifier">artist</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>)
</pre>

<p>and the tracks eager loader looks like:</p>

<pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">one_to_many</span> <span class="ruby-value">:tracks</span>, <span class="ruby-value">:eager_loader</span><span class="ruby-operator">=&gt;</span>(<span class="ruby-identifier">proc</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">eo_opts</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">eo_opts</span>[<span class="ruby-value">:rows</span>].<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">album</span><span class="ruby-operator">|</span> <span class="ruby-identifier">album</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-value">:tracks</span>] = []}
  <span class="ruby-identifier">id_map</span> = <span class="ruby-identifier">eo_opts</span>[<span class="ruby-value">:id_map</span>]
  <span class="ruby-constant">Track</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">:album_id</span><span class="ruby-operator">=&gt;</span><span class="ruby-identifier">id_map</span>.<span class="ruby-identifier">keys</span>).<span class="ruby-identifier">all</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">track</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">albums</span> = <span class="ruby-identifier">id_map</span>[<span class="ruby-identifier">track</span>.<span class="ruby-identifier">album_id</span>]
      <span class="ruby-identifier">albums</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">album</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">album</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-value">:tracks</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">track</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>)
</pre>

<p>Now, these are both overly simplistic eager loaders that don’t respect cascaded associations or any of the association options.  But hopefully they both provide simple examples that you can more easily build and learn from, as  the custom eager loaders described later in this page are more complex.</p>

<p>Basically, the eager loading steps can be broken down into:</p>
<ol><li>
<p>Set default association values (nil/[]) for each of the current objects</p>
</li><li>
<p>Return just related associated objects by filtering the associated class to include only rows with keys present in the id_map.</p>
</li><li>
<p>Iterating over the returned associated objects, indexing into the id_map using the foreign/primary key value in the associated object to get current values associated to that specific object.</p>
</li><li>
<p>For each of those current values, updating the cached association value to include that specific object.</p>
</li></ol>

<p>Using the :eager_loader proc, you should be able to eagerly load all associations that can be eagerly loaded, even if <a href="../../classes/Sequel.html"><code>Sequel</code></a> doesn’t natively support such eager loading.</p>

<h2 id="label-Limited+Associations">Limited Associations<span><a href="#label-Limited+Associations">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="../../classes/Sequel.html"><code>Sequel</code></a> supports specifying limits and/or offsets for associations:</p>

<pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> <span class="ruby-value">:first_10_albums</span>, <span class="ruby-value">class:</span> <span class="ruby-value">:Album</span>, <span class="ruby-value">order:</span> <span class="ruby-value">:release_date</span>, <span class="ruby-value">limit:</span> <span class="ruby-value">10</span>
</pre>

<p>For retrieving the associated objects for a single object, this just uses a LIMIT:</p>

<pre class="ruby"><span class="ruby-identifier">artist</span>.<span class="ruby-identifier">first_10_albums</span>
<span class="ruby-comment"># SELECT * FROM albums WHERE (artist_id = 1) LIMIT 10</span>
</pre>

<h3 id="label-Eager+Loading+via+eager">Eager Loading via eager<span><a href="#label-Eager+Loading+via+eager">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>However, if you want to eagerly load an association, you must use a different approach.  <a href="../../classes/Sequel.html"><code>Sequel</code></a> has 4 separate strategies for dealing with such cases.</p>

<p>The default strategy used on all databases is a UNION-based approach, which will submit multiple subqueries in a UNION query:</p>

<pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">id:</span> [<span class="ruby-value">1</span>,<span class="ruby-value">2</span>]).<span class="ruby-identifier">eager</span>(<span class="ruby-value">:first_10_albums</span>).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT * FROM (SELECT * FROM albums WHERE (artist_id = 1) LIMIT 10) UNION ALL</span>
<span class="ruby-comment"># SELECT * FROM (SELECT * FROM albums WHERE (artist_id = 2) LIMIT 10)</span>
</pre>

<p>This is the fastest way to load the associated objects on most databases, as long as there is an index on albums.artist_id.  Without an index it is probably the slowest approach, so make sure you have an index on the key columns.  If you cannot add an index, you’ll want to manually specify the :eager_limit_strategy option as shown below.</p>

<p>On PostgreSQL, for *_one associations that don’t use an offset, you can choose to use a the distinct on strategy:</p>

<pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_one</span> <span class="ruby-value">:first_album</span>, <span class="ruby-value">class:</span> <span class="ruby-value">:Album</span>, <span class="ruby-value">order:</span> <span class="ruby-value">:release_date</span>,
  <span class="ruby-value">eager_limit_strategy:</span> <span class="ruby-value">:distinct_on</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">id:</span> [<span class="ruby-value">1</span>,<span class="ruby-value">2</span>]).<span class="ruby-identifier">eager</span>(<span class="ruby-value">:first_album</span>).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT DISTINCT ON (albums.artist_id) *</span>
<span class="ruby-comment"># FROM albums</span>
<span class="ruby-comment"># WHERE (albums.artist_id IN (1, 2))</span>
<span class="ruby-comment"># ORDER BY albums.artist_id, release_date</span>
</pre>

<p>Otherwise, if the database supports window functions, you can choose to use the window function strategy:</p>

<pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> <span class="ruby-value">:first_10_albums</span>, <span class="ruby-value">class:</span> <span class="ruby-value">:Album</span>, <span class="ruby-value">order:</span> <span class="ruby-value">:release_date</span>, <span class="ruby-value">limit:</span> <span class="ruby-value">10</span>,
  <span class="ruby-value">eager_limit_strategy:</span> <span class="ruby-value">:window_function</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">:id</span><span class="ruby-operator">=&gt;</span>[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>]).<span class="ruby-identifier">eager</span>(<span class="ruby-value">:first_10_albums</span>).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT * FROM (</span>
<span class="ruby-comment">#   SELECT *, row_number() OVER (PARTITION BY albums.artist_id ORDER BY release_date) AS x_sequel_row_number_x</span>
<span class="ruby-comment">#   FROM albums</span>
<span class="ruby-comment">#   WHERE (albums.artist_id IN (1, 2))</span>
<span class="ruby-comment"># ) AS t1</span>
<span class="ruby-comment"># WHERE (x_sequel_row_number_x &lt;= 10)</span>
</pre>

<p>Alternatively, you can use the :ruby strategy, which will fall back to retrieving all records, and then will slice the resulting array to get the first 10 after retrieval.</p>

<h3 id="label-Dynamic+Eager+Loading+Limits">Dynamic Eager Loading Limits<span><a href="#label-Dynamic+Eager+Loading+Limits">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>If you need to eager load variable numbers of records (with limits that aren’t known at the time of the association definition), <a href="../../classes/Sequel.html"><code>Sequel</code></a> supports an :eager_limit dataset option that can be defined in an eager loading callback:</p>

<pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> <span class="ruby-value">:albums</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">id:</span> [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>]).<span class="ruby-identifier">eager</span>(<span class="ruby-value">albums:</span> <span class="ruby-identifier">lambda</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">order</span>(<span class="ruby-value">:release_date</span>).<span class="ruby-identifier">clone</span>(<span class="ruby-value">eager_limit:</span> <span class="ruby-value">3</span>)}).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT * FROM (</span>
<span class="ruby-comment">#   SELECT *, row_number() OVER (PARTITION BY albums.artist_id ORDER BY release_date) AS x_sequel_row_number_x</span>
<span class="ruby-comment">#   FROM albums</span>
<span class="ruby-comment">#   WHERE (albums.artist_id IN (1, 2))</span>
<span class="ruby-comment"># ) AS t1</span>
<span class="ruby-comment"># WHERE (x_sequel_row_number_x &lt;= 3)</span>
</pre>

<p>You can also customize the :eager_limit_strategy on a case-by-case basis by passing in that option in the same way:</p>

<pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">id:</span> [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>]).<span class="ruby-identifier">eager</span>(<span class="ruby-value">albums:</span> <span class="ruby-identifier">lambda</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">order</span>(<span class="ruby-value">:release_date</span>).<span class="ruby-identifier">clone</span>(<span class="ruby-value">eager_limit:</span> <span class="ruby-value">3</span>, <span class="ruby-value">eager_limit_strategy:</span> <span class="ruby-value">:ruby</span>)}).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT * FROM albums WHERE (albums.artist_id IN (1, 2)) ORDER BY release_date</span>
</pre>

<p>The :eager_limit and :eager_limit_strategy options currently only work when eager loading via eager, not with eager_graph.</p>

<h3 id="label-Eager+Loading+via+eager_graph_with_options">Eager Loading via eager_graph_with_options<span><a href="#label-Eager+Loading+via+eager_graph_with_options">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>When eager loading an association via eager_graph (which uses JOINs), the situation is similar.  While the UNION-based strategy cannot be used as you don’t know the records being eagerly loaded in advance, <a href="../../classes/Sequel.html"><code>Sequel</code></a> can use a variant of the other 3 strategies.  By default it retrieves all records and then does the array slice in ruby.  As eager_graph does not support options, to use an eager_graph limit strategy you have to use the eager_graph_with_options method with the :limit_strategy option.</p>

<p>The :distinct_on strategy uses DISTINCT ON in a subquery and JOINs that subquery:</p>

<pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager_graph_with_options</span>(<span class="ruby-value">:first_album</span>, <span class="ruby-value">limit_strategy:</span> <span class="ruby-value">:distinct_on</span>).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT artists.id, artists.name, first_album.id AS first_album_id,</span>
<span class="ruby-comment">#        first_album.name AS first_album_name, first_album.artist_id,</span>
<span class="ruby-comment">#        first_album.release_date</span>
<span class="ruby-comment"># FROM artists</span>
<span class="ruby-comment"># LEFT OUTER JOIN (</span>
<span class="ruby-comment">#   SELECT DISTINCT ON (albums.artist_id) *</span>
<span class="ruby-comment">#   FROM albums</span>
<span class="ruby-comment">#   ORDER BY albums.artist_id, release_date</span>
<span class="ruby-comment"># ) AS first_album ON (first_album.artist_id = artists.id)</span>
</pre>

<p>The :window_function approach JOINs to a nested subquery using a window function:</p>

<pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager_graph_with_options</span>(<span class="ruby-value">:first_10_albums</span>, <span class="ruby-value">limit_strategy:</span> <span class="ruby-value">:window_function</span>).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT artists.id, artists.name, first_10_albums.id AS first_10_albums_id,</span>
<span class="ruby-comment">#        first_10_albums.name AS first_10_albums_name, first_10_albums.artist_id,</span>
<span class="ruby-comment">#        first_10_albums.release_date</span>
<span class="ruby-comment"># FROM artists</span>
<span class="ruby-comment"># LEFT OUTER JOIN (</span>
<span class="ruby-comment">#   SELECT id, name, artist_id, release_date</span>
<span class="ruby-comment">#   FROM (</span>
<span class="ruby-comment">#     SELECT *, row_number() OVER (PARTITION BY tracks.album_id ORDER BY release_date) AS x_sequel_row_number_x</span>
<span class="ruby-comment">#     FROM albums</span>
<span class="ruby-comment">#   ) AS t1 WHERE (x_sequel_row_number_x &lt;= 10)</span>
<span class="ruby-comment"># ) AS first_10_albums ON (first_10_albums.artist_id = artists.id)</span>
</pre>

<p>The :correlated_subquery approach JOINs to a nested subquery using a correlated subquery:</p>

<pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager_graph_with_options</span>(<span class="ruby-value">:first_10_albums</span>, <span class="ruby-value">:limit_strategy</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">:correlated_subquery</span>).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT artists.id, artists.name, first_10_albums.id AS first_10_albums_id,</span>
<span class="ruby-comment">#        first_10_albums.name AS first_10_albums_name, first_10_albums.artist_id,</span>
<span class="ruby-comment">#        first_10_albums.release_date</span>
<span class="ruby-comment"># FROM artists</span>
<span class="ruby-comment"># LEFT OUTER JOIN (</span>
<span class="ruby-comment">#   SELECT *</span>
<span class="ruby-comment">#   FROM albums</span>
<span class="ruby-comment">#   WHERE albums.id IN (</span>
<span class="ruby-comment">#     SELECT t1.id</span>
<span class="ruby-comment">#     FROM tracks AS t1</span>
<span class="ruby-comment">#     WHERE (t1.album_id = tracks.album_id)</span>
<span class="ruby-comment">#     ORDER BY release_date</span>
<span class="ruby-comment">#     LIMIT 10</span>
<span class="ruby-comment">#   )</span>
<span class="ruby-comment"># ) AS first_10_albums ON (first_10_albums.artist_id = artists.id)</span>
</pre>

<p>The reason that <a href="../../classes/Sequel.html"><code>Sequel</code></a> does not automatically use the :distinct_on, :window function or :correlated_subquery strategy for eager_graph is that it can perform much worse than the default of just doing the array slicing in ruby.  If you are only using eager_graph to return a few records, it may be cheaper to get all of their associated records and filter them in ruby as opposed to computing the set of limited associated records for all rows.</p>

<p>It’s recommended to only use an eager_graph limit strategy if you have benchmarked it against the default behavior and found it is faster for your use case.</p>

<h3 id="label-Filtering+By+Associations">Filtering By Associations<span><a href="#label-Filtering+By+Associations">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>In order to return correct results, <a href="../../classes/Sequel.html"><code>Sequel</code></a> automatically uses a limit strategy when using filtering by associations with limited associations, if the database supports it.  As in the eager_graph case, the UNION-based strategy doesn’t work.  Unlike in the eager and eager_graph cases, the array slicing in ruby approach does not work, you must use an SQL-based strategy.  <a href="../../classes/Sequel.html"><code>Sequel</code></a> will select an appropriate default strategy based on the database you are using, and you can override it using the :filter_limit_strategy option.</p>

<p>The :distinct_on strategy:</p>

<pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">first_album:</span> <span class="ruby-constant">Album</span>[<span class="ruby-value">1</span>]).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT *</span>
<span class="ruby-comment"># FROM artists</span>
<span class="ruby-comment"># WHERE (artists.id IN (</span>
<span class="ruby-comment">#   SELECT albums.artist_id</span>
<span class="ruby-comment">#   FROM albums</span>
<span class="ruby-comment">#   WHERE ((albums.artist_id IS NOT NULL) AND (albums.id IN (</span>
<span class="ruby-comment">#     SELECT DISTINCT ON (albums.artist_id) albums.id</span>
<span class="ruby-comment">#     FROM albums</span>
<span class="ruby-comment">#     ORDER BY albums.artist_id, release_date</span>
<span class="ruby-comment">#   )) AND (albums.id = 1))))</span>
</pre>

<p>The :window_function strategy:</p>

<pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">first_10_albums:</span> <span class="ruby-constant">Album</span>[<span class="ruby-value">1</span>]).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT *</span>
<span class="ruby-comment"># FROM artists</span>
<span class="ruby-comment"># WHERE (artists.id IN (</span>
<span class="ruby-comment">#   SELECT albums.artist_id</span>
<span class="ruby-comment">#   FROM albums</span>
<span class="ruby-comment">#   WHERE ((albums.artist_id IS NOT NULL) AND (albums.id IN (</span>
<span class="ruby-comment">#     SELECT id FROM (</span>
<span class="ruby-comment">#       SELECT albums.id, row_number() OVER (PARTITION BY albums.artist_id ORDER BY release_date) AS x_sequel_row_number_x</span>
<span class="ruby-comment">#       FROM albums</span>
<span class="ruby-comment">#     ) AS t1</span>
<span class="ruby-comment">#     WHERE (x_sequel_row_number_x &lt;= 10)</span>
<span class="ruby-comment">#   )) AND (albums.id = 1))))</span>
</pre>

<p>The :correlated_subquery strategy:</p>

<pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">first_10_albums:</span> <span class="ruby-constant">Album</span>[<span class="ruby-value">1</span>]).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT *</span>
<span class="ruby-comment"># FROM artists</span>
<span class="ruby-comment"># WHERE (artists.id IN (</span>
<span class="ruby-comment">#   SELECT albums.artist_id</span>
<span class="ruby-comment">#   FROM albums</span>
<span class="ruby-comment">#   WHERE ((albums.artist_id IS NOT NULL) AND (albums.id IN (</span>
<span class="ruby-comment">#     SELECT t1.id</span>
<span class="ruby-comment">#     FROM albums AS t1</span>
<span class="ruby-comment">#     WHERE (t1.artist_id = albums.artist_id)</span>
<span class="ruby-comment">#     ORDER BY release_date</span>
<span class="ruby-comment">#     LIMIT 1</span>
<span class="ruby-comment">#   )) AND (albums.id = 1))))</span>
</pre>

<p>Note that filtering by limited associations does not work on MySQL, as MySQL does not support any of the strategies.  It’s also not supported when using composite keys on databases that don’t support window functions and don’t support multiple columns in IN.</p>

<h3 id="label-Additional+Association+Types">Additional Association Types<span><a href="#label-Additional+Association+Types">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>While the above examples for limited associations showed one_to_many and one_to_one associations, it’s just because those are the simplest examples.  <a href="../../classes/Sequel.html"><code>Sequel</code></a> supports all of the same features for many_to_many and one_through_one associations that are enabled by default, as well as the many_through_many and one_through_many associations that are added by the many_through_many plugin.</p>

<h2 id="label-More+advanced+association+examples+">More advanced association examples <span><a href="#label-More+advanced+association+examples+">&para;</a> <a href="#top">&uarr;</a></span></h2>

<h3 id="label-Association+extensions">Association extensions<span><a href="#label-Association+extensions">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>All associations come with an <code><em>association</em>_dataset</code> method that can be further filtered or otherwise modified:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Author</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>
  <span class="ruby-identifier">one_to_many</span> <span class="ruby-value">:authorships</span>
<span class="ruby-keyword">end</span>
<span class="ruby-constant">Author</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">authorships_dataset</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">number</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">10</span>}.<span class="ruby-identifier">first</span>
</pre>

<p>You can extend a dataset with a module using the <code>:extend</code> association option.  You can reference the model object that created the association dataset via the dataset’s <code>model_object</code> method, and the related association reflection via the dataset’s <code>association_reflection</code> method:</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">FindOrCreate</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_or_create</span>(<span class="ruby-identifier">vals</span>)
    <span class="ruby-identifier">first</span>(<span class="ruby-identifier">vals</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">model</span>.<span class="ruby-identifier">create</span>(<span class="ruby-identifier">vals</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">association_reflection</span>[<span class="ruby-value">:key</span>]<span class="ruby-operator">=&gt;</span><span class="ruby-identifier">model_object</span>.<span class="ruby-identifier">id</span>))
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">Author</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>
  <span class="ruby-identifier">one_to_many</span> <span class="ruby-value">:authorships</span>, <span class="ruby-value">extend:</span> <span class="ruby-constant">FindOrCreate</span>
<span class="ruby-keyword">end</span>
<span class="ruby-constant">Author</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">authorships_dataset</span>.<span class="ruby-identifier">find_or_create</span>(<span class="ruby-value">name:</span> <span class="ruby-string">&#39;Blah&#39;</span>, <span class="ruby-value">number:</span> <span class="ruby-value">10</span>)
</pre>

<h3 id="label-many_to_many+associations+through+model+tables">many_to_many associations through model tables<span><a href="#label-many_to_many+associations+through+model+tables">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The many_to_many association can be used even when the join table is a table used for a model.  The only requirement is the join table has foreign keys to both the current model and the associated model.  Anytime there is a one_to_many association from model A to model B, and model B has a many_to_one association to model C, you can use a many_to_many association from model A to model C.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Author</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>
  <span class="ruby-identifier">one_to_many</span> <span class="ruby-value">:authorships</span>
  <span class="ruby-identifier">many_to_many</span> <span class="ruby-value">:books</span>, <span class="ruby-value">join_table:</span> <span class="ruby-value">:authorships</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">Authorship</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>
  <span class="ruby-identifier">many_to_one</span> <span class="ruby-value">:author</span>
  <span class="ruby-identifier">many_to_one</span> <span class="ruby-value">:book</span>
<span class="ruby-keyword">end</span>

<span class="ruby-ivar">@author</span> = <span class="ruby-constant">Author</span>.<span class="ruby-identifier">first</span>
<span class="ruby-ivar">@author</span>.<span class="ruby-identifier">books</span>
</pre>

<h3 id="label-many_to_many+for+three-level+associations">many_to_many for three-level associations<span><a href="#label-many_to_many+for+three-level+associations">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>You can even use a many_to_many association between model A and model C if model A has a one_to_many association to model B, and model B has a one_to_many association to model C. You just need to use the appropriate :right_key and :right_primary_key options.  And in the reverse direction from model C to model A, you can use a one_through_one association using the :left_key and :left_primary_key options.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Firm</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>
  <span class="ruby-identifier">one_to_many</span> <span class="ruby-value">:clients</span>
  <span class="ruby-identifier">many_to_many</span> <span class="ruby-value">:invoices</span>, <span class="ruby-value">join_table:</span> <span class="ruby-value">:clients</span>, <span class="ruby-value">right_key:</span> <span class="ruby-value">:id</span>, <span class="ruby-value">right_primary_key:</span> <span class="ruby-value">:client_id</span>
<span class="ruby-keyword">end</span> 

<span class="ruby-keyword">class</span> <span class="ruby-constant">Client</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>
  <span class="ruby-identifier">many_to_one</span> <span class="ruby-value">:firm</span>
  <span class="ruby-identifier">one_to_many</span> <span class="ruby-value">:invoices</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">Invoice</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>
  <span class="ruby-identifier">many_to_one</span> <span class="ruby-value">:client</span>
  <span class="ruby-identifier">one_through_one</span> <span class="ruby-value">:firm</span>, <span class="ruby-value">join_table:</span> <span class="ruby-value">:clients</span>, <span class="ruby-value">left_key:</span> <span class="ruby-value">:id</span>, <span class="ruby-value">left_primary_key:</span> <span class="ruby-value">:client_id</span>
<span class="ruby-keyword">end</span>

<span class="ruby-constant">Firm</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">invoices</span>
<span class="ruby-constant">Invoice</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">firm</span>
</pre>

<p>To handle cases where there are multiple join tables, you can use the many_through_many plugin that ships with <a href="../../classes/Sequel.html"><code>Sequel</code></a>.</p>

<h3 id="label-Polymorphic+Associations">Polymorphic Associations<span><a href="#label-Polymorphic+Associations">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="../../classes/Sequel.html"><code>Sequel</code></a> discourages the use of polymorphic associations, which is the reason they are not supported by default.  All polymorphic associations can be made non-polymorphic by using additional tables and/or columns instead of having a column containing the associated class name as a string.</p>

<p>Polymorphic associations break referential integrity and are significantly more complex than non-polymorphic associations, so their use is not recommended unless you are stuck with an existing design that uses them.</p>

<p>If you must use them, look for the sequel_polymorphic external plugin, as it makes using polymorphic associations in <a href="../../classes/Sequel.html"><code>Sequel</code></a> about as easy as it is in ActiveRecord.  However, here’s how they can be done using Sequel’s custom associations (the sequel_polymorphic external plugin is just a generic version of this code):</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Asset</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>
  <span class="ruby-identifier">many_to_one</span> <span class="ruby-value">:attachable</span>, <span class="ruby-value">reciprocal:</span> <span class="ruby-value">:assets</span>,
    <span class="ruby-value">setter:</span> (<span class="ruby-identifier">lambda</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">attachable</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">self</span>[<span class="ruby-value">:attachable_id</span>] = (<span class="ruby-identifier">attachable</span>.<span class="ruby-identifier">pk</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">attachable</span>)
      <span class="ruby-keyword">self</span>[<span class="ruby-value">:attachable_type</span>] = (<span class="ruby-identifier">attachable</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">name</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">attachable</span>)
    <span class="ruby-keyword">end</span>),
    <span class="ruby-value">dataset:</span> (<span class="ruby-identifier">proc</span> <span class="ruby-keyword">do</span>
      <span class="ruby-identifier">klass</span> = <span class="ruby-identifier">attachable_type</span>.<span class="ruby-identifier">constantize</span>
      <span class="ruby-identifier">klass</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">klass</span>.<span class="ruby-identifier">primary_key</span><span class="ruby-operator">=&gt;</span><span class="ruby-identifier">attachable_id</span>)
    <span class="ruby-keyword">end</span>),
    <span class="ruby-value">eager_loader:</span> (<span class="ruby-identifier">lambda</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">eo</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">id_map</span> = {}
      <span class="ruby-identifier">eo</span>[<span class="ruby-value">:rows</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">asset</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">asset</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-value">:attachable</span>] = <span class="ruby-keyword">nil</span> 
        ((<span class="ruby-identifier">id_map</span>[<span class="ruby-identifier">asset</span>.<span class="ruby-identifier">attachable_type</span>] <span class="ruby-operator">||=</span> {})[<span class="ruby-identifier">asset</span>.<span class="ruby-identifier">attachable_id</span>] <span class="ruby-operator">||=</span> []) <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">asset</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">id_map</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">klass_name</span>, <span class="ruby-identifier">id_map</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">klass</span> = <span class="ruby-identifier">klass_name</span>.<span class="ruby-identifier">constantize</span>
        <span class="ruby-identifier">klass</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">klass</span>.<span class="ruby-identifier">primary_key</span><span class="ruby-operator">=&gt;</span><span class="ruby-identifier">id_map</span>.<span class="ruby-identifier">keys</span>).<span class="ruby-identifier">all</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">attach</span><span class="ruby-operator">|</span>
          <span class="ruby-identifier">id_map</span>[<span class="ruby-identifier">attach</span>.<span class="ruby-identifier">pk</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">asset</span><span class="ruby-operator">|</span>
            <span class="ruby-identifier">asset</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-value">:attachable</span>] = <span class="ruby-identifier">attach</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>)
<span class="ruby-keyword">end</span> 

<span class="ruby-keyword">class</span> <span class="ruby-constant">Post</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>
  <span class="ruby-identifier">one_to_many</span> <span class="ruby-value">:assets</span>, <span class="ruby-value">key:</span> <span class="ruby-value">:attachable_id</span>, <span class="ruby-value">reciprocal:</span> <span class="ruby-value">:attachable</span>, <span class="ruby-value">conditions:</span> {<span class="ruby-value">attachable_type:</span> <span class="ruby-string">&#39;Post&#39;</span>},
    <span class="ruby-value">adder:</span> <span class="ruby-identifier">lambda</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">asset</span><span class="ruby-operator">|</span> <span class="ruby-identifier">asset</span>.<span class="ruby-identifier">update</span>(<span class="ruby-value">attachable_id:</span> <span class="ruby-identifier">pk</span>, <span class="ruby-value">attachable_type:</span> <span class="ruby-string">&#39;Post&#39;</span>)},
    <span class="ruby-value">remover:</span> <span class="ruby-identifier">lambda</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">asset</span><span class="ruby-operator">|</span> <span class="ruby-identifier">asset</span>.<span class="ruby-identifier">update</span>(<span class="ruby-value">attachable_id:</span> <span class="ruby-keyword">nil</span>, <span class="ruby-value">attachable_type:</span> <span class="ruby-keyword">nil</span>)},
    <span class="ruby-value">clearer:</span> <span class="ruby-identifier">lambda</span>{<span class="ruby-identifier">assets_dataset</span>.<span class="ruby-identifier">update</span>(<span class="ruby-value">attachable_id:</span> <span class="ruby-keyword">nil</span>, <span class="ruby-value">attachable_type:</span> <span class="ruby-keyword">nil</span>)}
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">Note</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>
  <span class="ruby-identifier">one_to_many</span> <span class="ruby-value">:assets</span>, <span class="ruby-value">key:</span> <span class="ruby-value">:attachable_id</span>, <span class="ruby-value">reciprocal:</span> <span class="ruby-value">:attachable</span>, <span class="ruby-value">conditions:</span> {<span class="ruby-value">attachable_type:</span> <span class="ruby-string">&#39;Note&#39;</span>},
    <span class="ruby-value">adder:</span> <span class="ruby-identifier">lambda</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">asset</span><span class="ruby-operator">|</span> <span class="ruby-identifier">asset</span>.<span class="ruby-identifier">update</span>(<span class="ruby-value">attachable_id:</span> <span class="ruby-identifier">pk</span>, <span class="ruby-value">attachable_type:</span> <span class="ruby-string">&#39;Note&#39;</span>)},
    <span class="ruby-value">remover:</span> <span class="ruby-identifier">lambda</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">asset</span><span class="ruby-operator">|</span> <span class="ruby-identifier">asset</span>.<span class="ruby-identifier">update</span>(<span class="ruby-value">attachable_id:</span> <span class="ruby-keyword">nil</span>, <span class="ruby-value">attachable_type:</span> <span class="ruby-keyword">nil</span>)},
    <span class="ruby-value">clearer:</span> <span class="ruby-identifier">lambda</span>{<span class="ruby-identifier">assets_dataset</span>.<span class="ruby-identifier">update</span>(<span class="ruby-value">attachable_id:</span> <span class="ruby-keyword">nil</span>, <span class="ruby-value">attachable_type:</span> <span class="ruby-keyword">nil</span>)}
<span class="ruby-keyword">end</span>

<span class="ruby-ivar">@asset</span>.<span class="ruby-identifier">attachable</span> = <span class="ruby-ivar">@post</span>
<span class="ruby-ivar">@asset</span>.<span class="ruby-identifier">attachable</span> = <span class="ruby-ivar">@note</span>
</pre>

<h3 id="label-Joining+on+multiple+keys">Joining on multiple keys<span><a href="#label-Joining+on+multiple+keys">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Let’s say you have two tables that are associated with each other with multiple keys.  This can be handled using Sequel’s built in composite key support for associations:</p>

<pre class="ruby"><span class="ruby-comment"># Both of these models have an album_id, number, and disc_number fields.</span>
<span class="ruby-comment"># All FavoriteTracks have an associated track, but not all tracks have an</span>
<span class="ruby-comment"># associated favorite track</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">Track</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>
  <span class="ruby-identifier">many_to_one</span> <span class="ruby-value">:favorite_track</span>, <span class="ruby-value">key:</span> [<span class="ruby-value">:disc_number</span>, <span class="ruby-value">:number</span>, <span class="ruby-value">:album_id</span>], <span class="ruby-value">primary_key:</span> [<span class="ruby-value">:disc_number</span>, <span class="ruby-value">:number</span>, <span class="ruby-value">:album_id</span>]
<span class="ruby-keyword">end</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">FavoriteTrack</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>
  <span class="ruby-identifier">one_to_one</span> <span class="ruby-value">:tracks</span>, <span class="ruby-value">key:</span> [<span class="ruby-value">:disc_number</span>, <span class="ruby-value">:number</span>, <span class="ruby-value">:album_id</span>], <span class="ruby-value">primary_key:</span> [<span class="ruby-value">:disc_number</span>, <span class="ruby-value">:number</span>, <span class="ruby-value">:album_id</span>]
<span class="ruby-keyword">end</span>
</pre>

<h3 id="label-Tree+-+All+Ancestors+and+Descendants">Tree - All Ancestors and Descendants<span><a href="#label-Tree+-+All+Ancestors+and+Descendants">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Let’s say you want to store a tree relationship in your database, it’s pretty simple:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Node</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>
  <span class="ruby-identifier">many_to_one</span> <span class="ruby-value">:parent</span>, <span class="ruby-value">class:</span> <span class="ruby-keyword">self</span>
  <span class="ruby-identifier">one_to_many</span> <span class="ruby-value">:children</span>, <span class="ruby-value">key:</span> <span class="ruby-value">:parent_id</span>, <span class="ruby-value">class:</span> <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span>
</pre>

<p>You can easily get a node’s parent with node.parent, and a node’s children with node.children.  You can even eager load the relationship up to a certain depth:</p>

<pre class="ruby"><span class="ruby-comment"># Eager load three generations of generations of children for a given node</span>
<span class="ruby-constant">Node</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">id:</span> <span class="ruby-value">1</span>).<span class="ruby-identifier">eager</span>(<span class="ruby-value">children:</span> {<span class="ruby-value">children:</span> <span class="ruby-value">:children</span>}).<span class="ruby-identifier">all</span>.<span class="ruby-identifier">first</span>
<span class="ruby-comment"># Load parents and grandparents for a group of nodes</span>
<span class="ruby-constant">Node</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">id</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">10</span>}.<span class="ruby-identifier">eager</span>(<span class="ruby-value">parent:</span> <span class="ruby-value">:parent</span>).<span class="ruby-identifier">all</span>
</pre>

<p>What if you want to get all ancestors up to the root node, or all descendants, without knowing the depth of the tree?</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Node</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>
  <span class="ruby-identifier">many_to_one</span> <span class="ruby-value">:ancestors</span>, <span class="ruby-value">class:</span> <span class="ruby-keyword">self</span>,
   <span class="ruby-value">eager_loader:</span> (<span class="ruby-identifier">lambda</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">eo</span><span class="ruby-operator">|</span>
    <span class="ruby-comment"># Handle cases where the root node has the same parent_id as primary_key</span>
    <span class="ruby-comment"># and also when it is NULL</span>
    <span class="ruby-identifier">non_root_nodes</span> = <span class="ruby-identifier">eo</span>[<span class="ruby-value">:rows</span>].<span class="ruby-identifier">reject</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">n</span><span class="ruby-operator">|</span> 
      <span class="ruby-keyword">if</span> [<span class="ruby-keyword">nil</span>, <span class="ruby-identifier">n</span>.<span class="ruby-identifier">pk</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">n</span>.<span class="ruby-identifier">parent_id</span>)
        <span class="ruby-comment"># Make sure root nodes have their parent association set to nil</span>
        <span class="ruby-identifier">n</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-value">:parent</span>] = <span class="ruby-keyword">nil</span> 
        <span class="ruby-keyword">true</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-keyword">false</span>
      <span class="ruby-keyword">end</span> 
    <span class="ruby-keyword">end</span> 
    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">non_root_nodes</span>.<span class="ruby-identifier">empty?</span>
      <span class="ruby-identifier">id_map</span> = {}
      <span class="ruby-comment"># Create an map of parent_ids to nodes that have that parent id</span>
      <span class="ruby-identifier">non_root_nodes</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">n</span><span class="ruby-operator">|</span> (<span class="ruby-identifier">id_map</span>[<span class="ruby-identifier">n</span>.<span class="ruby-identifier">parent_id</span>] <span class="ruby-operator">||=</span> []) <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">n</span>}
      <span class="ruby-comment"># Doesn&#39;t cause an infinite loop, because when only the root node</span>
      <span class="ruby-comment"># is left, this is not called.</span>
      <span class="ruby-constant">Node</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">id:</span> <span class="ruby-identifier">id_map</span>.<span class="ruby-identifier">keys</span>).<span class="ruby-identifier">eager</span>(<span class="ruby-value">:ancestors</span>).<span class="ruby-identifier">all</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">node</span><span class="ruby-operator">|</span>
        <span class="ruby-comment"># Populate the parent association for each node</span>
        <span class="ruby-identifier">id_map</span>[<span class="ruby-identifier">node</span>.<span class="ruby-identifier">pk</span>].<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">n</span><span class="ruby-operator">|</span> <span class="ruby-identifier">n</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-value">:parent</span>] = <span class="ruby-identifier">node</span>}
      <span class="ruby-keyword">end</span> 
    <span class="ruby-keyword">end</span> 
  <span class="ruby-keyword">end</span>)
  <span class="ruby-identifier">many_to_one</span> <span class="ruby-value">:descendants</span>, <span class="ruby-value">eager_loader:</span> (<span class="ruby-identifier">lambda</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">eo</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">id_map</span> = {}
    <span class="ruby-identifier">eo</span>[<span class="ruby-value">:rows</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">n</span><span class="ruby-operator">|</span> 
      <span class="ruby-comment"># Initialize an empty array of child associations for each parent node</span>
      <span class="ruby-identifier">n</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-value">:children</span>] = []
      <span class="ruby-comment"># Populate identity map of nodes</span>
      <span class="ruby-identifier">id_map</span>[<span class="ruby-identifier">n</span>.<span class="ruby-identifier">pk</span>] = <span class="ruby-identifier">n</span> 
    <span class="ruby-keyword">end</span> 
    <span class="ruby-comment"># Doesn&#39;t cause an infinite loop, because the :eager_loader is not called</span>
    <span class="ruby-comment"># if no records are returned.  Exclude id = parent_id to avoid infinite loop</span>
    <span class="ruby-comment"># if the root note is one of the returned records and it has parent_id = id</span>
    <span class="ruby-comment"># instead of parent_id = NULL.</span>
    <span class="ruby-constant">Node</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">parent_id:</span> <span class="ruby-identifier">id_map</span>.<span class="ruby-identifier">keys</span>).<span class="ruby-identifier">exclude</span>(<span class="ruby-value">id:</span> <span class="ruby-value">:parent_id</span>).<span class="ruby-identifier">eager</span>(<span class="ruby-value">:descendants</span>).<span class="ruby-identifier">all</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">node</span><span class="ruby-operator">|</span>
      <span class="ruby-comment"># Get the parent from the identity map</span>
      <span class="ruby-identifier">parent</span> = <span class="ruby-identifier">id_map</span>[<span class="ruby-identifier">node</span>.<span class="ruby-identifier">parent_id</span>]
      <span class="ruby-comment"># Set the child&#39;s parent association to the parent</span>
      <span class="ruby-identifier">node</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-value">:parent</span>] = <span class="ruby-identifier">parent</span>
      <span class="ruby-comment"># Add the child association to the array of children in the parent</span>
      <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-value">:children</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">node</span>
    <span class="ruby-keyword">end</span> 
  <span class="ruby-keyword">end</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>Note that <a href="../../classes/Sequel.html"><code>Sequel</code></a> ships with an rcte_tree plugin that does all of the above and more:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Node</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>
  <span class="ruby-identifier">plugin</span> <span class="ruby-value">:rcte_tree</span>
<span class="ruby-keyword">end</span>
</pre>

<h3 id="label-Joining+multiple+keys+to+a+single+key-2C+through+a+third+table">Joining multiple keys to a single key, through a third table<span><a href="#label-Joining+multiple+keys+to+a+single+key-2C+through+a+third+table">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Let’s say you have a database of songs, lyrics, and artists.  Each song may or may not have a lyric (most songs are instrumental).  The lyric can be associated to an artist in each of four ways: composer, arranger, vocalist, or lyricist.  These may all be the same, or they could all be different, and none of them are required.  The songs table has a lyric_id field to associate it to the lyric, and the lyric table has four fields to associate it to the artist (composer_id, arranger_id, vocalist_id, and lyricist_id).</p>

<p>What you want to do is get all songs for a given artist, ordered by the song’s name, with no duplicates?</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>
  <span class="ruby-identifier">one_to_many</span> <span class="ruby-value">:songs</span>, <span class="ruby-value">order:</span> <span class="ruby-constant">Sequel</span>[<span class="ruby-value">:songs</span>][<span class="ruby-value">:name</span>],
    <span class="ruby-value">dataset:</span> <span class="ruby-identifier">proc</span>{<span class="ruby-constant">Song</span>.<span class="ruby-identifier">select_all</span>(<span class="ruby-value">:songs</span>).<span class="ruby-identifier">join</span>(<span class="ruby-value">:lyrics</span>, <span class="ruby-value">id:</span> <span class="ruby-value">:lyric_id</span>, <span class="ruby-identifier">id</span><span class="ruby-operator">=&gt;</span>[<span class="ruby-value">:composer_id</span>, <span class="ruby-value">:arranger_id</span>, <span class="ruby-value">:vocalist_id</span>, <span class="ruby-value">:lyricist_id</span>])},
    <span class="ruby-value">eager_loader:</span> (<span class="ruby-identifier">lambda</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">eo</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">h</span> = <span class="ruby-identifier">eo</span>[<span class="ruby-value">:id_map</span>]
      <span class="ruby-identifier">ids</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">keys</span>
      <span class="ruby-identifier">eo</span>[<span class="ruby-value">:rows</span>].<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-value">:songs</span>] = []}
      <span class="ruby-constant">Song</span>.<span class="ruby-identifier">select_all</span>(<span class="ruby-value">:songs</span>).
        <span class="ruby-identifier">select_append</span>{[<span class="ruby-identifier">lyrics</span>[<span class="ruby-value">:composer_id</span>], <span class="ruby-identifier">lyrics</span>[<span class="ruby-value">:arranger_id</span>], <span class="ruby-identifier">lyrics</span>[<span class="ruby-value">:vocalist_id</span>], <span class="ruby-identifier">lyrics</span>[<span class="ruby-value">:lyricist_id</span>]]}.
        <span class="ruby-identifier">join</span>(<span class="ruby-value">:lyrics</span>, <span class="ruby-value">id:</span> <span class="ruby-value">:lyric_id</span>){<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">or</span>(<span class="ruby-value">composer_id:</span> <span class="ruby-identifier">ids</span>, <span class="ruby-value">arranger_id:</span> <span class="ruby-identifier">ids</span>, <span class="ruby-value">vocalist_id:</span> <span class="ruby-identifier">ids</span>, <span class="ruby-value">lyricist_id:</span> <span class="ruby-identifier">ids</span>)}.
        <span class="ruby-identifier">order</span>{<span class="ruby-identifier">songs</span>[<span class="ruby-value">:name</span>]}.<span class="ruby-identifier">all</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">song</span><span class="ruby-operator">|</span>
          [<span class="ruby-value">:composer_id</span>, <span class="ruby-value">:arranger_id</span>, <span class="ruby-value">:vocalist_id</span>, <span class="ruby-value">:lyricist_id</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span>
            <span class="ruby-identifier">recs</span> = <span class="ruby-identifier">h</span>[<span class="ruby-identifier">song</span>.<span class="ruby-identifier">values</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">x</span>)]
            <span class="ruby-identifier">recs</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-value">:songs</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">song</span>} <span class="ruby-keyword">if</span> <span class="ruby-identifier">recs</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">eo</span>[<span class="ruby-value">:rows</span>].<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-value">:songs</span>].<span class="ruby-identifier">uniq!</span>}
    <span class="ruby-keyword">end</span>)
<span class="ruby-keyword">end</span>
</pre>

<h3 id="label-Statistics+Associations+-28Sum+of+Associated+Table+Column-29">Statistics Associations (Sum of Associated Table Column)<span><a href="#label-Statistics+Associations+-28Sum+of+Associated+Table+Column-29">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>In addition to getting associated records, you can use Sequel’s association support to get aggregate information for columns in associated tables (sums, averages, etc.).</p>

<p>Let’s say you have a database with projects and tickets.  A project can have many tickets, and each ticket has a number of hours associated with it.  You can use the association support to create a Project association that gives the sum of hours for all associated tickets.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Project</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>
  <span class="ruby-identifier">one_to_many</span> <span class="ruby-value">:tickets</span>
  <span class="ruby-identifier">many_to_one</span> <span class="ruby-value">:ticket_hours</span>, <span class="ruby-value">read_only:</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">key:</span> <span class="ruby-value">:id</span>,
   <span class="ruby-value">dataset:</span> <span class="ruby-identifier">proc</span>{<span class="ruby-constant">Ticket</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">:project_id</span><span class="ruby-operator">=&gt;</span><span class="ruby-identifier">id</span>).<span class="ruby-identifier">select</span>{<span class="ruby-identifier">sum</span>(<span class="ruby-identifier">hours</span>).<span class="ruby-identifier">as</span>(<span class="ruby-identifier">hours</span>)}},
   <span class="ruby-value">eager_loader:</span> (<span class="ruby-identifier">lambda</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">eo</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">eo</span>[<span class="ruby-value">:rows</span>].<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">p</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-value">:ticket_hours</span>] = <span class="ruby-keyword">nil</span>}
    <span class="ruby-constant">Ticket</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">project_id:</span> <span class="ruby-identifier">eo</span>[<span class="ruby-value">:id_map</span>].<span class="ruby-identifier">keys</span>).
     <span class="ruby-identifier">select_group</span>(<span class="ruby-value">:project_id</span>).
     <span class="ruby-identifier">select_append</span>{<span class="ruby-identifier">sum</span>(<span class="ruby-identifier">hours</span>).<span class="ruby-identifier">as</span>(<span class="ruby-identifier">hours</span>)}.
     <span class="ruby-identifier">all</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">t</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">p</span> = <span class="ruby-identifier">eo</span>[<span class="ruby-value">:id_map</span>][<span class="ruby-identifier">t</span>.<span class="ruby-identifier">values</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:project_id</span>)].<span class="ruby-identifier">first</span>
      <span class="ruby-identifier">p</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-value">:ticket_hours</span>] = <span class="ruby-identifier">t</span>
     <span class="ruby-keyword">end</span>
   <span class="ruby-keyword">end</span>)
  <span class="ruby-comment"># The association method returns a Ticket object with a single aggregate</span>
  <span class="ruby-comment"># sum-of-hours value, but you want it to return an Integer/Float of just the</span>
  <span class="ruby-comment"># sum of hours, so you call super and return just the sum-of-hours value.</span>
  <span class="ruby-comment"># This works for both lazy loading and eager loading.</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ticket_hours</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">s</span> = <span class="ruby-keyword">super</span>
      <span class="ruby-identifier">s</span>[<span class="ruby-value">:hours</span>]
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">Ticket</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>
  <span class="ruby-identifier">many_to_one</span> <span class="ruby-value">:project</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Note that it is often better to use a sum cache instead of this approach.  You can implement a sum cache using <code>after_create</code>, <code>after_update</code>, and <code>after_delete</code> hooks, or preferably using a database trigger.</p>
</div>
<div id='context'>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/jeremyevans/hanna-nouveau"><strong>Hanna Nouveau</strong> RDoc template</a>
</div>
</body>
</html>
