Sequel.require 'adapters/jdbc/transactions'

module Sequel
  module JDBC
    # Database and Dataset support for HSQLDB databases accessed via JDBC.
    module HSQLDB
      # Instance methods for HSQLDB Database objects accessed via JDBC.
      module DatabaseMethods
        include ::Sequel::JDBC::Transactions

        # HSQLDB uses the :h2 database type.
        def database_type
          :hsqldb
        end

        # Return Sequel::JDBC::HSQLDB::Dataset object with the given opts.
        def dataset(opts=nil)
          Sequel::JDBC::HSQLDB::Dataset.new(self, opts)
        end

        # HSQLDB uses an IDENTITY type
        def serial_primary_key_options
          {:primary_key => true, :type => :integer, :identity=>true, :start_with=>1}
        end

        def server_version
          @server_version ||= get{DATABASE_VERSION(){}}
        end
        
        private
        
        def alter_table_sql(table, op)
          case op[:op]
          when :rename_column
            "ALTER TABLE #{quote_schema_table(table)} ALTER COLUMN #{quote_identifier(op[:name])} RENAME TO #{quote_identifier(op[:new_name])}"
          when :set_column_type
            "ALTER TABLE #{quote_schema_table(table)} ALTER COLUMN #{quote_identifier(op[:name])} SET DATA TYPE #{type_literal(op)}"
          when :set_column_null
            "ALTER TABLE #{quote_schema_table(table)} ALTER COLUMN #{quote_identifier(op[:name])} SET #{op[:null] ? 'NULL' : 'NOT NULL'}"
          else
            super
          end
        end

        # Use IDENTITY() to get the last inserted id.
        def last_insert_id(conn, opts={})
          statement(conn) do |stmt|
            sql = 'CALL IDENTITY()'
            rs = log_yield(sql){stmt.executeQuery(sql)}
            rs.next
            rs.getInt(1)
          end
        end

        def type_literal(column)
          if column[:identity]
            sql = "#{super} GENERATED BY DEFAULT AS IDENTITY"
            if sw = column[:start_with]
              sql << " (START WITH #{sw.to_i}"
              sql << " INCREMENT BY #{column[:increment_by].to_i}" if column[:increment_by]
              sql << ")"
            end
            sql
          else
            super
          end
        end
      end
      
      # Dataset class for HSQLDB datasets accessed via JDBC.
      class Dataset < JDBC::Dataset
        BITWISE_METHOD_MAP = {:& =>:BITAND, :| => :BITOR, :^ => :BITXOR}
        BOOL_TRUE = 'TRUE'.freeze
        BOOL_FALSE = 'FALSE'.freeze
        SELECT_CLAUSE_METHODS = clause_methods(:select, %w'distinct columns from join where group having compounds order limit')

        # Handle HSQLDB specific LIKE and bitwise operator support, and
        # emulate the extract method, which DB2 doesn't natively support.
        def complex_expression_sql(op, args)
          case op
          when :ILIKE
            super(:LIKE, [SQL::Function.new(:ucase, args.at(0)), SQL::Function.new(:ucase, args.at(1)) ])
          when :"NOT ILIKE"
            super(:"NOT LIKE", [SQL::Function.new(:ucase, args.at(0)), SQL::Function.new(:ucase, args.at(1)) ])
          when :&, :|, :^
            op = BITWISE_METHOD_MAP[op]
            complex_expression_arg_pairs(args){|a, b| literal(SQL::Function.new(op, a, b))}
          when :<<
            complex_expression_arg_pairs(args){|a, b| "(#{literal(a)} * POWER(2, #{literal(b)}))"}
          when :>>
            complex_expression_arg_pairs(args){|a, b| "(#{literal(a)} / POWER(2, #{literal(b)}))"}
          when :'B~'
            "((0 - #{literal(args.at(0))}) - 1)"
          else
            super
          end
        end

        def supports_is_true?
          false
        end

        private

        # Use string in hex format for blob data.
        def literal_blob(v)
          blob = "X'"
          v.each_byte{|x| blob << sprintf('%02x', x)}
          blob << "'"
          blob
        end

        def literal_false
          BOOL_FALSE
        end

        # HSQLDB handles fractional seconds in timestamps, but not in times
        def literal_sqltime(v)
          v.strftime("'%H:%M:%S'")
        end

        def literal_true
          BOOL_TRUE
        end

        def select_clause_methods
          SELECT_CLAUSE_METHODS
        end

        # Use a default FROM table if the dataset does not contain a FROM table.
        def select_from_sql(sql)
          if @opts[:from]
            super
          else
            sql << " FROM (VALUES (0))"
          end
        end
      end
    end
  end
end
