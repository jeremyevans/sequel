<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>Sequel::Postgres::Database</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      function popupCode(url) {
        window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
      }
      
      function toggleCode(id) {
        var code = document.getElementById(id)
      
        code.style.display = code.style.display != 'block' ? 'block' : 'none'
        return true
      }
      
      // Make codeblocks hidden by default
      document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
    </script>
  </head>
  <body class='page'>
    <div class='class' id='wrapper'>
      <div class='header'>
        <h1 class='name'>
          <span class='type'>class</span>
          Sequel::Postgres::Database
        </h1>
        <ol class='paths'>
          <li>
            <a target="docwin" href="../../../files/lib/sequel/adapters/postgres_rb.html">lib/sequel/adapters/postgres.rb</a>
          </li>
        </ol>
        <div class='parent'>
          Superclass:
          <strong>Sequel::Database</strong>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <p><a href="Database.html">Database</a> class for PostgreSQL databases used
            with <a href="../../Sequel.html">Sequel</a> and the pg, postgres, or
            postgres-pr driver.</p>
          </div>
          <div id='method-list'>
            <h2>Methods</h2>
            <h3>Public Instance</h3>
            <ol>
              <li><a target="docwin" href="#method-i-bound_variable_arg">bound_variable_arg</a></li>
              <li><a target="docwin" href="#method-i-connect">connect</a></li>
              <li><a target="docwin" href="#attribute-i-convert_infinite_timestamps">convert_infinite_timestamps</a></li>
              <li><a target="docwin" href="#method-i-convert_infinite_timestamps-3D">convert_infinite_timestamps=</a></li>
              <li><a target="docwin" href="#method-i-copy_into">copy_into</a></li>
              <li><a target="docwin" href="#method-i-copy_table">copy_table</a></li>
              <li><a target="docwin" href="#method-i-disconnect_connection">disconnect_connection</a></li>
              <li><a target="docwin" href="#method-i-error_info">error_info</a></li>
              <li><a target="docwin" href="#method-i-execute">execute</a></li>
              <li><a target="docwin" href="#method-i-listen">listen</a></li>
              <li><a target="docwin" href="#method-i-to_application_timestamp">to_application_timestamp</a></li>
            </ol>
          </div>
          <div id='context'>
            <div id='includes'>
              <h2>Included modules</h2>
              <ol>
                <li><a target="docwin" href="DatabaseMethods.html">Sequel::Postgres::DatabaseMethods</a></li>
              </ol>
            </div>
          </div>
          <div id='class-list'>
            <h2>Classes and Modules</h2>
            <ol>
              <li><a target="docwin" href="Database/PG.html">Sequel::Postgres::Database::PG</a></li>
            </ol>
          </div>
          <div id='section'>
            <div id='constants-list'>
              <h2>Constants</h2>
              <div class='name-list'>
                <table summary='Constants'>
                  <tr class='top-aligned-row context-row'>
                    <td class='context-item-name'>DatasetClass</td>
                    <td>=</td>
                    <td class='context-item-value'>self</td>
                    <td>&nbsp;</td>
                    <td class='context-item-desc'></td>
                  </tr>
                  <tr class='top-aligned-row context-row'>
                    <td class='context-item-name'>INFINITE_DATETIME_VALUES</td>
                    <td>=</td>
                    <td class='context-item-value'>([PLUS_INFINITY, MINUS_INFINITY] + INFINITE_TIMESTAMP_STRINGS).freeze</td>
                    <td>&nbsp;</td>
                    <td class='context-item-desc'></td>
                  </tr>
                  <tr class='top-aligned-row context-row'>
                    <td class='context-item-name'>INFINITE_TIMESTAMP_STRINGS</td>
                    <td>=</td>
                    <td class='context-item-value'>['infinity'.freeze, '-infinity'.freeze].freeze</td>
                    <td>&nbsp;</td>
                    <td class='context-item-desc'></td>
                  </tr>
                </table>
              </div>
            </div>
            <div id='attribute-list'>
              <h2 class='section-bar'>Attributes</h2>
              <div class='name-list'>
                <table>
                  <tr class='top-aligned-row context-row'>
                    <td class='context-item-name'>
                      <a name='attribute-i-convert_infinite_timestamps'>convert_infinite_timestamps</a>
                    </td>
                    <td class='context-item-value'>[R]</td>
                    <td class='context-item-desc'>
                      
                      <p>Whether infinite timestamps/dates should be converted on retrieval.  By
                      default, no conversion is done, so an error is raised if you attempt to
                      retrieve an infinite timestamp/date.  You can set this to :nil to convert
                      to nil, :string to leave as a string, or :float to convert to an infinite
                      float.</p>
                    </td>
                  </tr>
                </table>
              </div>
            </div>
            <div id='methods'>
              <h2>Public Instance methods</h2>
              <div class='method public-instance' id='method-method-i-bound_variable_arg'>
                <a name='method-i-bound_variable_arg'></a>
                <div class='synopsis'>
                  <span class='name'>bound_variable_arg</span>
                  <span class='arguments'>(arg, conn)</span>
                </div>
                <div class='description'>
                  
                  <p>Convert given argument so that it can be used directly by pg.  Currently,
                  pg doesn&#39;t handle fractional seconds in Time/DateTime or blobs with
                  “0”, and it won&#39;t ever handle Sequel::SQLTime values correctly.  Only
                  public for use by the adapter, shouldn&#39;t be used by external code.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-bound_variable_arg-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-bound_variable_arg-source'><span class="ruby-comment"># File lib/sequel/adapters/postgres.rb, line 211</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">bound_variable_arg</span>(<span class="ruby-identifier">arg</span>, <span class="ruby-identifier">conn</span>)&#x000A;  <span class="ruby-keyword">case</span> <span class="ruby-identifier">arg</span>&#x000A;  <span class="ruby-keyword">when</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Blob</span>&#x000A;    {<span class="ruby-value">:value=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">arg</span>, <span class="ruby-value">:type=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">17</span>, <span class="ruby-value">:format=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>}&#x000A;  <span class="ruby-keyword">when</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQLTime</span>&#x000A;    <span class="ruby-identifier">literal</span>(<span class="ruby-identifier">arg</span>)&#x000A;  <span class="ruby-keyword">when</span> <span class="ruby-constant">DateTime</span>, <span class="ruby-constant">Time</span>&#x000A;    <span class="ruby-identifier">literal</span>(<span class="ruby-identifier">arg</span>)&#x000A;  <span class="ruby-keyword">else</span>&#x000A;    <span class="ruby-identifier">arg</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
              <div class='method public-instance' id='method-method-i-connect'>
                <a name='method-i-connect'></a>
                <div class='synopsis'>
                  <span class='name'>connect</span>
                  <span class='arguments'>(server)</span>
                </div>
                <div class='description'>
                  
                  <p>Connects to the database.  In addition to the standard database options,
                  using the :encoding or :charset option changes the client encoding for the
                  connection, :connect_timeout is a connection timeout in seconds, :sslmode
                  sets whether postgres&#39;s sslmode, and :notice_receiver handles server
                  notices in a proc. :connect_timeout, :driver_options, :sslmode, and
                  :notice_receiver are only supported if the pg driver is used.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-connect-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-connect-source'><span class="ruby-comment"># File lib/sequel/adapters/postgres.rb, line 231</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">connect</span>(<span class="ruby-identifier">server</span>)&#x000A;  <span class="ruby-identifier">opts</span> = <span class="ruby-identifier">server_opts</span>(<span class="ruby-identifier">server</span>)&#x000A;  <span class="ruby-keyword">if</span> <span class="ruby-constant">SEQUEL_POSTGRES_USES_PG</span>&#x000A;    <span class="ruby-identifier">connection_params</span> = {&#x000A;      <span class="ruby-value">:host</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:host</span>],&#x000A;      <span class="ruby-value">:port</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:port</span>] <span class="ruby-operator">||</span> <span class="ruby-value">5432</span>,&#x000A;      <span class="ruby-value">:dbname</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:database</span>],&#x000A;      <span class="ruby-value">:user</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:user</span>],&#x000A;      <span class="ruby-value">:password</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:password</span>],&#x000A;      <span class="ruby-value">:connect_timeout</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:connect_timeout</span>] <span class="ruby-operator">||</span> <span class="ruby-value">20</span>,&#x000A;      <span class="ruby-value">:sslmode</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:sslmode</span>]&#x000A;    }.<span class="ruby-identifier">delete_if</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">blank_object?</span>(<span class="ruby-identifier">value</span>) }&#x000A;    <span class="ruby-identifier">connection_params</span>.<span class="ruby-identifier">merge!</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:driver_options</span>]) <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:driver_options</span>]&#x000A;    <span class="ruby-identifier">conn</span> = <span class="ruby-constant">Adapter</span>.<span class="ruby-identifier">connect</span>(<span class="ruby-identifier">connection_params</span>)&#x000A;&#x000A;    <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">instance_variable_set</span>(<span class="ruby-value">:@prepared_statements</span>, {})&#x000A;&#x000A;    <span class="ruby-keyword">if</span> <span class="ruby-identifier">receiver</span> = <span class="ruby-identifier">opts</span>[<span class="ruby-value">:notice_receiver</span>]&#x000A;      <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">set_notice_receiver</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">receiver</span>)&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">else</span>&#x000A;    <span class="ruby-identifier">conn</span> = <span class="ruby-constant">Adapter</span>.<span class="ruby-identifier">connect</span>(&#x000A;      (<span class="ruby-identifier">opts</span>[<span class="ruby-value">:host</span>] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">blank_object?</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:host</span>])),&#x000A;      <span class="ruby-identifier">opts</span>[<span class="ruby-value">:port</span>] <span class="ruby-operator">||</span> <span class="ruby-value">5432</span>,&#x000A;      <span class="ruby-keyword">nil</span>, <span class="ruby-string">&#39;&#39;</span>,&#x000A;      <span class="ruby-identifier">opts</span>[<span class="ruby-value">:database</span>],&#x000A;      <span class="ruby-identifier">opts</span>[<span class="ruby-value">:user</span>],&#x000A;      <span class="ruby-identifier">opts</span>[<span class="ruby-value">:password</span>]&#x000A;    )&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">instance_variable_set</span>(<span class="ruby-value">:@db</span>, <span class="ruby-keyword">self</span>)&#x000A;&#x000A;  <span class="ruby-keyword">if</span> <span class="ruby-identifier">encoding</span> = <span class="ruby-identifier">opts</span>[<span class="ruby-value">:encoding</span>] <span class="ruby-operator">||</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:charset</span>]&#x000A;    <span class="ruby-keyword">if</span> <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:set_client_encoding</span>)&#x000A;      <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">set_client_encoding</span>(<span class="ruby-identifier">encoding</span>)&#x000A;    <span class="ruby-keyword">else</span>&#x000A;      <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">async_exec</span>(<span class="ruby-node">&quot;set client_encoding to &#39;#{encoding}&#39;&quot;</span>)&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-identifier">connection_configuration_sqls</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">sql</span><span class="ruby-operator">|</span> <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">execute</span>(<span class="ruby-identifier">sql</span>)}&#x000A;  <span class="ruby-identifier">conn</span>&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
              <div class='method public-instance' id='method-method-i-convert_infinite_timestamps-3D'>
                <a name='method-i-convert_infinite_timestamps-3D'></a>
                <div class='synopsis'>
                  <span class='name'>convert_infinite_timestamps=</span>
                  <span class='arguments'>(v)</span>
                </div>
                <div class='description'>
                  
                  <p>Set whether to allow infinite timestamps/dates.  Make sure the conversion
                  proc for date reflects that setting.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-convert_infinite_timestamps-3D-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-convert_infinite_timestamps-3D-source'><span class="ruby-comment"># File lib/sequel/adapters/postgres.rb, line 278</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">convert_infinite_timestamps=</span>(<span class="ruby-identifier">v</span>)&#x000A;  <span class="ruby-ivar">@convert_infinite_timestamps</span> = <span class="ruby-keyword">case</span> <span class="ruby-identifier">v</span>&#x000A;  <span class="ruby-keyword">when</span> <span class="ruby-constant">Symbol</span>&#x000A;    <span class="ruby-identifier">v</span>&#x000A;  <span class="ruby-keyword">when</span> <span class="ruby-string">&#39;nil&#39;</span>&#x000A;    <span class="ruby-value">:nil</span>&#x000A;  <span class="ruby-keyword">when</span> <span class="ruby-string">&#39;string&#39;</span>&#x000A;    <span class="ruby-value">:string</span>&#x000A;  <span class="ruby-keyword">when</span> <span class="ruby-string">&#39;float&#39;</span>&#x000A;    <span class="ruby-value">:float</span>&#x000A;  <span class="ruby-keyword">when</span> <span class="ruby-constant">String</span>&#x000A;    <span class="ruby-identifier">typecast_value_boolean</span>(<span class="ruby-identifier">v</span>)&#x000A;  <span class="ruby-keyword">else</span>&#x000A;    <span class="ruby-keyword">false</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-identifier">pr</span> = <span class="ruby-identifier">old_pr</span> = <span class="ruby-ivar">@use_iso_date_format</span> <span class="ruby-operator">?</span> <span class="ruby-constant">TYPE_TRANSLATOR</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:date</span>) <span class="ruby-operator">:</span> <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:string_to_date</span>)&#x000A;  <span class="ruby-keyword">if</span> <span class="ruby-identifier">v</span>&#x000A;    <span class="ruby-identifier">pr</span> = <span class="ruby-identifier">lambda</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">val</span><span class="ruby-operator">|</span>&#x000A;      <span class="ruby-keyword">case</span> <span class="ruby-identifier">val</span>&#x000A;      <span class="ruby-keyword">when</span> <span class="ruby-operator">*</span><span class="ruby-constant">INFINITE_TIMESTAMP_STRINGS</span>&#x000A;        <span class="ruby-identifier">infinite_timestamp_value</span>(<span class="ruby-identifier">val</span>)&#x000A;      <span class="ruby-keyword">else</span>&#x000A;        <span class="ruby-identifier">old_pr</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">val</span>)&#x000A;      <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-identifier">conversion_procs</span>[<span class="ruby-value">1082</span>] = <span class="ruby-identifier">pr</span>&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
              <div class='method public-instance' id='method-method-i-copy_into'>
                <a name='method-i-copy_into'></a>
                <div class='synopsis'>
                  <span class='name'>copy_into</span>
                  <span class='arguments'>(table, opts=OPTS)</span>
                </div>
                <div class='description'>
                  
                  <p><code>copy_into</code> uses PostgreSQL&#39;s +COPY FROM STDIN+ <a
                  href="../SQL.html">SQL</a> statement to do very fast inserts  into a table
                  using input preformatting in either CSV or PostgreSQL text format. This
                  method is only supported if pg 0.14.0+ is the underlying ruby driver. This
                  method should only be called if you want results returned to the client. 
                  If you are using +COPY FROM+ with a filename, you should just use
                  <code>run</code> instead of this method.</p>
                  
                  <p>The following options are respected:</p>
                  <table class="rdoc-list note-list"><tbody><tr><td class='label'>:columns </td><td>
                  <p>The columns to insert into, with the same order as the columns in the input
                  data.  If this isn&#39;t given, uses all columns in the table.</p>
                  </td></tr><tr><td class='label'>:data </td><td>
                  <p>The data to copy to PostgreSQL, which should already be in CSV or
                  PostgreSQL text format.  This can be either a string, or any object that
                  responds to each and yields string.</p>
                  </td></tr><tr><td class='label'>:format </td><td>
                  <p>The format to use.  text is the default, so this should be :csv or :binary.</p>
                  </td></tr><tr><td class='label'>:options </td><td>
                  <p>An options <a href="../SQL.html">SQL</a> string to use, which should
                  contain comma separated options.</p>
                  </td></tr><tr><td class='label'>:server </td><td>
                  <p>The server on which to run the query.</p>
                  </td></tr></tbody></table>
                  
                  <p>If a block is provided and :data option is not, this will yield to the
                  block repeatedly. The block should return a string, or nil to signal that
                  it is finished.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-copy_into-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-copy_into-source'><span class="ruby-comment"># File lib/sequel/adapters/postgres.rb, line 410</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">copy_into</span>(<span class="ruby-identifier">table</span>, <span class="ruby-identifier">opts</span>=<span class="ruby-constant">OPTS</span>)&#x000A;  <span class="ruby-identifier">data</span> = <span class="ruby-identifier">opts</span>[<span class="ruby-value">:data</span>]&#x000A;  <span class="ruby-identifier">data</span> = <span class="ruby-constant">Array</span>(<span class="ruby-identifier">data</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">data</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">String</span>)&#x000A;&#x000A;  <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">data</span>&#x000A;    <span class="ruby-identifier">raise</span> <span class="ruby-constant">Error</span>, <span class="ruby-string">&quot;Cannot provide both a :data option and a block to copy_into&quot;</span>&#x000A;  <span class="ruby-keyword">elsif</span> <span class="ruby-operator">!</span><span class="ruby-identifier">block_given?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">data</span>&#x000A;    <span class="ruby-identifier">raise</span> <span class="ruby-constant">Error</span>, <span class="ruby-string">&quot;Must provide either a :data option or a block to copy_into&quot;</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-identifier">synchronize</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:server</span>]) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">conn</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">execute</span>(<span class="ruby-identifier">copy_into_sql</span>(<span class="ruby-identifier">table</span>, <span class="ruby-identifier">opts</span>))&#x000A;    <span class="ruby-keyword">begin</span>&#x000A;      <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>&#x000A;        <span class="ruby-keyword">while</span> <span class="ruby-identifier">buf</span> = <span class="ruby-keyword">yield</span>&#x000A;          <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">put_copy_data</span>(<span class="ruby-identifier">buf</span>)&#x000A;        <span class="ruby-keyword">end</span>&#x000A;      <span class="ruby-keyword">else</span>&#x000A;        <span class="ruby-identifier">data</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">buff</span><span class="ruby-operator">|</span> <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">put_copy_data</span>(<span class="ruby-identifier">buff</span>)}&#x000A;      <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-keyword">rescue</span> <span class="ruby-constant">Exception</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">e</span>&#x000A;      <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">put_copy_end</span>(<span class="ruby-string">&quot;ruby exception occurred while copying data into PostgreSQL&quot;</span>)&#x000A;    <span class="ruby-keyword">ensure</span>&#x000A;      <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">put_copy_end</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">e</span>&#x000A;      <span class="ruby-keyword">while</span> <span class="ruby-identifier">res</span> = <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">get_result</span>&#x000A;        <span class="ruby-identifier">raise</span> <span class="ruby-identifier">e</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">e</span>&#x000A;        <span class="ruby-identifier">check_database_errors</span>{<span class="ruby-identifier">res</span>.<span class="ruby-identifier">check</span>}&#x000A;      <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span> &#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
              <div class='method public-instance' id='method-method-i-copy_table'>
                <a name='method-i-copy_table'></a>
                <div class='synopsis'>
                  <span class='name'>copy_table</span>
                  <span class='arguments'>(table, opts=OPTS)</span>
                </div>
                <div class='description'>
                  
                  <p><code>copy_table</code> uses PostgreSQL&#39;s +COPY TO STDOUT+ <a
                  href="../SQL.html">SQL</a> statement to return formatted results directly
                  to the caller.  This method is only supported if pg is the underlying ruby
                  driver.  This method should only be called if you want results returned to
                  the client.  If you are using +COPY TO+ with a filename, you should just
                  use <code>run</code> instead of this method.</p>
                  
                  <p>The table argument supports the following types:</p>
                  <table class="rdoc-list note-list"><tbody><tr><td class='label'>String </td><td>
                  <p>Uses the first argument directly as literal <a href="../SQL.html">SQL</a>.
                  If you are using a version of PostgreSQL before 9.0, you will probably want
                  to use a string if you are using any options at all, as the syntax <a
                  href="../../Sequel.html">Sequel</a> uses for options is only compatible
                  with PostgreSQL 9.0+.</p>
                  </td></tr><tr><td class='label'><a href="Dataset.html">Dataset</a> </td><td>
                  <p>Uses a query instead of a table name when copying.</p>
                  </td></tr><tr><td class='label'>other </td><td>
                  <p>Uses a table name (usually a symbol) when copying.</p>
                  </td></tr></tbody></table>
                  
                  <p>The following options are respected:</p>
                  <table class="rdoc-list note-list"><tbody><tr><td class='label'>:format </td><td>
                  <p>The format to use.  text is the default, so this should be :csv or :binary.</p>
                  </td></tr><tr><td class='label'>:options </td><td>
                  <p>An options <a href="../SQL.html">SQL</a> string to use, which should
                  contain comma separated options.</p>
                  </td></tr><tr><td class='label'>:server </td><td>
                  <p>The server on which to run the query.</p>
                  </td></tr></tbody></table>
                  
                  <p>If a block is provided, the method continually yields to the block, one
                  yield per row.  If a block is not provided, a single string is returned
                  with all of the data.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-copy_table-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-copy_table-source'><span class="ruby-comment"># File lib/sequel/adapters/postgres.rb, line 370</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">copy_table</span>(<span class="ruby-identifier">table</span>, <span class="ruby-identifier">opts</span>=<span class="ruby-constant">OPTS</span>)&#x000A;  <span class="ruby-identifier">synchronize</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:server</span>]) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">conn</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">execute</span>(<span class="ruby-identifier">copy_table_sql</span>(<span class="ruby-identifier">table</span>, <span class="ruby-identifier">opts</span>))&#x000A;    <span class="ruby-keyword">begin</span>&#x000A;      <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>&#x000A;        <span class="ruby-keyword">while</span> <span class="ruby-identifier">buf</span> = <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">get_copy_data</span>&#x000A;          <span class="ruby-keyword">yield</span> <span class="ruby-identifier">buf</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;        <span class="ruby-keyword">nil</span>&#x000A;      <span class="ruby-keyword">else</span>&#x000A;        <span class="ruby-identifier">b</span> = <span class="ruby-constant">String</span>.<span class="ruby-identifier">new</span>&#x000A;        <span class="ruby-identifier">b</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">buf</span> <span class="ruby-keyword">while</span> <span class="ruby-identifier">buf</span> = <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">get_copy_data</span>&#x000A;        <span class="ruby-identifier">b</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-keyword">ensure</span>&#x000A;      <span class="ruby-identifier">raise</span> <span class="ruby-constant">DatabaseDisconnectError</span>, <span class="ruby-string">&quot;disconnecting as a partial COPY may leave the connection in an unusable state&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">buf</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span> &#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
              <div class='method public-instance' id='method-method-i-disconnect_connection'>
                <a name='method-i-disconnect_connection'></a>
                <div class='synopsis'>
                  <span class='name'>disconnect_connection</span>
                  <span class='arguments'>(conn)</span>
                </div>
                <div class='description'>
                  
                  <p>Disconnect given connection</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-disconnect_connection-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-disconnect_connection-source'><span class="ruby-comment"># File lib/sequel/adapters/postgres.rb, line 309</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">disconnect_connection</span>(<span class="ruby-identifier">conn</span>)&#x000A;  <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">finish</span>&#x000A;<span class="ruby-keyword">rescue</span> <span class="ruby-constant">PGError</span>, <span class="ruby-constant">IOError</span>&#x000A;  <span class="ruby-keyword">nil</span>&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
              <div class='method public-instance' id='method-method-i-error_info'>
                <a name='method-i-error_info'></a>
                <div class='synopsis'>
                  <span class='name'>error_info</span>
                  <span class='arguments'>(e)</span>
                </div>
                <div class='description'>
                  
                  <p>Return a hash of information about the related PGError (or
                  Sequel::DatabaseError that wraps a PGError), with the following entries:</p>
                  <table class="rdoc-list note-list"><tbody><tr><td class='label'>:schema </td><td>
                  <p>The schema name related to the error</p>
                  </td></tr><tr><td class='label'>:table </td><td>
                  <p>The table name related to the error</p>
                  </td></tr><tr><td class='label'>:column </td><td>
                  <p>the column name related to the error</p>
                  </td></tr><tr><td class='label'>:constraint </td><td>
                  <p>The constraint name related to the error</p>
                  </td></tr><tr><td class='label'>:type </td><td>
                  <p>The datatype name related to the error</p>
                  </td></tr></tbody></table>
                  
                  <p>This requires a PostgreSQL 9.3+ server and 9.3+ client library, and ruby-pg
                  0.16.0+ to be supported.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-error_info-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-error_info-source'><span class="ruby-comment"># File lib/sequel/adapters/postgres.rb, line 327</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">error_info</span>(<span class="ruby-identifier">e</span>)&#x000A;  <span class="ruby-identifier">e</span> = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">wrapped_exception</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">DatabaseError</span>)&#x000A;  <span class="ruby-identifier">r</span> = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">result</span>&#x000A;  <span class="ruby-identifier">h</span> = {}&#x000A;  <span class="ruby-identifier">h</span>[<span class="ruby-value">:schema</span>] = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">error_field</span>(<span class="ruby-operator">::</span><span class="ruby-constant">PG</span><span class="ruby-operator">::</span><span class="ruby-constant">PG_DIAG_SCHEMA_NAME</span>)&#x000A;  <span class="ruby-identifier">h</span>[<span class="ruby-value">:table</span>] = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">error_field</span>(<span class="ruby-operator">::</span><span class="ruby-constant">PG</span><span class="ruby-operator">::</span><span class="ruby-constant">PG_DIAG_TABLE_NAME</span>)&#x000A;  <span class="ruby-identifier">h</span>[<span class="ruby-value">:column</span>] = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">error_field</span>(<span class="ruby-operator">::</span><span class="ruby-constant">PG</span><span class="ruby-operator">::</span><span class="ruby-constant">PG_DIAG_COLUMN_NAME</span>)&#x000A;  <span class="ruby-identifier">h</span>[<span class="ruby-value">:constraint</span>] = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">error_field</span>(<span class="ruby-operator">::</span><span class="ruby-constant">PG</span><span class="ruby-operator">::</span><span class="ruby-constant">PG_DIAG_CONSTRAINT_NAME</span>)&#x000A;  <span class="ruby-identifier">h</span>[<span class="ruby-value">:type</span>] = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">error_field</span>(<span class="ruby-operator">::</span><span class="ruby-constant">PG</span><span class="ruby-operator">::</span><span class="ruby-constant">PG_DIAG_DATATYPE_NAME</span>)&#x000A;  <span class="ruby-identifier">h</span>&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
              <div class='method public-instance' id='method-method-i-execute'>
                <a name='method-i-execute'></a>
                <div class='synopsis'>
                  <span class='name'>execute</span>
                  <span class='arguments'>(sql, opts=OPTS, &block)</span>
                </div>
                <div class='description'>
                  
                  <p>Execute the given <a href="../SQL.html">SQL</a> with the given args on an
                  available connection.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-execute-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-execute-source'><span class="ruby-comment"># File lib/sequel/adapters/postgres.rb, line 341</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">execute</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">opts</span>=<span class="ruby-constant">OPTS</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)&#x000A;  <span class="ruby-identifier">synchronize</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:server</span>]){<span class="ruby-operator">|</span><span class="ruby-identifier">conn</span><span class="ruby-operator">|</span> <span class="ruby-identifier">check_database_errors</span>{<span class="ruby-identifier">_execute</span>(<span class="ruby-identifier">conn</span>, <span class="ruby-identifier">sql</span>, <span class="ruby-identifier">opts</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)}}&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
              <div class='method public-instance' id='method-method-i-listen'>
                <a name='method-i-listen'></a>
                <div class='synopsis'>
                  <span class='name'>listen</span>
                  <span class='arguments'>(channels, opts=OPTS, &block)</span>
                </div>
                <div class='description'>
                  
                  <p>Listens on the given channel (or multiple channels if channel is an array),
                  waiting for notifications. After a notification is received, or the timeout
                  has passed, stops listening to the channel. Options:</p>
                  <table class="rdoc-list note-list"><tbody><tr><td class='label'>:after_listen </td><td>
                  <p>An object that responds to <code>call</code> that is called with the
                  underlying connection after the LISTEN statement is sent, but before the
                  connection starts waiting for notifications.</p>
                  </td></tr><tr><td class='label'>:loop </td><td>
                  <p>Whether to continually wait for notifications, instead of just waiting for
                  a single notification. If this option is given, a block must be provided. 
                  If this object responds to <code>call</code>, it is called with the
                  underlying connection after each notification is received (after the block
                  is called). If a :timeout option is used, and a callable object is given,
                  the object will also be called if the timeout expires.  If :loop is used
                  and you want to stop listening, you can either break from inside the block
                  given to <a href="Database.html#method-i-listen">listen</a>, or you can
                  throw :stop from inside the :loop object&#39;s call method or the block.</p>
                  </td></tr><tr><td class='label'>:server </td><td>
                  <p>The server on which to listen, if the sharding support is being used.</p>
                  </td></tr><tr><td class='label'>:timeout </td><td>
                  <p>How long to wait for a notification, in seconds (can provide a float value
                  for fractional seconds). If this object responds to <code>call</code>, it
                  will be called and should return the number of seconds to wait. If the loop
                  option is also specified, the object will be called on each iteration to
                  obtain a new timeout value.  If not given or nil, waits indefinitely.</p>
                  </td></tr></tbody></table>
                  
                  <p>This method is only supported if pg is used as the underlying ruby driver. 
                  It returns the channel the notification was sent to (as a string), unless
                  :loop was used, in which case it returns nil. If a block is given, it is
                  yielded 3 arguments:</p>
                  <ul><li>
                  <p>the channel the notification was sent to (as a string)</p>
                  </li><li>
                  <p>the backend pid of the notifier (as an integer),</p>
                  </li><li>
                  <p>and the payload of the notification (as a string or nil).</p>
                  </li></ul>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-listen-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-listen-source'><span class="ruby-comment"># File lib/sequel/adapters/postgres.rb, line 465</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">listen</span>(<span class="ruby-identifier">channels</span>, <span class="ruby-identifier">opts</span>=<span class="ruby-constant">OPTS</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)&#x000A;  <span class="ruby-identifier">check_database_errors</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">synchronize</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:server</span>]) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">conn</span><span class="ruby-operator">|</span>&#x000A;      <span class="ruby-keyword">begin</span>&#x000A;        <span class="ruby-identifier">channels</span> = <span class="ruby-constant">Array</span>(<span class="ruby-identifier">channels</span>)&#x000A;        <span class="ruby-identifier">channels</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">channel</span><span class="ruby-operator">|</span>&#x000A;          <span class="ruby-identifier">sql</span> = <span class="ruby-string">&quot;LISTEN &quot;</span>.<span class="ruby-identifier">dup</span>&#x000A;          <span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">send</span>(<span class="ruby-value">:identifier_append</span>, <span class="ruby-identifier">sql</span>, <span class="ruby-identifier">channel</span>)&#x000A;          <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">execute</span>(<span class="ruby-identifier">sql</span>)&#x000A;        <span class="ruby-keyword">end</span>&#x000A;        <span class="ruby-identifier">opts</span>[<span class="ruby-value">:after_listen</span>].<span class="ruby-identifier">call</span>(<span class="ruby-identifier">conn</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:after_listen</span>]&#x000A;        <span class="ruby-identifier">timeout</span> = <span class="ruby-identifier">opts</span>[<span class="ruby-value">:timeout</span>]&#x000A;        <span class="ruby-keyword">if</span> <span class="ruby-identifier">timeout</span>&#x000A;          <span class="ruby-identifier">timeout_block</span> = <span class="ruby-identifier">timeout</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:call</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">timeout</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">proc</span>{<span class="ruby-identifier">timeout</span>}&#x000A;        <span class="ruby-keyword">end</span>&#x000A;&#x000A;        <span class="ruby-keyword">if</span> <span class="ruby-identifier">l</span> = <span class="ruby-identifier">opts</span>[<span class="ruby-value">:loop</span>]&#x000A;          <span class="ruby-identifier">raise</span> <span class="ruby-constant">Error</span>, <span class="ruby-string">&#39;calling #listen with :loop requires a block&#39;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block</span>&#x000A;          <span class="ruby-identifier">loop_call</span> = <span class="ruby-identifier">l</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:call</span>)&#x000A;          <span class="ruby-identifier">catch</span>(<span class="ruby-value">:stop</span>) <span class="ruby-keyword">do</span>&#x000A;            <span class="ruby-identifier">loop</span> <span class="ruby-keyword">do</span>&#x000A;              <span class="ruby-identifier">t</span> = <span class="ruby-identifier">timeout_block</span> <span class="ruby-operator">?</span> [<span class="ruby-identifier">timeout_block</span>.<span class="ruby-identifier">call</span>] <span class="ruby-operator">:</span> []&#x000A;              <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">wait_for_notify</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">t</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)&#x000A;              <span class="ruby-identifier">l</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">conn</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">loop_call</span>&#x000A;            <span class="ruby-keyword">end</span>&#x000A;          <span class="ruby-keyword">end</span>&#x000A;          <span class="ruby-keyword">nil</span>&#x000A;        <span class="ruby-keyword">else</span>&#x000A;          <span class="ruby-identifier">t</span> = <span class="ruby-identifier">timeout_block</span> <span class="ruby-operator">?</span> [<span class="ruby-identifier">timeout_block</span>.<span class="ruby-identifier">call</span>] <span class="ruby-operator">:</span> []&#x000A;          <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">wait_for_notify</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">t</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)&#x000A;        <span class="ruby-keyword">end</span>&#x000A;      <span class="ruby-keyword">ensure</span>&#x000A;        <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">execute</span>(<span class="ruby-string">&quot;UNLISTEN *&quot;</span>)&#x000A;      <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
              <div class='method public-instance' id='method-method-i-to_application_timestamp'>
                <a name='method-i-to_application_timestamp'></a>
                <div class='synopsis'>
                  <span class='name'>to_application_timestamp</span>
                  <span class='arguments'>(value)</span>
                </div>
                <div class='description'>
                  
                  <p>If <a
                  href="Database.html#attribute-i-convert_infinite_timestamps">#convert_infinite_timestamps</a>
                  is true and the value is infinite, return an appropriate value based on the
                  <a
                  href="Database.html#attribute-i-convert_infinite_timestamps">#convert_infinite_timestamps</a>
                  setting.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-to_application_timestamp-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-to_application_timestamp-source'><span class="ruby-comment"># File lib/sequel/adapters/postgres.rb, line 506</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">to_application_timestamp</span>(<span class="ruby-identifier">value</span>)&#x000A;  <span class="ruby-keyword">if</span> <span class="ruby-identifier">convert_infinite_timestamps</span>&#x000A;    <span class="ruby-keyword">case</span> <span class="ruby-identifier">value</span>&#x000A;    <span class="ruby-keyword">when</span> <span class="ruby-operator">*</span><span class="ruby-constant">INFINITE_TIMESTAMP_STRINGS</span>&#x000A;      <span class="ruby-identifier">infinite_timestamp_value</span>(<span class="ruby-identifier">value</span>)&#x000A;    <span class="ruby-keyword">else</span>&#x000A;      <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">else</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="https://github.com/rdoc/hanna-nouveau"><strong>Hanna Nouveau</strong> RDoc template</a>
    </div>
  </body>
</html>
