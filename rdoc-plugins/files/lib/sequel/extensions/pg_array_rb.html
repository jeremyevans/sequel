<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>pg_array.rb</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../../../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='file' id='wrapper'>
      <div class='header'>
        <h1 class='name'>pg_array.rb</h1>
        <div class='paths'>
          lib/sequel/extensions/pg_array.rb
        </div>
        <div class='last-update'>
          Last Update:
          <span class='datetime'>2014-11-20 12:20:00 -0800</span>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <p>The pg_array extension adds support for <a
            href="../../../../classes/Sequel.html">Sequel</a> to handle
            PostgreSQL&#39;s array types.</p>
            
            <p>This extension integrates with Sequel&#39;s native postgres adapter and the
            jdbc/postgresql adapter, so that when array fields are retrieved, they are
            parsed and returned as instances of <a
            href="../../../../classes/Sequel/Postgres/PGArray.html">Sequel::Postgres::PGArray</a>.
            PGArray is a DelegateClass of <a
            href="../../../../classes/Array.html">Array</a>, so it mostly acts like an
            array, but not completely (is_a?(Array) is false).  If you want the actual
            array, you can call PGArray#to_a.  This is done so that <a
            href="../../../../classes/Sequel.html">Sequel</a> does not treat a PGArray
            like an <a href="../../../../classes/Array.html">Array</a> by default,
            which would cause issues.</p>
            
            <p>In addition to the parsers, this extension comes with literalizers for
            PGArray using the standard <a
            href="../../../../classes/Sequel.html">Sequel</a> literalization callbacks,
            so they work with on all adapters.</p>
            
            <p>To turn an existing <a href="../../../../classes/Array.html">Array</a> into
            a PGArray:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">pg_array</span>(<span class="ruby-identifier">array</span>)</pre>
            
            <p>If you have loaded the <a
            href="../../../doc/core_extensions_rdoc.html">core_extensions
            extension</a>, or you have loaded the core_refinements extension and have
            activated refinements for the file, you can also use <a
            href="../../../../classes/Array.html#method-i-pg_array">Array#pg_array</a>:</p>
            
            <pre class="ruby"><span class="ruby-identifier">array</span>.<span class="ruby-identifier">pg_array</span></pre>
            
            <p>You can also provide a type, though in many cases it isn&#39;t necessary:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">pg_array</span>(<span class="ruby-identifier">array</span>, :<span class="ruby-identifier">varchar</span>) <span class="ruby-comment"># or :integer, :&quot;double precision&quot;, etc.</span>&#x000A;<span class="ruby-identifier">array</span>.<span class="ruby-identifier">pg_array</span>(:<span class="ruby-identifier">varchar</span>) <span class="ruby-comment"># or :integer, :&quot;double precision&quot;, etc.</span></pre>
            
            <p>So if you want to insert an array into an integer[] database column:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">insert</span>(:<span class="ruby-identifier">column=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">pg_array</span>([<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]))</pre>
            
            <p>To use this extension, first load it into your <a
            href="../../../../classes/Sequel/Database.html">Sequel::Database</a>
            instance:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">extension</span> :<span class="ruby-identifier">pg_array</span></pre>
            
            <p>See the schema modification guide for details on using postgres array
            columns in CREATE/ALTER TABLE statements.</p>
            
            <p>If you are not using the native postgres or jdbc/postgresql adapter and are
            using array types as model column values you probably should use the the
            pg_typecast_on_load plugin if the column values are returned as a string.</p>
            
            <p>This extension by default includes handlers for array types for all scalar
            types that the native postgres adapter handles. It also makes it easy to
            add support for other array types.  In general, you just need to make sure
            that the scalar type is handled and has the appropriate converter installed
            in Sequel::Postgres::PG_TYPES or the Database instance&#39;s
            conversion_procs usingthe appropriate type OID.  For user defined types,
            you can do this via:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">conversion_procs</span>[<span class="ruby-identifier">scalar_type_oid</span>] = <span class="ruby-identifier">lambda</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">string</span><span class="ruby-operator">|</span> }</pre>
            
            <p>Then you can call <a
            href="../../../../classes/Sequel/Postgres/PGArray/DatabaseMethods.html#method-i-register_array_type">Sequel::Postgres::PGArray::DatabaseMethods#register_array_type</a>
            to automatically set up a handler for the array type.  So if you want to
            support the foo[] type (assuming the foo type is already supported):</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">register_array_type</span>(<span class="ruby-string">&#39;foo&#39;</span>)</pre>
            
            <p>You can also register array types on a global basis using <a
            href="../../../../classes/Sequel/Postgres/PGArray.html#method-c-register">Sequel::Postgres::PGArray.register</a>.
            In this case, you&#39;ll have to specify the type oids:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Postgres</span><span class="ruby-operator">::</span><span class="ruby-constant">PG_TYPES</span>[<span class="ruby-value">1234</span>] = <span class="ruby-identifier">lambda</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">string</span><span class="ruby-operator">|</span> }&#x000A;<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Postgres</span><span class="ruby-operator">::</span><span class="ruby-constant">PGArray</span>.<span class="ruby-identifier">register</span>(<span class="ruby-string">&#39;foo&#39;</span>, :<span class="ruby-identifier">oid=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">4321</span>, :<span class="ruby-identifier">scalar_oid=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1234</span>)</pre>
            
            <p>Both <a
            href="../../../../classes/Sequel/Postgres/PGArray/DatabaseMethods.html#method-i-register_array_type">Sequel::Postgres::PGArray::DatabaseMethods#register_array_type</a>
            and <a
            href="../../../../classes/Sequel/Postgres/PGArray.html#method-c-register">Sequel::Postgres::PGArray.register</a>
            support many options to customize the array type handling.  See the <a
            href="../../../../classes/Sequel/Postgres/PGArray.html#method-c-register">Sequel::Postgres::PGArray.register</a>
            method documentation.</p>
            
            <p>If you want an easy way to call PostgreSQL array functions and operators,
            look into the pg_array_ops extension.</p>
            
            <p>This extension requires the json, strscan, and delegate libraries.</p>
          </div>
          <div id='context'>
            <div id='requires'>
              <h2>Required files</h2>
              <ol>
                <li>delegate</li>
                <li>strscan</li>
                <li>json</li>
                <li>adapters/utils/pg_types</li>
              </ol>
            </div>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
