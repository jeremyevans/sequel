<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>Sequel::Plugins::ConcurrentEagerLoading</title>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='class' id='wrapper'>
<div class='header'>
<h1 class='name'><span class='type'>module</span>
Sequel::Plugins::ConcurrentEagerLoading
</h1>
<ol class='paths'>
<li>
<a href="../../../files/lib/sequel/plugins/concurrent_eager_loading_rb.html">lib/sequel/plugins/concurrent_eager_loading.rb</a>
</li>
</ol>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<p>The <a href="../../../files/lib/sequel/plugins/concurrent_eager_loading_rb.html">concurrent_eager_loading</a> plugin allows for eager loading multiple associations concurrently in separate threads.  You must load the <a href="../../../files/lib/sequel/extensions/async_thread_pool_rb.html">async_thread_pool</a> <a href="../../Database.html"><code>Database</code></a> extension into the <a href="../../Database.html"><code>Database</code></a> object the model class uses in order for this plugin to work.</p>

<p>By default in <a href="../../Sequel.html"><code>Sequel</code></a>, eager loading happens in a serial manner.  If you have code such as:</p>

<pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">eager</span>(<span class="ruby-value">:artist</span>, <span class="ruby-value">:genre</span>, <span class="ruby-value">:tracks</span>)
</pre>

<p><a href="../../Sequel.html"><code>Sequel</code></a> will load the albums, then the artists for the albums, then the genres for the albums, then the tracks for the albums.</p>

<p>With the <a href="../../../files/lib/sequel/plugins/concurrent_eager_loading_rb.html">concurrent_eager_loading</a> plugin, you can use the <code>eager_load_concurrently</code> method to allow for concurrent eager loading:</p>

<pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">eager_load_concurrently</span>.<span class="ruby-identifier">eager</span>(<span class="ruby-value">:artist</span>, <span class="ruby-value">:genre</span>, <span class="ruby-value">:tracks</span>)
</pre>

<p>This will load the albums, first, since it needs to load the albums to know which artists, genres, and tracks to eagerly load. However, it will load the artists, genres, and tracks for the albums concurrently in separate threads. This can significantly improve performance, especially if there is significant latency between the application and the database. Note that using separate threads is only used in the case where there are multiple associations to eagerly load. With only a single association to eagerly load, there is no reason to use a separate thread, since it would not improve performance.</p>

<p>If you want to make concurrent eager loading the default, you can load the plugin with the <code>:always</code> option. In this case, all eager loads will be concurrent.  If you want to force a non-concurrent eager load, you can use <code>eager_load_serially</code>:</p>

<pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">eager_load_serially</span>.<span class="ruby-identifier">eager</span>(<span class="ruby-value">:artist</span>, <span class="ruby-value">:genre</span>, <span class="ruby-value">:tracks</span>)
</pre>

<p>Note that making concurrent eager loading the default is probably a bad idea if you are eager loading inside transactions and want the eager load to reflect changes made inside the transaction, unless you plan to use <code>eager_load_serially</code> for such cases.  See the <a href="../../../files/lib/sequel/extensions/async_thread_pool_rb.html">async_thread_pool</a> <a href="../../Database.html"><code>Database</code></a> extension documentation for more general caveats regarding its use.</p>

<p>The default eager loaders for all of the association types that ship with <a href="../../Sequel.html"><code>Sequel</code></a> support safe concurrent eager loading.  However, if you are specifying a custom <code>:eager_loader</code> for an association, it may not work safely unless it it modified to support concurrent eager loading.  Taking this example from the Advanced Associations guide</p>

<pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">many_to_one</span> <span class="ruby-value">:artist</span>, <span class="ruby-value">eager_loader:</span> (<span class="ruby-identifier">proc</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">eo_opts</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">eo_opts</span>[<span class="ruby-value">:rows</span>].<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">album</span><span class="ruby-operator">|</span> <span class="ruby-identifier">album</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-value">:artist</span>] = <span class="ruby-keyword">nil</span>}
  <span class="ruby-identifier">id_map</span> = <span class="ruby-identifier">eo_opts</span>[<span class="ruby-value">:id_map</span>]
  <span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">id:</span> <span class="ruby-identifier">id_map</span>.<span class="ruby-identifier">keys</span>).<span class="ruby-identifier">all</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">artist</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">albums</span> = <span class="ruby-identifier">id_map</span>[<span class="ruby-identifier">artist</span>.<span class="ruby-identifier">id</span>]
      <span class="ruby-identifier">albums</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">album</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">album</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-value">:artist</span>] = <span class="ruby-identifier">artist</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>)
</pre>

<p>This would not support concurrent eager loading safely.  To support safe concurrent eager loading, you need to make sure you are not modifying the associations for objects concurrently by separate threads.  This is implemented using a mutex, which you can access via <code>eo_opts[:mutex]</code>. To keep things simple, you can use <code>Sequel.synchronize_with</code> to only use this mutex if it is available.  You want to use the mutex around the code that initializes the associations (usually to <code>nil</code> or <code>[]</code>), and also around the code that sets the associatied objects appropriately after they have been retreived.  You do not want to use the mutex around the code that loads the objects, since that will prevent concurrent loading. So after the changes, the custom eager loader would look like this:</p>

<pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">many_to_one</span> <span class="ruby-value">:artist</span>, <span class="ruby-value">eager_loader:</span> (<span class="ruby-identifier">proc</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">eo_opts</span><span class="ruby-operator">|</span>
  <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">synchronize_with</span>(<span class="ruby-identifier">eo</span>[<span class="ruby-value">:mutex</span>]) <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">eo_opts</span>[<span class="ruby-value">:rows</span>].<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">album</span><span class="ruby-operator">|</span> <span class="ruby-identifier">album</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-value">:artist</span>] = <span class="ruby-keyword">nil</span>}
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">id_map</span> = <span class="ruby-identifier">eo_opts</span>[<span class="ruby-value">:id_map</span>]
  <span class="ruby-identifier">rows</span> = <span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">id:</span> <span class="ruby-identifier">id_map</span>.<span class="ruby-identifier">keys</span>).<span class="ruby-identifier">all</span>
  <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">synchronize_with</span>(<span class="ruby-identifier">eo</span>[<span class="ruby-value">:mutex</span>]) <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">rows</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">artist</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">albums</span> = <span class="ruby-identifier">id_map</span>[<span class="ruby-identifier">artist</span>.<span class="ruby-identifier">id</span>]
        <span class="ruby-identifier">albums</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">album</span><span class="ruby-operator">|</span>
          <span class="ruby-identifier">album</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-value">:artist</span>] = <span class="ruby-identifier">artist</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>)
</pre>

<p>Usage:</p>

<pre class="ruby"><span class="ruby-comment"># Make all model subclass datasets support concurrent eager loading</span>
<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:concurrent_eager_loading</span>

<span class="ruby-comment"># Make the Album class datasets support concurrent eager loading</span>
<span class="ruby-constant">Album</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:concurrent_eager_loading</span>

<span class="ruby-comment"># Make all model subclass datasets concurrently eager load by default</span>
<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:concurrent_eager_loading</span>, <span class="ruby-value">always:</span> <span class="ruby-keyword">true</span>
</pre>
</div>
<div id='method-list'>
<h2>Methods</h2>
<h3>Public Class</h3>
<ol>
<li><a href="#method-c-configure">configure</a></li>
</ol>
</div>
<div id='context'>
</div>
<div id='class-list'>
<h2>Classes and Modules</h2>
<ol>
<li><a href="ConcurrentEagerLoading/ClassMethods.html">Sequel::Plugins::ConcurrentEagerLoading::ClassMethods</a></li>
<li><a href="ConcurrentEagerLoading/DatasetMethods.html">Sequel::Plugins::ConcurrentEagerLoading::DatasetMethods</a></li>
</ol>
</div>
<div id='section'>
<div id='methods'>
<h2>Public Class methods</h2>
<div class='method public-class' id='method-method-c-configure'>
<a name='method-c-configure'></a>
<div class='synopsis'>
<span class='name'>configure</span><span class='arguments'>(mod, opts=OPTS)</span>

</div>
<div class='description'>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-c-configure-source&#39;); return false'>
[show source]
</a>
<pre id='method-c-configure-source'>    <span class="ruby-comment"># File lib/sequel/plugins/concurrent_eager_loading.rb</span>
<span class="line-num">105</span> <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier ruby-title">configure</span>(<span class="ruby-identifier">mod</span>, <span class="ruby-identifier">opts</span>=<span class="ruby-constant">OPTS</span>)
<span class="line-num">106</span>   <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-value">:always</span>)
<span class="line-num">107</span>     <span class="ruby-identifier">mod</span>.<span class="ruby-identifier">instance_variable_set</span>(<span class="ruby-value">:@always_eager_load_concurrently</span>, <span class="ruby-identifier">opts</span>[<span class="ruby-value">:always</span>])
<span class="line-num">108</span>   <span class="ruby-keyword">end</span>
<span class="line-num">109</span> <span class="ruby-keyword">end</span></pre>
</div>
</div>
</div>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/jeremyevans/hanna"><strong>Hanna</strong> RDoc template</a>
</div>
</body>
</html>
